language: cpp
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int cnt = 0;\n  for (int i = 0; i < s.size(); i++) {\n    if\
    \ (s[i] == '(') {\n      cnt++;\n    } else {\n      cnt--;\n    }\n    if (cnt\
    \ < 0) {\n      return \"No\";\n    }\n  }\n  if (cnt == 0) {\n    return \"Yes\"\
    ;\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate =\
    \ match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphz0rx_g9.cpp: In function 'int main()':\n/tmp/tmphz0rx_g9.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphz0rx_g9.cpp:2:\n/tmp/tmphz0rx_g9.cpp:39:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmphz0rx_g9.cpp:39:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmphz0rx_g9.cpp:39:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmphz0rx_g9.cpp:39:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmphz0rx_g9.cpp:40:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmphz0rx_g9.cpp:40:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmphz0rx_g9.cpp:40:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 == -1 && c2 == 1) {\n    return \"Yes\";\n  } else {\n    return\
    \ \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4ujy111p.cpp: In function 'int main()':\n/tmp/tmp4ujy111p.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4ujy111p.cpp:2:\n/tmp/tmp4ujy111p.cpp:45:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp4ujy111p.cpp:45:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp4ujy111p.cpp:45:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp4ujy111p.cpp:45:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp4ujy111p.cpp:46:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp4ujy111p.cpp:46:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp4ujy111p.cpp:46:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 > 0 && c2 < 0) {\n    if (c1 == -c2) {\n      return \"Yes\";\n\
    \    } else {\n      return \"No\";\n    }\n  } else if (c1 < 0 && c2 > 0) {\n\
    \    if (c2 == -c1) {\n      return \"Yes\";\n    } else {\n      return \"No\"\
    ;\n    }\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplvoq_pkf.cpp: In function 'int main()':\n/tmp/tmplvoq_pkf.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplvoq_pkf.cpp:2:\n/tmp/tmplvoq_pkf.cpp:55:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmplvoq_pkf.cpp:55:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmplvoq_pkf.cpp:55:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmplvoq_pkf.cpp:55:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmplvoq_pkf.cpp:56:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmplvoq_pkf.cpp:56:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmplvoq_pkf.cpp:56:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto i : lst) {\n    for (auto j : i) {\n \
    \     if (j == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  if (count == 0) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbtnhwmvc.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpbtnhwmvc.cpp:18:13: error: 'i' does not name a type\n   for (auto\
    \ i : lst) {\n             ^\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ';' before\
    \ 'if'\n   if (count == 0) {\n   ^\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected\
    \ primary-expression before 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ';'\
    \ before 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected primary-expression before\
    \ 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ')' before 'if'\n/tmp/tmpbtnhwmvc.cpp:\
    \ In function 'int main()':\n/tmp/tmpbtnhwmvc.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbtnhwmvc.cpp:2:\n/tmp/tmpbtnhwmvc.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpbtnhwmvc.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpbtnhwmvc.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpbtnhwmvc.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpbtnhwmvc.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto str : lst) {\n    for (auto c : str) {\n\
    \      if (c == '(') {\n        count++;\n      } else {\n        count--;\n \
    \     }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4nqjg28h.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp4nqjg28h.cpp:18:13: error: 'str' does not name a type\n   for\
    \ (auto str : lst) {\n             ^\n/tmp/tmp4nqjg28h.cpp:30:3: error: expected\
    \ ';' before 'return'\n   return count == 0 ? \"Yes\" : \"No\";\n   ^\n/tmp/tmp4nqjg28h.cpp:30:3:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp4nqjg28h.cpp:30:3:\
    \ error: expected ';' before 'return'\n/tmp/tmp4nqjg28h.cpp:30:3: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp4nqjg28h.cpp:30:3: error: expected\
    \ ')' before 'return'\n/tmp/tmp4nqjg28h.cpp: In function 'int main()':\n/tmp/tmp4nqjg28h.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4nqjg28h.cpp:2:\n/tmp/tmp4nqjg28h.cpp:34:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp4nqjg28h.cpp:34:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp4nqjg28h.cpp:34:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp4nqjg28h.cpp:34:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp4nqjg28h.cpp:35:47:\
    \ warning: extended initializer lists only available with -std=c++11 "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string str1 = lst[0];\n    std::string str2 = lst[1];\n   \
    \ int count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < str1.length();\
    \ i++) {\n        if (str1[i] == '(') {\n            count1++;\n        } else\
    \ {\n            count1--;\n        }\n    }\n    for (int i = 0; i < str2.length();\
    \ i++) {\n        if (str2[i] == '(') {\n            count2++;\n        } else\
    \ {\n            count2--;\n        }\n    }\n    if (count1 == 0 && count2 ==\
    \ 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph7mjct_t.cpp: In function 'int main()':\n/tmp/tmph7mjct_t.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph7mjct_t.cpp:2:\n/tmp/tmph7mjct_t.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmph7mjct_t.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmph7mjct_t.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmph7mjct_t.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmph7mjct_t.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmph7mjct_t.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmph7mjct_t.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(') {\n        \
    \    c1++;\n        } else {\n            c1--;\n        }\n    }\n    for(int\
    \ i = 0; i < n2; i++) {\n        if(s2[i] == '(') {\n            c2++;\n     \
    \   } else {\n            c2--;\n        }\n    }\n    if(c1 == 0 && c2 == 0)\
    \ {\n        return \"Yes\";\n    } else if(c1 == -1 && c2 == 1) {\n        return\
    \ \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n   \
    \ auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz6n29afn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n \
    \   if (s[i] == '(') {\n      count++;\n    } else {\n      count--;\n    }\n\
    \    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg89x16am.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpswvcjnm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  std::stack<char> st;\n  for (int i = 0; i < s.length(); i++)\
    \ {\n    if (s[i] == '(') {\n      st.push(s[i]);\n    } else {\n      if (st.empty())\
    \ {\n        return \"No\";\n      } else {\n        st.pop();\n      }\n    }\n\
    \  }\n  if (st.empty()) {\n    return \"Yes\";\n  } else {\n    return \"No\"\
    ;\n  }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmldlhcwo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int c1 = 0;\n  int c2 = 0;\n  for (int i = 0; i < n1;\
    \ i++) {\n    if (s1[i] == '(') {\n      c1++;\n    } else {\n      c1--;\n  \
    \  }\n  }\n  for (int i = 0; i < n2; i++) {\n    if (s2[i] == '(') {\n      c2++;\n\
    \    } else {\n      c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return\
    \ \"Yes\";\n  }\n  if (c1 == 0 && c2 != 0) {\n    return \"No\";\n  }\n  if (c1\
    \ != 0 && c2 == 0) {\n    return \"No\";\n  }\n  if (c1 != 0 && c2 != 0) {\n \
    \   if (c1 == c2) {\n      return \"Yes\";\n    } else {\n      return \"No\"\
    ;\n    }\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph7v080ro.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ len1 = s1.length();\n    int len2 = s2.length();\n    int count1 = 0;\n    int\
    \ count2 = 0;\n    for(int i = 0; i < len1; i++) {\n        if(s1[i] == '(') {\n\
    \            count1++;\n        }\n        else {\n            count1--;\n   \
    \     }\n    }\n    for(int i = 0; i < len2; i++) {\n        if(s2[i] == '(')\
    \ {\n            count2++;\n        }\n        else {\n            count2--;\n\
    \        }\n    }\n    if(count1 == 0 && count2 == 0) {\n        return \"Yes\"\
    ;\n    }\n    else {\n        return \"No\";\n    }\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp98vf_ijg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count\
    \ = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(') {\n \
    \     count++;\n    } else {\n      count--;\n    }\n  }\n  for (int i = 0; i\
    \ < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count++;\n    } else {\n\
    \      count--;\n    }\n  }\n  if (count == 0) {\n    return \"Yes\";\n  } else\
    \ {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk2375yui.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpswvcjnm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpswvcjnm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int cnt = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n   \
    \   if (c == '(') {\n        cnt++;\n      } else {\n        cnt--;\n      }\n\
    \      if (cnt < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return cnt\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5x7k4j0f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    for(int i = 0; i < n2; i++)\
    \ {\n        if(s2[i] == '(')\n            c2++;\n        else\n            c2--;\n\
    \    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 ==\
    \ -1 && c2 == 1)\n        return \"Yes\";\n    else if(c1 == 1 && c2 == -1)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu46a0doq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int n = lst.size();\n  int open = 0;\n  int close = 0;\n  for (int\
    \ i = 0; i < n; i++) {\n    for (int j = 0; j < lst[i].size(); j++) {\n      if\
    \ (lst[i][j] == '(') {\n        open++;\n      } else {\n        close++;\n  \
    \    }\n    }\n  }\n  if (open == close) {\n    return \"Yes\";\n  } else {\n\
    \    return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4tmdn65w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (auto c : s1) {\n    if (c == '(') {\n      count1++;\n\
    \    } else {\n      count1--;\n    }\n  }\n  for (auto c : s2) {\n    if (c ==\
    \ '(') {\n      count2++;\n    } else {\n      count2--;\n    }\n  }\n  if (count1\
    \ == 0 && count2 == 0) {\n    return \"Yes\";\n  }\n  if (count1 == 1 && count2\
    \ == -1) {\n    return \"Yes\";\n  }\n  if (count1 == -1 && count2 == 1) {\n \
    \   return \"Yes\";\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppq5f3bk0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // your code here\n  std::string s1 = lst[0];\n  std::string s2 =\
    \ lst[1];\n  int open = 0;\n  int close = 0;\n  for(int i = 0; i < s1.length();\
    \ i++){\n    if(s1[i] == '('){\n      open++;\n    }\n    else{\n      close++;\n\
    \    }\n  }\n  for(int i = 0; i < s2.length(); i++){\n    if(s2[i] == '('){\n\
    \      open++;\n    }\n    else{\n      close++;\n    }\n  }\n  if(open == close){\n\
    \    return \"Yes\";\n  }\n  else{\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4nrf16fr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string a = lst[0];\n    std::string b = lst[1];\n    int count_a\
    \ = 0;\n    int count_b = 0;\n    for (int i = 0; i < a.size(); i++) {\n     \
    \   if (a[i] == '(') {\n            count_a++;\n        } else {\n           \
    \ count_a--;\n        }\n    }\n    for (int i = 0; i < b.size(); i++) {\n   \
    \     if (b[i] == '(') {\n            count_b++;\n        } else {\n         \
    \   count_b--;\n        }\n    }\n    if (count_a == 0 && count_b == 0) {\n  \
    \      return \"Yes\";\n    } else if (count_a > 0 && count_b < 0) {\n       \
    \ if (count_a == -count_b) {\n            return \"Yes\";\n        } else {\n\
    \            return \"No\";\n        }\n    } else if (count_a < 0 && count_b\
    \ > 0) {\n        if (count_a == -count_b) {\n            return \"Yes\";\n  \
    \      } else {\n            return \"No\";\n        }\n    } else {\n       \
    \ return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpaiah4ax_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto s : lst) {\n  \
    \      for (auto c : s) {\n            if (c == '(') {\n                open++;\n\
    \            } else {\n                close++;\n            }\n        }\n  \
    \  }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv3pm6428.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpswvcjnm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto i : lst[0]) {\n\
    \        if (i == '(') {\n            open++;\n        } else {\n            close++;\n\
    \        }\n    }\n    for (auto i : lst[1]) {\n        if (i == '(') {\n    \
    \        open++;\n        } else {\n            close++;\n        }\n    }\n \
    \   if (open == close) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp764fz0vc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (auto i : lst[0]) {\n    if\
    \ (i == '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  for\
    \ (auto i : lst[1]) {\n    if (i == '(') {\n      open++;\n    } else {\n    \
    \  close++;\n    }\n  }\n  if (open == close) {\n    return \"Yes\";\n  } else\
    \ {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjlryck9l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string result = \"\";\n    int open = 0;\n    int close = 0;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == '(') {\n                open++;\n     \
    \       } else {\n                close++;\n            }\n        }\n    }\n\
    \    if (open == close) {\n        result = \"Yes\";\n    } else {\n        result\
    \ = \"No\";\n    }\n    return result;\n}\nint main() {\n    auto candidate =\
    \ match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxq99zkhi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n \
    \   if (s[i] == '(') {\n      count++;\n    } else {\n      count--;\n    }\n\
    \    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg89x16am.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst[0]) {\n        if (i == '(')\
    \ {\n            count++;\n        } else {\n            count--;\n        }\n\
    \    }\n    for (auto i : lst[1]) {\n        if (i == '(') {\n            count++;\n\
    \        } else {\n            count--;\n        }\n    }\n    if (count == 0)\
    \ {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpurvl1fh_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int cnt1 = 0, cnt2 = 0;\n    for (auto s : lst) {\n        for (auto\
    \ c : s) {\n            if (c == '(') {\n                cnt1++;\n           \
    \ } else {\n                cnt2++;\n            }\n        }\n    }\n    if (cnt1\
    \ == cnt2) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n\
    \    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg729odgl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    std::stack<char> st;\n    for (int i = 0; i < s.length();\
    \ i++) {\n        if (s[i] == '(') {\n            st.push(s[i]);\n        } else\
    \ {\n            if (st.empty()) {\n                return \"No\";\n         \
    \   } else {\n                st.pop();\n            }\n        }\n    }\n   \
    \ if (st.empty()) {\n        return \"Yes\";\n    } else {\n        return \"\
    No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3x90p0r2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int s1_open\
    \ = 0;\n  int s1_close = 0;\n  int s2_open = 0;\n  int s2_close = 0;\n  for (int\
    \ i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(') {\n      s1_open++;\n\
    \    } else {\n      s1_close++;\n    }\n  }\n  for (int i = 0; i < s2.length();\
    \ i++) {\n    if (s2[i] == '(') {\n      s2_open++;\n    } else {\n      s2_close++;\n\
    \    }\n  }\n  if (s1_open == s1_close && s2_open == s2_close) {\n    return \"\
    Yes\";\n  } else if (s1_open == s1_close && s2_open != s2_close) {\n    return\
    \ \"No\";\n  } else if (s1_open != s1_close && s2_open == s2_close) {\n    return\
    \ \"No\";\n  } else if (s1_open != s1_close && s2_open != s2_close) {\n    if\
    \ (s1_open > s1_close) {\n      if (s2_open > s2_close) {\n        return \"No\"\
    ;\n      } else {\n        return \"Yes\";\n      }\n    } else {\n      if (s2_open\
    \ > s2_close) {\n        return \"Yes\";\n      } else {\n        return \"No\"\
    ;\n      }\n    }\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph4urh1id.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int c1 = 0;\n  int c2 = 0;\n  for (int i = 0; i < n1;\
    \ i++) {\n    if (s1[i] == '(') {\n      c1++;\n    } else {\n      c1--;\n  \
    \  }\n  }\n  for (int i = 0; i < n2; i++) {\n    if (s2[i] == '(') {\n      c2++;\n\
    \    } else {\n      c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return\
    \ \"Yes\";\n  }\n  if (c1 == 0 && c2 != 0) {\n    return \"No\";\n  }\n  if (c1\
    \ != 0 && c2 == 0) {\n    return \"No\";\n  }\n  if (c1 > 0 && c2 < 0) {\n   \
    \ return \"No\";\n  }\n  if (c1 < 0 && c2 > 0) {\n    return \"No\";\n  }\n  if\
    \ (c1 > 0 && c2 > 0) {\n    return \"Yes\";\n  }\n  if (c1 < 0 && c2 < 0) {\n\
    \    return \"Yes\";\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv9ktx5xd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (auto s : lst) {\n    for (auto\
    \ c : s) {\n      if (c == '(') {\n        open++;\n      } else {\n        close++;\n\
    \      }\n    }\n  }\n  return (open == close) ? \"Yes\" : \"No\";\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpulzy5diu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto str : lst) {\n        for (auto c\
    \ : str) {\n            if (c == '(') {\n                count++;\n          \
    \  } else {\n                count--;\n            }\n            if (count <\
    \ 0) {\n                return \"No\";\n            }\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4vwfw230.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int cnt = 0;\n    for (int i = 0; i < lst.size(); i++) {\n     \
    \   for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == '(')\
    \ {\n                cnt++;\n            } else {\n                cnt--;\n  \
    \          }\n            if (cnt < 0) {\n                return \"No\";\n   \
    \         }\n        }\n    }\n    if (cnt == 0) {\n        return \"Yes\";\n\
    \    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqb4axxfw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n \
    \   if (s[i] == '(') {\n      count++;\n    } else {\n      count--;\n    }\n\
    \    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg89x16am.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // your code here\n  std::string s1 = lst[0];\n  std::string s2 =\
    \ lst[1];\n  int count1 = 0;\n  int count2 = 0;\n  for(int i = 0; i < s1.length();\
    \ i++){\n    if(s1[i] == '('){\n      count1++;\n    }\n    else{\n      count1--;\n\
    \    }\n  }\n  for(int i = 0; i < s2.length(); i++){\n    if(s2[i] == '('){\n\
    \      count2++;\n    }\n    else{\n      count2--;\n    }\n  }\n  if(count1 ==\
    \ 0 && count2 == 0){\n    return \"Yes\";\n  }\n  else if(count1 > 0 && count2\
    \ < 0){\n    if(count1 == abs(count2)){\n      return \"Yes\";\n    }\n    else{\n\
    \      return \"No\";\n    }\n  }\n  else if(count1 < 0 && count2 > 0){\n    if(abs(count1)\
    \ == count2){\n      return \"Yes\";\n    }\n    else{\n      return \"No\";\n\
    \    }\n  }\n  else{\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvykfntio.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto s : lst) {\n        for (auto c :\
    \ s) {\n            if (c == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0594m9ga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s = lst[0] + lst[1];\n  int cnt = 0;\n  for (int i = 0;\
    \ i < s.size(); i++) {\n    if (s[i] == '(') {\n      cnt++;\n    } else {\n \
    \     cnt--;\n    }\n    if (cnt < 0) {\n      return \"No\";\n    }\n  }\n  if\
    \ (cnt == 0) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp567nn5hl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ len1 = s1.length();\n    int len2 = s2.length();\n    int count1 = 0;\n    int\
    \ count2 = 0;\n    for(int i = 0; i < len1; i++) {\n        if(s1[i] == '(') {\n\
    \            count1++;\n        }\n        else {\n            count1--;\n   \
    \     }\n    }\n    for(int i = 0; i < len2; i++) {\n        if(s2[i] == '(')\
    \ {\n            count2++;\n        }\n        else {\n            count2--;\n\
    \        }\n    }\n    if(count1 == 0 && count2 == 0) {\n        return \"Yes\"\
    ;\n    }\n    else {\n        return \"No\";\n    }\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp98vf_ijg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    for(int i = 0; i < n2; i++)\
    \ {\n        if(s2[i] == '(')\n            c2++;\n        else\n            c2--;\n\
    \    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 ==\
    \ -1 && c2 == 1)\n        return \"Yes\";\n    else if(c1 == 1 && c2 == -1)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu46a0doq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 == 0 && c2 != 0) {\n    return \"No\";\n  } else if (c1 != 0 &&\
    \ c2 == 0) {\n    return \"No\";\n  } else if (c1 < 0 && c2 < 0) {\n    return\
    \ \"No\";\n  } else if (c1 > 0 && c2 > 0) {\n    return \"No\";\n  } else {\n\
    \    return \"Yes\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxhof7le5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto s : lst) {\n        for (auto c :\
    \ s) {\n            if (c == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0594m9ga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 == 0 && c2 != 0) {\n    if (c2 > 0) {\n      for (int i = 0; i <\
    \ s1.length(); i++) {\n        if (s1[i] == '(') {\n          c2--;\n        }\n\
    \        if (c2 == 0) {\n          return \"Yes\";\n        }\n      }\n    }\
    \ else {\n      for (int i = 0; i < s1.length(); i++) {\n        if (s1[i] ==\
    \ ')') {\n          c2++;\n        }\n        if (c2 == 0) {\n          return\
    \ \"Yes\";\n        }\n      }\n    }\n  } else if (c1 != 0 && c2 == 0) {\n  \
    \  if (c1 > 0) {\n      for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n          c1--;\n        }\n        if (c1 == 0) {\n          return\
    \ \"Yes\";\n        }\n      }\n    } else {\n      for (int i = 0; i < s2.length();\
    \ i++) {\n        if (s2[i] == ')') {\n          c1++;\n        }\n        if\
    \ (c1 == 0) {\n          return \"Yes\";\n        }\n      }\n    }\n  } else\
    \ {\n    return \"No\";\n  }\n\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppomwlll5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string str1 = lst[0];\n    std::string str2 = lst[1];\n   \
    \ int count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < str1.length();\
    \ i++) {\n        if (str1[i] == '(') {\n            count1++;\n        } else\
    \ {\n            count1--;\n        }\n    }\n    for (int i = 0; i < str2.length();\
    \ i++) {\n        if (str2[i] == '(') {\n            count2++;\n        } else\
    \ {\n            count2--;\n        }\n    }\n    if (count1 == 0 && count2 ==\
    \ 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph7mjct_t.cpp: In function 'int main()':\n/tmp/tmph7mjct_t.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph7mjct_t.cpp:2:\n/tmp/tmph7mjct_t.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmph7mjct_t.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmph7mjct_t.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmph7mjct_t.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmph7mjct_t.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmph7mjct_t.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmph7mjct_t.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 == 0 && c2 != 0) {\n    if (c2 > 0) {\n      for (int i = 0; i <\
    \ s1.length(); i++) {\n        if (s1[i] == '(') {\n          c2--;\n        }\n\
    \        if (c2 == 0) {\n          return \"Yes\";\n        }\n      }\n    }\
    \ else {\n      for (int i = 0; i < s1.length(); i++) {\n        if (s1[i] ==\
    \ ')') {\n          c2++;\n        }\n        if (c2 == 0) {\n          return\
    \ \"Yes\";\n        }\n      }\n    }\n  } else if (c1 != 0 && c2 == 0) {\n  \
    \  if (c1 > 0) {\n      for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n          c1--;\n        }\n        if (c1 == 0) {\n          return\
    \ \"Yes\";\n        }\n      }\n    } else {\n      for (int i = 0; i < s2.length();\
    \ i++) {\n        if (s2[i] == ')') {\n          c1++;\n        }\n        if\
    \ (c1 == 0) {\n          return \"Yes\";\n        }\n      }\n    }\n  } else\
    \ {\n    return \"No\";\n  }\n\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppomwlll5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  std::stack<char> st;\n  for (int i = 0; i < s.length(); i++)\
    \ {\n    if (s[i] == '(') {\n      st.push(s[i]);\n    } else {\n      if (st.empty())\
    \ {\n        return \"No\";\n      } else {\n        st.pop();\n      }\n    }\n\
    \  }\n  if (st.empty()) {\n    return \"Yes\";\n  } else {\n    return \"No\"\
    ;\n  }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmldlhcwo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int sum = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n   \
    \   if (c == '(') {\n        sum++;\n      } else {\n        sum--;\n      }\n\
    \      if (sum < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return sum\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpisyrvr6c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int i = 0;\n  int j = 0;\n  int cnt = 0;\n  while (i\
    \ < n1 && j < n2) {\n    if (s1[i] == '(') {\n      cnt++;\n    } else {\n   \
    \   cnt--;\n    }\n    if (s2[j] == '(') {\n      cnt++;\n    } else {\n     \
    \ cnt--;\n    }\n    if (cnt < 0) {\n      return \"No\";\n    }\n    i++;\n \
    \   j++;\n  }\n  while (i < n1) {\n    if (s1[i] == '(') {\n      cnt++;\n   \
    \ } else {\n      cnt--;\n    }\n    if (cnt < 0) {\n      return \"No\";\n  \
    \  }\n    i++;\n  }\n  while (j < n2) {\n    if (s2[j] == '(') {\n      cnt++;\n\
    \    } else {\n      cnt--;\n    }\n    if (cnt < 0) {\n      return \"No\";\n\
    \    }\n    j++;\n  }\n  if (cnt == 0) {\n    return \"Yes\";\n  } else {\n  \
    \  return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7a5vqe3e.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(')\n                count++;\n            else\n\
    \                count--;\n            if (count < 0)\n                return\
    \ \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuxmn04vj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // your code here\n  std::string s1 = lst[0];\n  std::string s2 =\
    \ lst[1];\n  std::string s3 = s1 + s2;\n  std::string s4 = s2 + s1;\n  int count\
    \ = 0;\n  for (int i = 0; i < s3.length(); i++) {\n    if (s3[i] == '(') {\n \
    \     count++;\n    } else {\n      count--;\n    }\n    if (count < 0) {\n  \
    \    break;\n    }\n  }\n  if (count == 0) {\n    return \"Yes\";\n  }\n  count\
    \ = 0;\n  for (int i = 0; i < s4.length(); i++) {\n    if (s4[i] == '(') {\n \
    \     count++;\n    } else {\n      count--;\n    }\n    if (count < 0) {\n  \
    \    break;\n    }\n  }\n  if (count == 0) {\n    return \"Yes\";\n  }\n  return\
    \ \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpelvsi_zm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string first = lst[0];\n  std::string second = lst[1];\n  int\
    \ first_count = 0;\n  int second_count = 0;\n  for (int i = 0; i < first.length();\
    \ i++) {\n    if (first[i] == '(') {\n      first_count++;\n    } else {\n   \
    \   first_count--;\n    }\n  }\n  for (int i = 0; i < second.length(); i++) {\n\
    \    if (second[i] == '(') {\n      second_count++;\n    } else {\n      second_count--;\n\
    \    }\n  }\n  if (first_count == 0 && second_count == 0) {\n    return \"Yes\"\
    ;\n  } else if (first_count == 0 && second_count != 0) {\n    return \"No\";\n\
    \  } else if (first_count != 0 && second_count == 0) {\n    return \"No\";\n \
    \ } else if (first_count > 0 && second_count < 0) {\n    return \"No\";\n  } else\
    \ if (first_count < 0 && second_count > 0) {\n    return \"No\";\n  } else if\
    \ (first_count > 0 && second_count > 0) {\n    return \"Yes\";\n  } else if (first_count\
    \ < 0 && second_count < 0) {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp69ijo7b3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s3 = s1 + s2;\n    std::stack<char> st;\n    for (int i = 0; i < s3.length();\
    \ i++) {\n        if (s3[i] == '(') {\n            st.push(s3[i]);\n        }\
    \ else {\n            if (st.empty()) {\n                return \"No\";\n    \
    \        } else {\n                st.pop();\n            }\n        }\n    }\n\
    \    if (st.empty()) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpihf4_1gj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto s : lst) {\n  \
    \      for (auto c : s) {\n            if (c == '(') {\n                open++;\n\
    \            } else {\n                close++;\n            }\n        }\n  \
    \  }\n    if (open == close) {\n        return \"Yes\";\n    } else {\n      \
    \  return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu1ozu_iu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto i : lst[0]) {\n\
    \        if (i == '(') {\n            open++;\n        } else {\n            close++;\n\
    \        }\n    }\n    for (auto i : lst[1]) {\n        if (i == '(') {\n    \
    \        open++;\n        } else {\n            close++;\n        }\n    }\n \
    \   if (open == close) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp764fz0vc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // your code here\n  std::string s1 = lst[0];\n  std::string s2 =\
    \ lst[1];\n  int count1 = 0;\n  int count2 = 0;\n  for(int i = 0; i < s1.length();\
    \ i++){\n    if(s1[i] == '('){\n      count1++;\n    }\n    else{\n      count1--;\n\
    \    }\n  }\n  for(int i = 0; i < s2.length(); i++){\n    if(s2[i] == '('){\n\
    \      count2++;\n    }\n    else{\n      count2--;\n    }\n  }\n  if(count1 ==\
    \ 0 && count2 == 0){\n    return \"Yes\";\n  }\n  else if(count1 < 0 && count2\
    \ > 0){\n    if(count1 + count2 == 0){\n      return \"Yes\";\n    }\n    else{\n\
    \      return \"No\";\n    }\n  }\n  else if(count1 > 0 && count2 < 0){\n    if(count1\
    \ + count2 == 0){\n      return \"Yes\";\n    }\n    else{\n      return \"No\"\
    ;\n    }\n  }\n  else{\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppiy99d8i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(') {\n        \
    \    c1++;\n        } else {\n            c1--;\n        }\n    }\n    for(int\
    \ i = 0; i < n2; i++) {\n        if(s2[i] == '(') {\n            c2++;\n     \
    \   } else {\n            c2--;\n        }\n    }\n    if(c1 == 0 && c2 == 0)\
    \ {\n        return \"Yes\";\n    } else if(c1 == 0 && c2 != 0) {\n        if(c2\
    \ % 2 == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    } else if(c1 != 0 && c2 == 0) {\n        if(c1 % 2 ==\
    \ 0) {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    } else {\n        if((c1 + c2) % 2 == 0) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpaxobw_lq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto i : lst[0]) {\n\
    \        if (i == '(') {\n            open++;\n        } else {\n            close++;\n\
    \        }\n    }\n    for (auto i : lst[1]) {\n        if (i == '(') {\n    \
    \        open++;\n        } else {\n            close++;\n        }\n    }\n \
    \   if (open == close) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp764fz0vc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int left = 0;\n  int right = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      left++;\n    } else {\n      right++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      left++;\n    } else {\n      right++;\n    }\n  }\n  if (left\
    \ == right) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdjom2n6p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpswvcjnm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string str1 = lst[0];\n  std::string str2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < str1.length(); i++) {\n    if\
    \ (str1[i] == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n\
    \  }\n  for (int i = 0; i < str2.length(); i++) {\n    if (str2[i] == '(') {\n\
    \      count2++;\n    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0\
    \ && count2 == 0) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf6_66jig.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    // your code here\n    std::string s1 = lst[0];\n    std::string\
    \ s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    for(int i = 0; i\
    \ < s1.length(); i++){\n        if(s1[i] == '('){\n            count1++;\n   \
    \     }\n        else{\n            count1--;\n        }\n    }\n    for(int i\
    \ = 0; i < s2.length(); i++){\n        if(s2[i] == '('){\n            count2++;\n\
    \        }\n        else{\n            count2--;\n        }\n    }\n    if(count1\
    \ == 0 && count2 == 0){\n        return \"Yes\";\n    }\n    else if(count1 <\
    \ 0 && count2 < 0){\n        return \"No\";\n    }\n    else if(count1 > 0 &&\
    \ count2 > 0){\n        return \"No\";\n    }\n    else{\n        return \"Yes\"\
    ;\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpskehpzl6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int c1 = 0;\n  int c2 = 0;\n  for (int i = 0; i < n1;\
    \ i++) {\n    if (s1[i] == '(') {\n      c1++;\n    } else {\n      c1--;\n  \
    \  }\n  }\n  for (int i = 0; i < n2; i++) {\n    if (s2[i] == '(') {\n      c2++;\n\
    \    } else {\n      c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return\
    \ \"Yes\";\n  }\n  if (c1 == 0 && c2 != 0) {\n    return \"No\";\n  }\n  if (c1\
    \ != 0 && c2 == 0) {\n    return \"No\";\n  }\n  if (c1 > 0 && c2 < 0) {\n   \
    \ return \"No\";\n  }\n  if (c1 < 0 && c2 > 0) {\n    return \"No\";\n  }\n  if\
    \ (c1 > 0 && c2 > 0) {\n    return \"Yes\";\n  }\n  if (c1 < 0 && c2 < 0) {\n\
    \    return \"Yes\";\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv9ktx5xd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s3 = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s3.length(); i++)\
    \ {\n        if (s3[i] == '(') {\n            count++;\n        } else {\n   \
    \         count--;\n        }\n        if (count < 0) {\n            return \"\
    No\";\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    }\
    \ else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate =\
    \ match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3wfr2jey.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      open++;\n    } else {\n      close++;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  if (open\
    \ == close) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp2ua1gqs.cpp: In function 'int main()':\n/tmp/tmpp2ua1gqs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp2ua1gqs.cpp:2:\n/tmp/tmpp2ua1gqs.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpp2ua1gqs.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpp2ua1gqs.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpp2ua1gqs.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpp2ua1gqs.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpp2ua1gqs.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto i : lst) {\n    for (auto j : i) {\n \
    \     if (j == '(') {\n        count++;\n      } else {\n        count--;\n  \
    \    }\n      if (count < 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  if (count == 0) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbtnhwmvc.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpbtnhwmvc.cpp:18:13: error: 'i' does not name a type\n   for (auto\
    \ i : lst) {\n             ^\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ';' before\
    \ 'if'\n   if (count == 0) {\n   ^\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected\
    \ primary-expression before 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ';'\
    \ before 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected primary-expression before\
    \ 'if'\n/tmp/tmpbtnhwmvc.cpp:30:3: error: expected ')' before 'if'\n/tmp/tmpbtnhwmvc.cpp:\
    \ In function 'int main()':\n/tmp/tmpbtnhwmvc.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbtnhwmvc.cpp:2:\n/tmp/tmpbtnhwmvc.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpbtnhwmvc.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpbtnhwmvc.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpbtnhwmvc.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpbtnhwmvc.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int left = 0;\n  int right = 0;\n  for (auto s : lst) {\n    for (auto\
    \ c : s) {\n      if (c == '(') {\n        left++;\n      } else {\n        right++;\n\
    \      }\n    }\n  }\n  return left == right ? \"Yes\" : \"No\";\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa3xott7s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int c1 = 0;\n  int c2 = 0;\n  for (int i = 0; i < n1;\
    \ i++) {\n    if (s1[i] == '(')\n      c1++;\n    else\n      c1--;\n  }\n  for\
    \ (int i = 0; i < n2; i++) {\n    if (s2[i] == '(')\n      c2++;\n    else\n \
    \     c2--;\n  }\n  if (c1 == 0 && c2 == 0)\n    return \"Yes\";\n  else if (c1\
    \ == 0 && c2 != 0) {\n    if (c2 > 0) {\n      for (int i = 0; i < n1; i++) {\n\
    \        if (s1[i] == '(')\n          c2--;\n        if (c2 == 0)\n          return\
    \ \"Yes\";\n      }\n    } else {\n      for (int i = 0; i < n1; i++) {\n    \
    \    if (s1[i] == ')')\n          c2++;\n        if (c2 == 0)\n          return\
    \ \"Yes\";\n      }\n    }\n  } else if (c1 != 0 && c2 == 0) {\n    if (c1 > 0)\
    \ {\n      for (int i = 0; i < n2; i++) {\n        if (s2[i] == '(')\n       \
    \   c1--;\n        if (c1 == 0)\n          return \"Yes\";\n      }\n    } else\
    \ {\n      for (int i = 0; i < n2; i++) {\n        if (s2[i] == ')')\n       \
    \   c1++;\n        if (c1 == 0)\n          return \"Yes\";\n      }\n    }\n \
    \ }\n  return \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp16lc6yv5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (auto i : lst[0]) {\n    if\
    \ (i == '(') {\n      open++;\n    } else {\n      close++;\n    }\n  }\n  for\
    \ (auto i : lst[1]) {\n    if (i == '(') {\n      open++;\n    } else {\n    \
    \  close++;\n    }\n  }\n  if (open == close) {\n    return \"Yes\";\n  } else\
    \ {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjlryck9l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s = \"\";\n    for (int i = 0; i < lst.size(); i++)\
    \ {\n        s += lst[i];\n    }\n    int count = 0;\n    for (int i = 0; i <\
    \ s.length(); i++) {\n        if (s[i] == '(') {\n            count++;\n     \
    \   } else {\n            count--;\n        }\n        if (count < 0) {\n    \
    \        return \"No\";\n        }\n    }\n    if (count == 0) {\n        return\
    \ \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n   \
    \ auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp60ag83ek.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int c1 = 0;\n\
    \  int c2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i] == '(')\
    \ {\n      c1++;\n    } else {\n      c1--;\n    }\n  }\n  for (int i = 0; i <\
    \ s2.length(); i++) {\n    if (s2[i] == '(') {\n      c2++;\n    } else {\n  \
    \    c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return \"Yes\";\n  }\
    \ else if (c1 > 0 && c2 < 0) {\n    if (c1 == -c2) {\n      return \"Yes\";\n\
    \    } else {\n      return \"No\";\n    }\n  } else if (c1 < 0 && c2 > 0) {\n\
    \    if (c2 == -c1) {\n      return \"Yes\";\n    } else {\n      return \"No\"\
    ;\n    }\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplvoq_pkf.cpp: In function 'int main()':\n/tmp/tmplvoq_pkf.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplvoq_pkf.cpp:2:\n/tmp/tmplvoq_pkf.cpp:55:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmplvoq_pkf.cpp:55:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmplvoq_pkf.cpp:55:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmplvoq_pkf.cpp:55:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmplvoq_pkf.cpp:56:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmplvoq_pkf.cpp:56:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmplvoq_pkf.cpp:56:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n \
    \     if (c == '(')\n        count++;\n      else\n        count--;\n      if\
    \ (count < 0)\n        return \"No\";\n    }\n  }\n  return count == 0 ? \"Yes\"\
    \ : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppz_fy2g8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < s1.length(); i++) {\n    \
    \    if (s1[i] == '(') {\n            c1++;\n        } else {\n            c1--;\n\
    \        }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i]\
    \ == '(') {\n            c2++;\n        } else {\n            c2--;\n        }\n\
    \    }\n    if (c1 == 0 && c2 == 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpui1j8ise.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(') {\n        \
    \    c1++;\n        } else {\n            c1--;\n        }\n    }\n    for(int\
    \ i = 0; i < n2; i++) {\n        if(s2[i] == '(') {\n            c2++;\n     \
    \   } else {\n            c2--;\n        }\n    }\n    if(c1 == 0 && c2 == 0)\
    \ {\n        return \"Yes\";\n    } else if(c1 == 0 && c2 != 0) {\n        if(c2\
    \ > 0) {\n            if(s1[0] == '(') {\n                return \"Yes\";\n  \
    \          } else {\n                return \"No\";\n            }\n        }\
    \ else {\n            if(s1[n1 - 1] == ')') {\n                return \"Yes\"\
    ;\n            } else {\n                return \"No\";\n            }\n     \
    \   }\n    } else if(c1 != 0 && c2 == 0) {\n        if(c1 > 0) {\n           \
    \ if(s2[0] == '(') {\n                return \"Yes\";\n            } else {\n\
    \                return \"No\";\n            }\n        } else {\n           \
    \ if(s2[n2 - 1] == ')') {\n                return \"Yes\";\n            } else\
    \ {\n                return \"No\";\n            }\n        }\n    } else {\n\
    \        if(c1 > 0 && c2 > 0) {\n            if(s1[0] == '(' && s2[0] == '(')\
    \ {\n                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else if(c1 < 0 && c2 < 0) {\n            if(s1[n1\
    \ - 1] == ')' && s2[n2 - 1] == ')') {\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphehff99r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int n = lst.size();\n  std::string ans = \"Yes\";\n  for (int i =\
    \ 0; i < n; i++) {\n    int cnt = 0;\n    for (int j = 0; j < lst[i].size(); j++)\
    \ {\n      if (lst[i][j] == '(') {\n        cnt++;\n      } else {\n        cnt--;\n\
    \      }\n      if (cnt < 0) {\n        ans = \"No\";\n        break;\n      }\n\
    \    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmzggymy9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n \
    \   if (s[i] == '(') {\n      count++;\n    } else {\n      count--;\n    }\n\
    \    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg89x16am.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    for\
    \ (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == '(') {\n     \
    \   count++;\n      } else {\n        count--;\n      }\n      if (count < 0)\
    \ {\n        return \"No\";\n      }\n    }\n  }\n  if (count == 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gcjplgp.cpp: In function 'int main()':\n/tmp/tmp9gcjplgp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gcjplgp.cpp:2:\n/tmp/tmp9gcjplgp.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp9gcjplgp.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp9gcjplgp.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp9gcjplgp.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp9gcjplgp.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp9gcjplgp.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int count1 = 0;\n  int count2 = 0;\n  for (int i = 0; i < lst[0].size();\
    \ i++) {\n    if (lst[0][i] == '(') {\n      count1++;\n    } else {\n      count1--;\n\
    \    }\n  }\n  for (int i = 0; i < lst[1].size(); i++) {\n    if (lst[1][i] ==\
    \ '(') {\n      count2++;\n    } else {\n      count2--;\n    }\n  }\n  if (count1\
    \ == 0 && count2 == 0) {\n    return \"Yes\";\n  } else if (count1 > 0 && count2\
    \ < 0) {\n    return \"Yes\";\n  } else if (count1 < 0 && count2 > 0) {\n    return\
    \ \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdqqwzl0x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].size();\
    \ i++) {\n        if (lst[0][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    for (int i = 0; i < lst[1].size();\
    \ i++) {\n        if (lst[1][i] == '(') {\n            open++;\n        } else\
    \ {\n            close++;\n        }\n    }\n    if (open == close) {\n      \
    \  return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprx4pynqd.cpp: In function 'int main()':\n/tmp/tmprx4pynqd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx4pynqd.cpp:2:\n/tmp/tmprx4pynqd.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmprx4pynqd.cpp:41:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprx4pynqd.cpp:41:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmprx4pynqd.cpp:42:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmprx4pynqd.cpp:42:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmprx4pynqd.cpp:42:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  std::string\
    \ s = s1 + s2;\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n \
    \   if (s[i] == '(') {\n      count++;\n    } else {\n      count--;\n    }\n\
    \    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg89x16am.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ n1 = s1.length();\n    int n2 = s2.length();\n    int count1 = 0;\n    int count2\
    \ = 0;\n    for(int i = 0; i < n1; i++) {\n        if(s1[i] == '(') {\n      \
    \      count1++;\n        }\n        else {\n            count1--;\n        }\n\
    \    }\n    for(int i = 0; i < n2; i++) {\n        if(s2[i] == '(') {\n      \
    \      count2++;\n        }\n        else {\n            count2--;\n        }\n\
    \    }\n    if(count1 == 0 && count2 == 0) {\n        return \"Yes\";\n    }\n\
    \    else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwqzneolc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (std::string s : lst)\
    \ {\n        for (char c : s) {\n            if (c == '(') {\n               \
    \ open++;\n            } else {\n                close++;\n            }\n   \
    \     }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp93ucswwt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    std::string\
    \ s = s1 + s2;\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (s[i] == '(') {\n            count++;\n        } else {\n        \
    \    count--;\n        }\n        if (count < 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb7f4l0c1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto s : lst) {\n        for (auto c :\
    \ s) {\n            if (c == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0594m9ga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto i : lst[0]) {\n\
    \        if (i == '(') {\n            open++;\n        } else {\n            close++;\n\
    \        }\n    }\n    for (auto i : lst[1]) {\n        if (i == '(') {\n    \
    \        open++;\n        } else {\n            close++;\n        }\n    }\n \
    \   if (open == close) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp764fz0vc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int open = 0;\n    int close = 0;\n    for (auto s : lst) {\n  \
    \      for (auto c : s) {\n            if (c == '(') {\n                open++;\n\
    \            } else {\n                close++;\n            }\n        }\n  \
    \  }\n    if (open == close) {\n        return \"Yes\";\n    } else {\n      \
    \  return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu1ozu_iu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int cnt = 0;\n    for (auto s : lst) {\n        for (auto c : s)\
    \ {\n            if (c == '(') cnt++;\n            else cnt--;\n            if\
    \ (cnt < 0) return \"No\";\n        }\n    }\n    return cnt == 0 ? \"Yes\" :\
    \ \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp58960ncr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int open = 0;\n  int close = 0;\n  for (auto s : lst) {\n    for (auto\
    \ c : s) {\n      if (c == '(') {\n        open++;\n      } else {\n        close++;\n\
    \      }\n    }\n  }\n  if (open == close) {\n    return \"Yes\";\n  } else {\n\
    \    return \"No\";\n  }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd2hsx7lv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1[i] ==\
    \ '(') {\n            count++;\n        } else {\n            count--;\n     \
    \   }\n    }\n    for (int i = 0; i < s2.length(); i++) {\n        if (s2[i] ==\
    \ '(') {\n            count++;\n        } else {\n            count--;\n     \
    \   }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    } else {\n \
    \       return \"No\";\n    }\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o2kazwq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  int cnt = 0;\n  for (auto s : lst) {\n    for (auto c : s) {\n   \
    \   if (c == '(') {\n        cnt++;\n      } else {\n        cnt--;\n      }\n\
    \      if (cnt < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return cnt\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5x7k4j0f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto s : lst) {\n        for (auto c :\
    \ s) {\n            if (c == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0594m9ga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n   \
    \     for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ '(') {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n    }\n    if (count == 0) {\n        return \"Yes\"\
    ;\n    } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb21_oj5.cpp: In function 'int main()':\n/tmp/tmpxb21_oj5.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb21_oj5.cpp:2:\n/tmp/tmpxb21_oj5.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpxb21_oj5.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxb21_oj5.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpxb21_oj5.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpxb21_oj5.cpp:39:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpxb21_oj5.cpp:39:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto i : lst) {\n        for (auto j :\
    \ i) {\n            if (j == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n   \
    \ }\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcdf0sxj6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcdf0sxj6.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmpcdf0sxj6.cpp:30:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpcdf0sxj6.cpp:30:5: error: expected ')' before 'if'\n/tmp/tmpcdf0sxj6.cpp:\
    \ In function 'int main()':\n/tmp/tmpcdf0sxj6.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcdf0sxj6.cpp:2:\n/tmp/tmpcdf0sxj6.cpp:38:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpcdf0sxj6.cpp:38:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcdf0sxj6.cpp:38:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpcdf0sxj6.cpp:39:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by defa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int n1 = s1.size();\n\
    \  int n2 = s2.size();\n  int c1 = 0;\n  int c2 = 0;\n  for (int i = 0; i < n1;\
    \ i++) {\n    if (s1[i] == '(') {\n      c1++;\n    } else {\n      c1--;\n  \
    \  }\n  }\n  for (int i = 0; i < n2; i++) {\n    if (s2[i] == '(') {\n      c2++;\n\
    \    } else {\n      c2--;\n    }\n  }\n  if (c1 == 0 && c2 == 0) {\n    return\
    \ \"Yes\";\n  }\n  if (c1 == 0 && c2 < 0) {\n    return \"No\";\n  }\n  if (c1\
    \ > 0 && c2 == 0) {\n    return \"No\";\n  }\n  if (c1 > 0 && c2 < 0) {\n    if\
    \ (c1 == -c2) {\n      return \"Yes\";\n    } else {\n      return \"No\";\n \
    \   }\n  }\n  if (c1 < 0 && c2 > 0) {\n    if (c2 == -c1) {\n      return \"Yes\"\
    ;\n    } else {\n      return \"No\";\n    }\n  }\n  if (c1 < 0 && c2 < 0) {\n\
    \    return \"No\";\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfze15o3u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count1\
    \ = 0;\n  int count2 = 0;\n  for (int i = 0; i < s1.length(); i++) {\n    if (s1[i]\
    \ == '(') {\n      count1++;\n    } else {\n      count1--;\n    }\n  }\n  for\
    \ (int i = 0; i < s2.length(); i++) {\n    if (s2[i] == '(') {\n      count2++;\n\
    \    } else {\n      count2--;\n    }\n  }\n  if (count1 == 0 && count2 == 0)\
    \ {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1if8do8w.cpp: In function 'int main()':\n/tmp/tmp1if8do8w.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1if8do8w.cpp:2:\n/tmp/tmp1if8do8w.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp1if8do8w.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp1if8do8w.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp1if8do8w.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmp1if8do8w.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmp1if8do8w.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    int count = 0;\n    for (auto s : lst) {\n        for (auto c :\
    \ s) {\n            if (c == '(') {\n                count++;\n            } else\
    \ {\n                count--;\n            }\n            if (count < 0) {\n \
    \               return \"No\";\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0594m9ga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s1 = lst[0];\n    std::string s2 = lst[1];\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < s1.length(); i++)\
    \ {\n        if (s1[i] == '(') {\n            count1++;\n        } else {\n  \
    \          count1--;\n        }\n    }\n    for (int i = 0; i < s2.length(); i++)\
    \ {\n        if (s2[i] == '(') {\n            count2++;\n        } else {\n  \
    \          count2--;\n        }\n    }\n    if (count1 == 0 && count2 == 0) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpksh29575.cpp: In function 'int main()':\n/tmp/tmpksh29575.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksh29575.cpp:2:\n/tmp/tmpksh29575.cpp:43:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpksh29575.cpp:43:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpksh29575.cpp:43:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpksh29575.cpp:44:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpksh29575.cpp:44:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpksh29575.cpp:44:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
