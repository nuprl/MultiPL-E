name: HumanEval_129_minPath
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once\
  \ on the cells of the grid.\n// You have to find the minimum path of length k in\
  \ the grid. You can start\n// from any cell, and in each step you can move to any\
  \ of the neighbor cells,\n// in other words, you can go to cells which share an\
  \ edge with you current\n// cell.\n// Please note that a path of length k means\
  \ visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off\
  \ the grid.\n// A path A (of length k) is considered less than a path B (of length\
  \ k) if\n// after making the ordered vectors of the values on the cells that A and\
  \ B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n// than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j]\
  \ = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered\
  \ vector of the values on the cells that the minimum path go through.\n// Examples:\
  \    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n//\
  \ (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n//\
  \ (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>>\
  \ grid, long k) {\n"
tests: "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) ==\
  \ (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) ==\
  \ (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6,\
  \ (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11,\
  \ (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15,\
  \ (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5,\
  \ (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16,\
  \ (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14,\
  \ (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1,\
  \ (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8,\
  \ (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4,\
  \ (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7,\
  \ (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10,\
  \ (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1,\
  \ (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11,\
  \ (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15,\
  \ (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10,\
  \ (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6,\
  \ (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12,\
  \ (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9,\
  \ (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8,\
  \ (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1,\
  \ (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2,\
  \ (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}),\
  \ (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}),\
  \ (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1,\
  \ (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10))\
  \ == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1,\
  \ (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10))\
  \ == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3, (long)1, (long)3})));\n}\n"
completions: ["    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < m; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long cur = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < cur) {\n          \
    \      cur = dp[i][j][k];\n                ans = {grid[i][j]};\n            }\
    \ else if (dp[i][j][k] == cur) {\n               ", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \                ans = std::vector<long>({grid[i][j]});\n            }\n     \
    \   }\n    }\n    for (int l = k - 1", "    // Your code here\n    std::vector<long>\
    \ res;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < m; j++) {\n            if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n;", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int len = 2; len\
    \ <= k; len++) {\n        for(int i = 0; i < n; i++) {\n            for(int j\
    \ = 0; j < n; j++) {\n                if(i > 0) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i-1][j][len-1]);\n                }\n         \
    \       if(i < n-1) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i+1][j][len-1]);\n                }\n                if(j > 0) {\n      \
    \              dp[i][j][len] = std::min(dp[i][j][len], dp[i][j-1][len-1]);\n \
    \               }\n                if(j < n-1) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i][j+1][len-1]);\n                }\n         \
    \       dp[i][j][len] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long min_val = INT_MAX;\n    for(int i = 0; i < n; i++) {\n      \
    \  for(int j = 0; j < n; j++) {\n            if(dp[i][j][k] < min_val) {\n   \
    \             min_val = dp[i][j][k];\n                ans.clear();\n         \
    \       ans.push_back(grid[i][j]);\n            } else if(dp[i][", "    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < m; j++) {\n                for (int\
    \ x = 0; x < n; x++) {\n                    for (int y = 0; y < m; y++) {\n  \
    \                      if (abs(x - i) + abs(y - j) == 1) {\n                 \
    \           if (dp[x][y][len - 1] != -1) {\n                                if\
    \ (dp[i][j][len] == -1 || dp[i][j][len] > dp[x][y][len - 1] + grid[i][j]) {\n\
    \                                    dp[i][j][len] = dp[x][y][len - 1] + grid[i][j];\n\
    \                                    path[i][j][len] = path[x][y][len - 1];\n\
    \                                    path[i][j][len].push_back(grid[i][j]);\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k);\n    ans[k - 1] = grid[0][0];\n    int i = 0, j = 0;\n    for (int l\
    \ = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] == dp[i][j][l\
    \ + 1] - grid[i][j]) {\n            ans[l - 1] = grid[i - 1][j];\n           \
    \ i--;\n        } else if", "    int n = grid.size();\n    assert(n >= 2);\n \
    \   assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long> ans;\n   \
    \ std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n            }\n        }\n    }\n    long min_val = INT_MAX;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          min_val = std::min(min_val, dp[i][j][k]);\n        }\n    }\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n", "    int\
    \ n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < m; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k);\n    ans[k - 1] = dp[0][0][k];\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < ans[k -\
    \ 1]) {\n                ans[k - 1] = dp[i][j][k];\n            }\n        }\n\
    \    }\n    int", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;\n            }\n        }\n    }\n    std::vector",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    std::function<long(int,\
    \ int, int)> dfs = [&](int x, int y, int step) {\n        if (step == 0) {\n \
    \           return grid[x][y];\n        }\n        if (dp[x][y][step] != -1) {\n\
    \            return dp[x][y][step];\n        }\n        long res = INT_MAX;\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx >= 0 && nx < n && ny\
    \ >= 0 && ny < n) {\n                res = std::min(res, dfs(nx, ny, step - 1));\n\
    \            }\n        }\n        dp[x][y][step] = res;\n        return res;\n\
    \    };\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            ans.push_back(dfs(i, j, k));\n        }\n    }\n    std::sort(ans.begin(),\
    \ ans.end());\n    return ans;", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < m; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(j > 0){\n         \
    \           dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n          \
    \      }\n                if(i < n-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i+1][j][l-1]);\n                }\n                if(j < m-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n        \
    \        }\n                dp[i][j][l] += grid[i][j];\n            }\n      \
    \  }\n    }\n    int min_i = 0, min_j = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(dp[i][j][k] < dp[min_i][min_j][k]){\n\
    \                min_i = i;\n                min_j = j;\n            }\n     \
    \   }\n    }\n    std::vector<long> ans;", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n            }\n        }\n    }\n    std::vector<long> ans;\n\
    \    ans.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int l = 2; l\
    \ <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n \
    \           ans.push_back(grid[i - 1][j]);\n            i--;\n        } else if\
    \ (i < n - 1 && dp[i][j][l] == dp[i", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; ++i) {\n       \
    \ for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i <\
    \ n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int\
    \ x = -1; x <= 1; ++x) {\n                    for (int y = -1; y <= 1; ++y) {\n\
    \                        if (x == 0 && y == 0) {\n                           \
    \ continue;\n                        }\n                        int nx = i + x;\n\
    \                        int ny = j + y;\n                        if (nx < 0 ||\
    \ nx >= n || ny < 0 || ny >= n) {\n                            continue;\n   \
    \                     }\n                        if (dp[nx][ny][l - 1] == -1)\
    \ {\n                            continue;\n                        }\n      \
    \                  if (dp[i][j][l] == -1 || dp[nx][ny][l - 1] < dp[i][j][l]) {\n\
    \                            dp[i][j][l] = dp[nx][ny][l - 1];\n              \
    \              path[i][j][l] = nx * n + ny;\n                        }\n     \
    \               }\n                }\n            }\n        }\n    }\n    int\
    \ x = 0;\n    int y = 0;\n    for (int i = 0; i < n; ++i) {\n       ", "    int\
    \ n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <=\
    \ n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2;\
    \ len <= k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int\
    \ j = 0; j < n; ++j) {\n                for (int x = 0; x < n; ++x) {\n      \
    \              for (int y = 0; y < n; ++y) {\n                        if (dp[x][y][len\
    \ - 1] == -1) {\n                            continue;\n                     \
    \   }\n                        if (i == x && j == y) {\n                     \
    \       continue;\n                        }\n                        if (std::abs(i\
    \ - x) + std::abs(j - y) != 1) {\n                            continue;\n    \
    \                    }\n                        if (dp[i][j][len] == -1 || dp[i][j][len]\
    \ > dp[x][y][len - 1] + grid[i][j]) {\n                            dp[i][j][len]\
    \ = dp[x][y][len - 1] + grid[i][j];\n                            path[i][j][len]\
    \ = x * n + y;\n                        }\n                    }\n           \
    \     }\n            }\n        }\n    }\n    int x = 0, y = 0;\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n", "    int n =\
    \ grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n *\
    \ n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for (int j\
    \ = 0; j < n; ++j) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            path[i][j][l] = 0;\n                    }\n                }\n  \
    \              if (i < n - 1 && dp[i + 1][j][l - 1] != -1) {\n               \
    \     if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l]) {\n        \
    \                dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l]\
    \ = 1;\n                    }\n                }\n                if (j > 0 &&\
    \ dp[i][j - 1][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i][j\
    \ - 1][", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> par(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++)\
    \ {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m;\
    \ j++) {\n                for (int x = 0; x < n; x++) {\n                    for\
    \ (int y = 0; y < m; y++) {\n                        if (dp[x][y][l - 1] != -1)\
    \ {\n                            if (i == x && j == y) {\n                   \
    \             continue;\n                            }\n                     \
    \       if (i == x && std::abs(j - y) == 1) {\n                              \
    \  if (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l - 1] + grid[i][j]) {\n  \
    \                                  dp[i][j][l] = dp[x][y][l - 1] + grid[i][j];\n\
    \                                    par[i][j][l][0] = x;\n                  \
    \                  par[i][j][l][1] = y;\n                                }\n \
    \                           }\n                            if (j == y && std::abs(i\
    \ - x) == 1) {\n                                if (dp[i][j][l] == -1 || dp[i][j][l]\
    \ > dp[x][y][l - 1] +", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ v;\n                if (i > 0) {\n                    v.push_back(dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      v.push_back(dp[i + 1][j][l - 1]);\n                }\n                if\
    \ (j > 0) {\n                    v.push_back(dp[i][j - 1][l - 1]);\n         \
    \       }\n                if (j < m - 1) {\n                    v.push_back(dp[i][j\
    \ + 1][l - 1]);\n                }\n                if (v.size() == 0) {\n   \
    \                 dp[i][j][l] = 0;\n                } else {\n               \
    \     dp[i][j][l] = *std::min_element(v.begin(), v.end());\n                }\n\
    \            }\n        }\n    }\n    std::vector<long> res;\n    res.push_back(dp[0][0][k]);\n\
    \    int i = 0, j = 0;\n    for (int l = k - 1; l >= 1; l--) {\n        if (i\
    \ > 0 && dp[i - 1][j][l] == res.back()) {\n            res.push_back(dp[i - 1][j][l]);\n\
    \            i--;\n        } else if (i < n - 1 && dp[i + 1][j][l] == res", "\t\
    int n = grid.size();\n\tint m = grid[0].size();\n\tstd::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tdp[i][j][1]\
    \ = grid[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j =\
    \ 0; j < m; j++) {\n\t\t\tfor (int l = 2; l <= k; l++) {\n\t\t\t\tif (i > 0) {\n\
    \t\t\t\t\tdp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n\t\t\t\t\
    }\n\t\t\t\tif (i < n - 1) {\n\t\t\t\t\tdp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n\t\t\t\t}\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tif (j < m - 1) {\n\t\t\t\t\tdp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tdp[i][j][l]\
    \ += grid[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<long> ans(k);\n\tint x =\
    \ 0, y = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tans[i] = grid[x][y];\n\t\tif\
    \ (x > 0 && dp[", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(n * n <= k);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n));\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n \
    \               path[i][j].push_back(grid[i][j]);\n            } else if (i ==\
    \ 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n              \
    \  path[i][j] = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp[i][j] = d", "    int n = grid.size();\n \
    \   assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; ++i) {\n       \
    \ for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i <\
    \ n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i\
    \ > 0 && dp[i - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] ==\
    \ -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        path[i][j][l] = 0;\n       \
    \             }\n                }\n                if (i < n - 1 && dp[i + 1][j][l\
    \ - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i + 1][j][l -\
    \ 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i + 1][j][l -\
    \ 1];\n                        path[i][j][l] = 1;\n                    }\n   \
    \             }\n                if (j > 0 && dp[i][j - 1][l - 1] != -1) {\n \
    \                   if (dp[i][j][l] == -1 || dp[i][j - 1][", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                std::vector<long> v;\n                if (i >\
    \ 0) {\n                    v.push_back(dp[i - 1][j][l - 1]);\n              \
    \  }\n                if (i < n - 1) {\n                    v.push_back(dp[i +\
    \ 1][j][l - 1]);\n                }\n                if (j > 0) {\n          \
    \          v.push_back(dp[i][j - 1][l - 1]);\n                }\n            \
    \    if (j < m - 1) {\n                    v.push_back(dp[i][j + 1][l - 1]);\n\
    \                }\n                if (v.size() == 0) {\n                   \
    \ dp[i][j][l] = 0;\n                } else {\n                    std::sort(v.begin(),\
    \ v.end());\n                    dp[i][j][l] = v[0];\n                }\n    \
    \        }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ != 0) {\n                ans = dp[i][j][k];\n                break;\n      \
    \      }\n        }\n    }\n    return ans;", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n            }\n        }\n    }\n    std::vector<long> ans;\n\
    \    int i = 0, j = 0;\n    for (int l = 1; l <= k; l++) {\n        ans.push_back(grid[i][j]);\n\
    \        if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            i--;\n\
    \        } else if (i < n - 1 && dp[i][j][l] == dp[i + 1][j][l - 1]) {\n     \
    \       i++;\n       ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \   std::function<long(int, int, int)> dfs = [&](int x, int y, int step) {\n \
    \       if (step == 0) return 0;\n        if (dp[x][y][step] != -1) return dp[x][y][step];\n\
    \        long res = INT_MAX;\n        for (auto d : dir) {\n            int nx\
    \ = x + d[0], ny = y + d[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny\
    \ >= n) continue;\n            res = std::min(res, dfs(nx, ny, step - 1) + grid[x][y]);\n\
    \        }\n        return dp[x][y][step] = res;\n    };\n    long min_val = INT_MAX;\n\
    \    std::vector<long> res;\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            long val = dfs(i, j, k);\n            if (val\
    \ < min_val) {\n                min_val = val;\n                res = {grid[i][j]};\n\
    \            } else if (val == min_val) {\n                res.push_back(grid[i][j]);\n\
    \            }\n        }\n    }\n    return res;", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            ans.push_back(grid[i -\
    \ 1][j]);\n            i--;\n        } else if (i < n - 1", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            prev[i][j][1] = std::vector<long>({i, j});\n    \
    \    }\n    }\n    for (int len = 2; len <= k; ++len) {\n        for (int i =\
    \ 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n              \
    \  for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj\
    \ <= 1; ++dj) {\n                        if (di * di + dj * dj != 1) {\n     \
    \                       continue;\n                        }\n               \
    \         int ni = i + di;\n                        int nj = j + dj;\n       \
    \                 if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n            \
    \                continue;\n                        }\n                      \
    \  if (dp[ni][nj][len - 1] == -1) {\n                            continue;\n \
    \                       }\n                        if (dp[i][j][len] == -1 ||\
    \ dp[i][j][len] > dp[ni][nj][len - 1] + grid[i][j]) {\n                      \
    \      dp[i][j][len] = dp[ni][nj][len - 1] + grid[i][j];\n                   \
    \         prev[i][j][len] = prev[ni][nj", "    int n = grid.size();\n    int m\
    \ = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                long min = INT_MAX;\n\
    \                if (i > 0) {\n                    min = std::min(min, dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              min = std::min(min, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j > 0) {\n                    min = std::min(min, dp[i][j\
    \ - 1][l - 1]);\n                }\n                if (j < m - 1) {\n       \
    \             min = std::min(min, dp[i][j + 1][l - 1]);\n                }\n \
    \               dp[i][j][l] = min;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int i = 0, j = 0;\n    for (int l = 1; l <= k; l++) {\n        ans.push_back(dp[i][j][l]);\n\
    \        if (i > 0 && dp[i - 1][j][l] == dp[i][j][l + 1]) {\n            i--;\n\
    \        } else if (i < n - 1 && dp[i + 1][j][l] == dp[i][j][l + 1]) {\n     \
    \       i++;\n        } else if (j > 0 && dp[i][j - 1][l] == dp[i][j][l + 1])\
    \ {\n", "    // Write your code here\n    std::vector<long> ans;\n    long n =\
    \ grid.size();\n    long m = grid[0].size();\n    long min = INT_MAX;\n    for(long\
    \ i = 0; i < n; i++){\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ < min){\n                min = grid[i][j];\n            }\n        }\n    }\n\
    \    for(long i = 0; i < n; i++){\n        for(long j = 0; j < m; j++){\n    \
    \        if(grid[i][j] == min){\n                ans.push_back(min);\n       \
    \         long x = i;\n                long y = j;\n                for(long l\
    \ = 1; l < k; l++){\n                    if(x-1 >= 0 && grid[x-1][y] < grid[x][y]){\n\
    \                        ans.push_back(grid[x-1][y]);\n                      \
    \  x = x-1;\n                    }\n                    else if(x+1 < n && grid[x+1][y]\
    \ < grid[x][y]){\n                        ans.push_back(grid[x+1][y]);\n     \
    \                   x = x+1;\n                    }\n                    else\
    \ if(y-1 >= 0 && grid[x][y-1] < grid[x][y]){\n                        ans.push_back(grid[x][y-1]);\n\
    \                        y = y-1;\n                    }\n                   \
    \ else if(y+1 < m && grid[x][y+1] < grid[x][y]){\n                        ans.push_back(grid[x][y+1]);\n\
    \                        y = y+1;\n                    }\n                }\n\
    \                return ans;\n            }\n        }\n    }\n    return ans;",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long> ans;\n  \
    \  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int len =\
    \ 2; len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < n; j++) {\n                for (int x = 0; x < n; x++) {\n \
    \                   for (int y = 0; y < n; y++) {\n                        if\
    \ (abs(x - i) + abs(y - j) == 1) {\n                            if (dp[x][y][len\
    \ - 1] != -1) {\n                                if (dp[i][j][len] == -1 || dp[i][j][len]\
    \ > dp[x][y][len - 1] + grid[i][j]) {\n                                    dp[i][j][len]\
    \ = dp[x][y][len - 1] + grid[i][j];\n                                    path[i][j][len]\
    \ = path[x][y][len - 1];\n                                    path[i][j][len].push_back(grid[i][j]);\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n   ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans(k);\n    ans[0] = dp[0][0][k];\n\
    \    int x = 0, y = 0;\n    for (int i = 1; i < k; i++) {\n        if (x > 0 &&\
    \ dp[x - 1][y][k - i] < dp[x][y][k - i]) {\n            ans[i] = dp[x - 1][y][k\
    \ - i];\n            x--;\n        } else if (x < n - 1 && dp[x + 1][y][k - i]\
    \ < d", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n \
    \   for (int l = 1; l <= k; l++) {\n        ans.push_back(grid[i][j]);\n     \
    \   if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            i--;\n   \
    \     } else if (i < n - 1 && dp[i][j][l] == dp[i + 1][j][l - 1]) {\n        \
    \    i++;\n       ", "    std::vector<long> result;\n    // Implement your solution\
    \ here\n    return result;", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(k >= 1);\n    assert(n * n >= k);\n    std::vector<long> ans;\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (i > 0 && dp[i - 1][j] != -1) {\n  \
    \                  if (dp[i][j] == -1 || dp[i - 1][j] + 1 < dp[i][j]) {\n    \
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                        path[i][j]\
    \ = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i - 1][j] + 1 == dp[i][j]) {\n            \
    \            std::vector<long> tmp = path[i - 1][j];\n                       \
    \ tmp.push_back(grid[i][j]);\n                        if (tmp < path[i][j]) {\n\
    \                            path[i][j] = tmp;\n                        }\n  \
    \                  }\n                }\n                if (j > 0 && dp[i][j\
    \ - 1] != -1) {\n                    if (dp[i][j] == -1 || dp[i][j - 1] + 1 <\
    \ dp[i][j]) {\n                        dp[i][j] = dp[i][j - 1] + 1;\n        \
    \                path[i][j] = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, 0));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n     \
    \       } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    std::vector<long> ans;\n\
    \    for (int i = 0; i < k; i++) {\n        ans.push_back(", "    std::vector<long>\
    \ result;\n    // Your code goes here\n    return result;", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else {\n                std::vector<long>\
    \ curr;\n                if (i > 0) {\n                    curr.push_back(dp[i\
    \ - 1][j]);\n                }\n                if (j > 0) {\n               \
    \     curr.push_back(dp[i][j - 1]);\n                }\n                if (curr.size()\
    \ == 0) {\n                    dp[i][j] = grid[i][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else {\n                    std::sort(curr.begin(), curr.end());\n\
    \                    dp[i][j] = curr[0] + grid[i][j];\n                    if\
    \ (i > 0 && dp[i - 1][j] == curr[0]) {\n                        path[i][j] = path[i\
    \ - 1][j];\n                    } else {\n                        path[i][j] =\
    \ path[i][j - 1];\n                    }\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    std::vector<long> res;\n\
    \    for (int i = 0; i < k; i++) {\n        res.push_back(path[n - 1][n - 1][i]);\n\
    \    }\n    return res;", "    std::vector<long> res;\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    res.push_back(grid[x][y]);\n    for (int i = k - 1; i > 0; i--) {",
  "    // Your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for(int i = 0; i < n; i++) {\n        for(int j\
    \ = 0; j < m; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j].push_back(grid[i][j]);\n            }\n   \
    \         else {\n                if(i > 0) {\n                    if(dp[i][j]\
    \ > dp[i - 1][j] + 1) {\n                        dp[i][j] = dp[i - 1][j] + 1;\n\
    \                        path[i][j] = path[i - 1][j];\n                      \
    \  path[i][j].push_back(grid[i][j]);\n                    }\n                \
    \    else if(dp[i][j] == dp[i - 1][j] + 1) {\n                        std::vector<long>\
    \ temp = path[i - 1][j];\n                        temp.push_back(grid[i][j]);\n\
    \                        if(temp < path[i][j]) {\n                           \
    \ path[i][j] = temp;\n                        }\n                    }\n     \
    \           }\n                if(j > 0) {\n                    if(dp[i][j] >\
    \ dp[i][j - 1] + 1) {\n                        dp[i][j] = dp[i][j - 1] + 1;\n\
    \                        path[i][j] = path[i][j - 1];\n                      \
    \  path[i][j].push_back(grid[i][j]);\n                    }\n                \
    \    else if(dp[i][j] == dp[i][j - 1] + 1) {\n                        std::vector<long>\
    \ temp = path[i][j - 1];\n                        temp.push_back(grid[i][j]);",
  "    // Your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k, INT_MAX)));\n \
    \   for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n     \
    \       dp[i][j][0] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < n; j++) {\n            for(int l = 1; l <\
    \ k; l++) {\n                if(i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if(i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if(j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if(j + 1 < n) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n \
    \   for(int l = 0; l < k; l++) {\n        ans.push_back(dp[i][j][l]);\n      \
    \  if(i - 1 >= 0 && dp[i - 1][j][l] < dp[i][j][l]) {\n            i--;\n     \
    \   } else if(i + 1 < n && dp[i + 1][j][l] < dp[i][j][l]) {\n            i++;\n\
    \        } else if", "    // Your code here\n    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    int x = 0, y = 0;\n    for(int i = 0; i < n; i++) {\n\
    \        for(int j = 0; j < m; j++) {\n            if(grid[i][j] == 1) {\n   \
    \             x = i;\n                y = j;\n                break;\n       \
    \     }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(1);\n\
    \    for(int i = 0; i < k - 1; i++) {\n        if(x + 1 < n && grid[x + 1][y]\
    \ < grid[x][y]) {\n            x++;\n        } else if(y + 1 < m && grid[x][y\
    \ + 1] < grid[x][y]) {\n            y++;\n        } else if(x - 1 >= 0 && grid[x\
    \ - 1][y] < grid[x][y]) {\n            x--;\n        } else if(y - 1 >= 0 && grid[x][y\
    \ - 1] < grid[x][y]) {\n            y--;\n        }\n        ans.push_back(grid[x][y]);\n\
    \    }\n    return ans;", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[ans[0]][ans[1]][k])\
    \ {\n                ans = {i, j};\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    for (int i = 0; i < k;", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i\
    \ - 1][j][l - 1];\n                        path[i][j][l] = path[i - 1][j][l -\
    \ 1];\n                        path[i][j][l].push_back(grid[i][j]);\n        \
    \            }\n                }\n                if (i < n - 1) {\n        \
    \            if (dp[i + 1][j][l - 1] < dp[i][j][l]) {\n                      \
    \  dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l] =\
    \ path[i + 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j - 1][l - 1] < dp[i][j", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ min_val = {-1, -1};\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (min_val[0] == -1 || dp[i - 1][j][l - 1] < min_val[0])\
    \ {\n                        min_val = {dp[i - 1][j][l - 1], 0};\n           \
    \         }\n                }\n                if (i < n - 1 && dp[i + 1][j][l\
    \ - 1] != -1) {\n                    if (min_val[0] == -1 || dp[i + 1][j][l -\
    \ 1] < min_val[0]) {\n                        min_val = {dp[i + 1][j][l - 1],\
    \ 1};\n                    }\n                }\n                if (j > 0 &&\
    \ dp[i][j - 1][l - 1] != -1) {\n                    if (min_val[0] == -1 || dp[i][j\
    \ - 1][l - 1] < min_val[0]) {\n                        min_val = {dp[i][j - 1][l\
    \ - 1], 2};\n                    }\n", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> dp_path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            dp_path[i][j][1] = std::vector<long>({grid[i][j]});\n\
    \        }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                std::vector<long>\
    \ min_path;\n                long min_val = -1;\n                if (i > 0) {\n\
    \                    if (dp[i - 1][j][l - 1] != -1) {\n                      \
    \  if (min_val == -1 || dp[i - 1][j][l - 1] < min_val) {\n                   \
    \         min_val = dp[i - 1][j][l - 1];\n                            min_path\
    \ = dp_path[i - 1][j][l - 1];\n                        }\n                   \
    \ }\n                }\n                if (i < n - 1) {\n                   \
    \ if (dp[i + 1][j][l - 1] != -1) {\n                        if (min_val == -1\
    \ || dp[i + 1][j][l - 1] < min_val) {\n                            min_val = dp[i\
    \ + 1][j][l - 1];\n                            min_path = dp", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] + 1 < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j] +\
    \ 1;\n                        path[i][j] = path[i - 1][j];\n                 \
    \       path[i][j].push_back(grid[i][j]);\n                    } else if (dp[i\
    \ - 1][j] + 1 == dp[i][j]) {\n                        std::vector<long> tmp =\
    \ path[i - 1][j];\n                        tmp.push_back(grid[i][j]);\n      \
    \                  if (tmp < path[i][j]) {\n                            path[i][j]\
    \ = tmp;\n                        }\n                    }\n                }\n\
    \                if (j > 0) {\n                    if (dp[i][j - 1] + 1 < dp[i][j])\
    \ {\n                        dp[i][j] = dp[i][j - 1] + 1;\n                  \
    \      path[i][j] = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i][j - 1] + 1 == dp[i][j]) {\n            \
    \            std::vector<long> tmp = path[i][j - 1];\n                       \
    \ tmp.push_back(grid[i][j]);\n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   for (int l = 0; l < k; l++) {\n                for (int d = 0; d < 4; d++)\
    \ {\n                    int x = i + dir[d][0];\n                    int y = j\
    \ + dir[d][1];\n                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n\
    \                    if (dp[x][y][l] == -1) continue;\n                    if\
    \ (dp[i][j][l + 1] == -1 || dp[i][j][l + 1] > dp[x][y][l] * 10 + grid[i][j]) {\n\
    \                        dp[i][j][l + 1] = dp[x][y][l] * 10 + grid[i][j];\n  \
    \                      path[i][j][l + 1] = path[x][y][l];\n                  \
    \      path[i][j][l + 1].push_back(grid[i][j]);\n                    }\n     \
    \           }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] == -1)\
    \ continue;\n            if (ans.empty() || ans > path[i][j][k]) {\n         \
    \       ans =", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                long min = INT_MAX;\n                if (i > 0)\
    \ {\n                    min = std::min(min, dp[i - 1][j][l - 1]);\n         \
    \       }\n                if (i < n - 1) {\n                    min = std::min(min,\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 min = std::min(min, dp[i][j - 1][l - 1]);\n                }\n\
    \                if (j < n - 1) {\n                    min = std::min(min, dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = min + grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    long min = INT_MAX;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n    \
    \            ans.clear();\n                ans.push_back(grid[i][j]);\n      \
    \      } else if (dp[i][j][k] == min) {\n                ans.push_back(grid[i][j]);\n\
    \            }\n        }\n    }\n    return ans;", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j].push_back(grid[i][j]);\n            } else\
    \ {\n                if (i > 0) {\n                    if (dp[i - 1][j] + 1 <\
    \ dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j] + 1;\n        \
    \                path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i - 1][j] + 1 == dp[i][j]) {\n            \
    \            std::vector<long> temp = path[i - 1][j];\n                      \
    \  temp.push_back(grid[i][j]);\n                        if (temp < path[i][j])\
    \ {\n                            path[i][j] = temp;\n                        }\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j - 1] + 1 < dp[i][j]) {\n                        dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                        path[i][j] = path[i][j - 1];\n\
    \                        path[i][j].push_back(grid[i][j]);\n                 \
    \   } else if (dp[i][j - 1] + 1 == dp[i][j]) {\n                        std::vector<long>\
    \ temp = path[i][j - 1];\n                        temp.push_back(grid[i][j]);\n\
    \                        if (temp < path[i][j]) {\n                           ",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ cur;\n                if (i > 0) {\n                    cur.push_back(dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              cur.push_back(dp[i + 1][j][l - 1]);\n                }\n      \
    \          if (j > 0) {\n                    cur.push_back(dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    cur.push_back(dp[i][j\
    \ + 1][l - 1]);\n                }\n                std::sort(cur.begin(), cur.end());\n\
    \                dp[i][j][l] = cur[0];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            if (dp[i][j][k] == 1) {\n                ans = dp[i][j];\n  \
    \              break;\n            }\n        }\n    }\n    return ans;", "  \
    \  int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else {\n                if\
    \ (i > 0) {\n                    if (dp[i][j] > dp[i - 1][j] + grid[i][j]) {\n\
    \                        dp[i][j] = dp[i - 1][j] + grid[i][j];\n             \
    \           path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i][j] == dp[i - 1][j] + grid[i][j]) {\n   \
    \                     std::vector<long> temp = path[i - 1][j];\n             \
    \           temp.push_back(grid[i][j]);\n                        if (temp < path[i][j])\
    \ {\n                            path[i][j] = temp;\n                        }\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j] > dp[i][j - 1] + grid[i][j]) {\n               \
    \         dp[i][j] = dp[i][j - 1] + grid[i][j];\n                        path[i][j]\
    \ = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i][j] == dp[i][j - 1] + grid[i][j]) {\n   \
    \                     std::vector<long> temp = path[i][j -", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                    path[i][j] = path[i - 1][j];\n                   \
    \ path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else {", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for (int\
    \ j = 0; j < n; ++j) {\n                for (int di = -1; di <= 1; ++di) {\n \
    \                   for (int dj = -1; dj <= 1; ++dj) {\n                     \
    \   if (di == 0 && dj == 0) continue;\n                        int ni = i + di;\n\
    \                        int nj = j + dj;\n                        if (ni < 0\
    \ || ni >= n || nj < 0 || nj >= n) continue;\n                        if (dp[ni][nj][l\
    \ - 1] == -1) continue;\n                        if (dp[i][j][l] == -1 || dp[i][j][l]\
    \ > dp[ni][nj][l - 1]) {\n                            dp[i][j][l] = dp[ni][nj][l\
    \ - 1];\n                            path[i][j][l] = path[ni][nj][l - 1];\n  \
    \                          path[i][j][l].push_back(grid[i][j]);\n            \
    \            }", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i)\
    \ {\n            for (int j = 0; j < n; ++j) {\n                long min_val =\
    \ -1;\n                std::vector<long> min_path;\n                for (int di\
    \ = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj)\
    \ {\n                        if (di == 0 && dj == 0) {\n                     \
    \       continue;\n                        }\n                        int ni =\
    \ i + di;\n                        int nj = j + dj;\n                        if\
    \ (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n                            continue;\n\
    \                        }\n                        if (dp[ni][nj][l - 1] == -1)\
    \ {\n                            continue;\n                        }\n      \
    \                  if (min_val == -1 || dp[ni][nj][l - 1] < min_val) {\n     \
    \                       min_val = dp[ni][nj][l - 1];\n                       \
    \     min_path = path[ni][nj][l - 1];\n                        }\n           \
    \         }\n                }\n                if", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;", "    // Your code here\n    std::vector<long>\
    \ result;\n    std::vector<std::vector<long>> path;\n    std::vector<long> temp;\n\
    \    for(int i=0;i<grid.size();i++){\n        for(int j=0;j<grid[i].size();j++){\n\
    \            temp.push_back(grid[i][j]);\n            path.push_back(temp);\n\
    \            temp.clear();\n        }\n    }\n    std::sort(path.begin(),path.end());\n\
    \    for(int i=0;i<k;i++){\n        result.push_back(path[i][0]);\n    }\n   \
    \ return result;", "    int n = grid.size();\n    int m = grid[0].size();\n  \
    \  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                long min = INT_MAX;\n\
    \                if (i > 0) {\n                    min = std::min(min, dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              min = std::min(min, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j > 0) {\n                    min = std::min(min, dp[i][j\
    \ - 1][l - 1]);\n                }\n                if (j < m - 1) {\n       \
    \             min = std::min(min, dp[i][j + 1][l - 1]);\n                }\n \
    \               dp[i][j][l] = min + grid[i][j];\n            }\n        }\n  \
    \  }\n    long min = INT_MAX;\n    int x, y;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < min)\
    \ {\n                min = dp[i][j][k];\n                x = i;\n            \
    \    y = j;\n            }\n        }\n    }\n    std::vector<long> ans;\n   \
    \ ans.push_back(grid[x][y]);\n    for (int i = k - 1; i >= 1; i--) {\n       \
    \ if (x > 0 && dp[x - 1][y][i", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long> ans;\n  \
    \  for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n    \
    \        assert(grid[i][j] >= 1);\n            assert(grid[i][j] <= n * n);\n\
    \        }\n    }\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp_path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   dp_path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int\
    \ l = 2; l <= k; l++) {\n                std::vector<long> cur_path;\n       \
    \         long cur_min = -1;\n                if (i - 1 >= 0) {\n            \
    \        if (dp[i - 1][j][l - 1] != -1) {\n                        if (cur_min\
    \ == -1 || cur_min > dp[i - 1][j][l - 1]) {\n                            cur_min\
    \ = dp[i - 1][j][l - 1];\n                            cur_path = dp_path[i - 1][j][l\
    \ - 1];\n                        }\n                    }\n                }\n\
    \                if (i + 1 < n) {\n                    if (dp[i + 1][j][l", " \
    \   int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                for (int x = 0; x < n; x++) {\n      \
    \              for (int y = 0; y < n; y++) {\n                        if (dp[x][y][l\
    \ - 1] != -1) {\n                            if (i == x && abs(j - y) == 1 ||\
    \ j == y && abs(i - x) == 1) {\n                                if (dp[i][j][l]\
    \ == -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j]) {\n              \
    \                      dp[i][j][l] = dp[x][y][l - 1] * 10 + grid[i][j];\n    \
    \                                path[i][j][l] = path[x][y][l - 1];\n        \
    \                            path[i][j][l].push_back(grid[i][j]);\n          \
    \                      }\n                            }\n                    \
    \    }\n                    }\n                }\n            }\n        }\n \
    \   }\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j =", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k+1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n                }\n             \
    \   if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n\
    \                }\n                if (i < n-1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n                }\n             \
    \   if (j < m-1) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans(k, INT_MAX);\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < ans[k-1]) {\n                ans[k-1] = dp[i][j][k];\n            }\n    \
    \    }\n    }\n    for (int i = k-1; i >= 1; i--", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                std::vector<long> candidates;\n              \
    \  if (i > 0) {\n                    candidates.push_back(dp[i - 1][j][l - 1]);\n\
    \                }\n                if (i < n - 1) {\n                    candidates.push_back(dp[i\
    \ + 1][j][l - 1]);\n                }\n                if (j > 0) {\n        \
    \            candidates.push_back(dp[i][j - 1][l - 1]);\n                }\n \
    \               if (j < n - 1) {\n                    candidates.push_back(dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = *std::min_element(candidates.begin(),\
    \ candidates.end());\n            }\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int l = 2;\
    \ l <= k; l++) {\n        if (i > 0 && dp[i - 1][j][l] < dp[i][j][l]) {\n    \
    \        result.push_back(grid[i - 1][j]);\n            i--;\n        } else if\
    \ (i < n - 1 && dp[i + 1][j][l] < dp[i][j][l]) {\n            result.push_back(grid[i",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \   std::function<long(int, int, int)> dfs = [&](int x, int y, int step) {\n \
    \       if (step == 0) return 0;\n        if (dp[x][y][step] != -1) return dp[x][y][step];\n\
    \        long res = INT_MAX;\n        for (auto d : dir) {\n            int nx\
    \ = x + d[0];\n            int ny = y + d[1];\n            if (nx < 0 || nx >=\
    \ n || ny < 0 || ny >= m) continue;\n            res = std::min(res, dfs(nx, ny,\
    \ step - 1) + grid[nx][ny]);\n        }\n        return dp[x][y][step] = res;\n\
    \    };\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            long\
    \ val = dfs(i, j, k);\n            if (val < min_val) {\n                min_val\
    \ = val;\n                ans = {grid[i][j]};\n            } else if (val == min_val)\
    \ {\n                ans.push_back(grid[i][j]);\n            }\n        }\n  \
    \  }\n    return ans;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k);\n    ans[k - 1] = grid[0][0];\n    int i = 0, j = 0;\n    for (int l\
    \ = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] < dp[i][j][l])\
    \ {\n            ans[l - 1] = grid[i - 1][j];\n            i--;\n        } else\
    \ if (j > 0 && dp[i", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k;\
    \ l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j\
    \ < n; j++) {\n                dp[i][j][l] = INT_MAX;\n                for (int\
    \ x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n  \
    \                      if (abs(x - i) + abs(y - j) == 1) {\n                 \
    \           if (dp[x][y][l - 1] < dp[i][j][l]) {\n                           \
    \     dp[i][j][l] = dp[x][y][l - 1];\n                                path[i][j][l]\
    \ = grid[i][j];\n                            } else if (dp[x][y][l - 1] == dp[i][j][l])\
    \ {\n                                path[i][j][l] = std::min(path[i][j][l], grid[i][j]);\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k, 0);\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n\
    \        for (int", "    int n = grid.size();\n    int m = grid[0].size();\n \
    \   std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                long min = INT_MAX;\n\
    \                if (i > 0) {\n                    min = std::min(min, dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              min = std::min(min, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j > 0) {\n                    min = std::min(min, dp[i][j\
    \ - 1][l - 1]);\n                }\n                if (j < m - 1) {\n       \
    \             min = std::min(min, dp[i][j + 1][l - 1]);\n                }\n \
    \               dp[i][j][l] = min;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int l\
    \ = 2; l <= k; l++) {\n        long min = INT_MAX;\n        int i_min = -1, j_min\
    \ = -1;\n        if (i > 0) {\n            if (dp[i - 1][j][l - 1] < min) {\n\
    \                min = dp[i - 1][j][l - 1];\n                i_min = i - 1;\n\
    \                j_min = j;\n            }\n        }\n        if (i < n - 1)\
    \ {\n            if (dp[i", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;\n            }\n        }\n    }\n    std::vector",
  "    std::vector<long> res;\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < m) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            min_val = std::min(min_val, dp[i][j][k]);\n\
    \        }\n    }\n    res.push_back(min_val);\n    for (int l = k - 1; l >= 1;\
    \ l--) {\n        for (int i = 0; i < n;", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n    int min_j\
    \ = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \                min_i = i;\n                min_j = j;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> res;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < dp[res[0]][res[1]][k])\
    \ {\n                res = {i, j};\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[res[0]][res[1]]);\n    for (", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j].push_back(grid[i][j]);\n            } else\
    \ {\n                if (i > 0) {\n                    if (dp[i][j] > dp[i - 1][j]\
    \ + 1) {\n                        dp[i][j] = dp[i - 1][j] + 1;\n             \
    \           path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i][j] == dp[i - 1][j] + 1) {\n            \
    \            std::vector<long> temp = path[i - 1][j];\n                      \
    \  temp.push_back(grid[i][j]);\n                        if (temp < path[i][j])\
    \ {\n                            path[i][j] = temp;\n                        }\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j] > dp[i][j - 1] + 1) {\n                        dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                        path[i][j] = path[i][j - 1];\n\
    \                        path[i][j].push_back(grid[i][j]);\n                 \
    \   } else if (dp[i][j] == dp[i][j - 1] + 1) {\n                        std::vector<long>\
    \ temp = path[i][j - 1];\n                        temp.push_back(grid[i][j]);\n\
    \                        if (temp < path[i][j])", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                long min = LONG_MAX;\n\
    \                if (i > 0) {\n                    min = std::min(min, dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              min = std::min(min, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j > 0) {\n                    min = std::min(min, dp[i][j\
    \ - 1][l - 1]);\n                }\n                if (j < n - 1) {\n       \
    \             min = std::min(min, dp[i][j + 1][l - 1]);\n                }\n \
    \               dp[i][j][l] = min;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int l\
    \ = 2; l <= k; l++) {\n        long min = LONG_MAX;\n        int min_i = -1, min_j\
    \ = -1;\n        if (i > 0) {\n            if (dp[i - 1][j][l - 1] < min) {\n\
    \                min = dp[i - 1][j][l - 1];\n                min_i = i - 1;\n\
    \                min_j = j;\n            }\n        }\n        if (i < n - 1)\
    \ {\n            if (dp[i + 1][j][l - 1] < min", "    std::vector<long> res;\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    res.push_back(grid[x][y]);\n    for (int i = k - 1; i > 0; i--) {",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> path(n, std::vector<long>(n,\
    \ -1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = 1;\n            } else if (j == 0) {\n         \
    \       dp[i][j] = dp[i - 1][j] + grid[i][j];\n                path[i][j] = 0;\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = 0;\n                } else {\n                    dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n                    path[i][j] = 1;\n                }\n\
    \            }\n        }\n    }\n    std::vector<long> res;\n    int i = n -\
    \ 1, j = n - 1;\n    while (k > 0) {\n        res.push_back(grid[i][j]);\n   \
    \     if (path[i][j] == 0) {\n            i--;\n        } else {\n           \
    \ j--;\n        }\n        k--;\n    }\n    return res;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    std::vector<std::vector<long>> dirs = {{0,\
    \ 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int len =\
    \ 2; len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < n; j++) {\n                for (auto dir : dirs) {\n       \
    \             int x = i + dir[0];\n                    int y = j + dir[1];\n \
    \                   if (x < 0 || x >= n || y < 0 || y >= n) continue;\n      \
    \              if (dp[x][y][len - 1] == -1) continue;\n                    if\
    \ (dp[i][j][len] == -1 || dp[x][y][len - 1] < dp[i][j][len]) {\n             \
    \           dp[i][j][len] = dp[x][y][len - 1];\n                        path[i][j][len]\
    \ = path[x][y][len - 1];\n                        path[i][j][len].push_back(grid[i][j]);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            ans.push_back(grid[i -\
    \ 1][j]);\n            i--;\n        } else if (i < n - 1 && dp[i][j][l] == dp[i\
    \ + 1", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j]\
    \ = grid[i][j];\n            path[i][j].push_back(grid[i][j]);\n        }\n  \
    \  }\n    for (int i = 1; i < k; i++) {\n        for (int j = 0; j < n; j++) {\n\
    \            for (int l = 0; l < m; l++) {\n                if (j > 0 && dp[j][l]\
    \ > dp[j - 1][l] + grid[j][l]) {\n                    dp[j][l] = dp[j - 1][l]\
    \ + grid[j][l];\n                    path[j][l] = path[j - 1][l];\n          \
    \          path[j][l].push_back(grid[j][l]);\n                }\n            \
    \    if (j < n - 1 && dp[j][l] > dp[j + 1][l] + grid[j][l]) {\n              \
    \      dp[j][l] = dp[j + 1][l] + grid[j][l];\n                    path[j][l] =\
    \ path[j + 1][l];\n                    path[j][l].push_back(grid[j][l]);\n   \
    \             }\n                if (l > 0 && dp[j][l] > dp[j][l - 1] + grid[j][l])\
    \ {\n                    dp[j][l] = dp[j][l - 1] + grid[j][l];\n             \
    \       path[j][l] = path[j][l - 1];\n                    path[j][l].push_back(grid[j][l]);\n\
    \                }\n                if (l < m - 1", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len\
    \ <= k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int\
    \ j = 0; j < n; ++j) {\n                long min_val = -1;\n                for\
    \ (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <=\
    \ 1; ++dj) {\n                        if (di == 0 && dj == 0) {\n            \
    \                continue;\n                        }\n                      \
    \  int ni = i + di;\n                        int nj = j + dj;\n              \
    \          if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n                   \
    \         continue;\n                        }\n                        if (dp[ni][nj][len\
    \ - 1] == -1) {\n                            continue;\n                     \
    \   }\n                        if (min_val == -1 || dp[ni][nj][len - 1] < min_val)\
    \ {\n                            min_val = dp[ni][nj][len - 1];\n            \
    \            }\n                    }\n                }\n                dp[i][j][len]\
    \ = min_val;\n            }\n        }\n    }\n    long min_val = -1;\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   if (min_val == -1 || dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \            }\n        }\n   ", "    int n = grid.size();\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++) {\n      \
    \  for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n\
    \                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                   \
    \ dp[i][j] = dp[i - 1][j];\n                    path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n          \
    \      }\n                if (i < n - 1 && dp[i + 1][j] < dp[i][j]) {\n      \
    \              dp[i][j] = dp[i + 1][j];\n                    path[i][j][l] = path[i\
    \ + 1][j][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n\
    \                }\n                if (j > 0 && dp[i][j - 1] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n\
    \                }\n                if (j < n - 1 && dp[i][j + 1] < dp[i][j"]
stop_tokens:
- "\n}"
