language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (index == -1) {\n                index = i;\n            }\
    \ else {\n                if (word[index] == word[i]) {\n                    index\
    \ = i;\n                } else {\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    if (index != -1) {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdhf6asvo.cpp: In function 'int main()':\n/tmp/tmpdhf6asvo.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdhf6asvo.cpp:2:\n/tmp/tmpdhf6asvo.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       return \"\";\n            }\n            if (vowels.find(word[i + 1])\
    \ == std::string::npos) {\n                return word.substr(i, 1);\n       \
    \     }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiqkahc93.cpp: In function 'int main()':\n/tmp/tmpiqkahc93.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqkahc93.cpp:2:\n/tmp/tmpiqkahc93.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5syz_woe.cpp: In function 'int main()':\n/tmp/tmp5syz_woe.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5syz_woe.cpp:2:\n/tmp/tmp5syz_woe.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (index == -1) {\n                index = i;\n            }\
    \ else {\n                if (i + 1 < index) {\n                    result = word[i];\n\
    \                    break;\n                }\n            }\n        } else\
    \ {\n            index = -1;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps2vfj0kh.cpp: In function 'int main()':\n/tmp/tmps2vfj0kh.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps2vfj0kh.cpp:2:\n/tmp/tmps2vfj0kh.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int len = word.length();\n    for(int\
    \ i = len-1; i > 0; i--) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if(word[i-1] != 'a'\
    \ && word[i-1] != 'e' && word[i-1] != 'i' && word[i-1] != 'o' && word[i-1] !=\
    \ 'u') {\n                return word.substr(i,1);\n            }\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpga7w_53a.cpp: In function 'int main()':\n/tmp/tmpga7w_53a.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpga7w_53a.cpp:2:\n/tmp/tmpga7w_53a.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    int closest_vowel_distance = INT_MAX;\n    int word_length = word.length();\n\
    \    for (int i = 0; i < word_length; i++) {\n        for (int j = 0; j < vowels.length();\
    \ j++) {\n            if (word[i] == vowels[j]) {\n                int distance\
    \ = word_length - i - 1;\n                if (distance < closest_vowel_distance)\
    \ {\n                    closest_vowel_distance = distance;\n                \
    \    closest_vowel_index = i;\n                }\n            }\n        }\n \
    \   }\n    if (closest_vowel_index == -1) {\n        return \"\";\n    }\n   \
    \ return std::string(1, word[closest_vowel_index]);\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp51_icxrs.cpp: In function 'int main()':\n/tmp/tmp51_icxrs.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp51_icxrs.cpp:2:\n/tmp/tmp51_icxrs.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    int word_length = word.length();\n    for (int i = 0; i < word_length; i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if\
    \ (i > 0 && i < word_length - 1) {\n                if (vowels.find(word[i - 1])\
    \ == std::string::npos && vowels.find(word[i + 1]) == std::string::npos) {\n \
    \                   if (closest_vowel_index == -1) {\n                       \
    \ closest_vowel_index = i;\n                        closest_vowel = word[i];\n\
    \                    } else {\n                        if (i > closest_vowel_index)\
    \ {\n                            closest_vowel_index = i;\n                  \
    \          closest_vowel = word[i];\n                        }\n             \
    \       }\n                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptb0mspyy.cpp: In function 'int main()':\n/tmp/tmptb0mspyy.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptb0mspyy.cpp:2:\n/tmp/tmptb0mspyy.cpp:43:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5olew3xj.cpp: In function 'int main()':\n/tmp/tmp5olew3xj.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5olew3xj.cpp:2:\n/tmp/tmp5olew3xj.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    int i = index - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(i + 1, index - i);\n\
    \        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpixqdk9e7.cpp: In function 'int main()':\n/tmp/tmpixqdk9e7.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpixqdk9e7.cpp:2:\n/tmp/tmpixqdk9e7.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    int word_length = word.length();\n    for (int i = 0; i < word_length; i++)\
    \ {\n        char current_char = word[i];\n        if (vowels.find(current_char)\
    \ != std::string::npos) {\n            if (i == 0) {\n                if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                    closest_vowel = current_char;\n\
    \                    closest_vowel_index = i;\n                }\n           \
    \ } else if (i == word_length - 1) {\n                if (vowels.find(word[i -\
    \ 1]) == std::string::npos) {\n                    closest_vowel = current_char;\n\
    \                    closest_vowel_index = i;\n                }\n           \
    \ } else {\n                if (vowels.find(word[i - 1]) == std::string::npos\
    \ && vowels.find(word[i + 1]) == std::string::npos) {\n                    closest_vowel\
    \ = current_char;\n                    closest_vowel_index = i;\n            \
    \    }\n            }\n        }\n    }\n    return closest_vowel;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmrx56g33.cpp: In function 'int main()':\n/tmp/tmpmrx56g33.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmrx56g33.cpp:2:\n/tmp/tmpmrx56g33.cpp:47:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    for(int i = n-1; i\
    \ >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n    \
    \        if(i == n-1) {\n                return \"\";\n            }\n       \
    \     if(vowels.find(word[i+1]) == std::string::npos) {\n                return\
    \ word.substr(i, 1);\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvkx5dw9t.cpp: In function 'int main()':\n/tmp/tmpvkx5dw9t.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvkx5dw9t.cpp:2:\n/tmp/tmpvkx5dw9t.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    int index = -1;\n\
    \    int min_distance = INT_MAX;\n    for (int i = 0; i < word.length(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.length() - i;\n            if (distance < min_distance) {\n\
    \                min_distance = distance;\n                index = i;\n      \
    \      }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvn6bavdr.cpp: In function 'int main()':\n/tmp/tmpvn6bavdr.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvn6bavdr.cpp:2:\n/tmp/tmpvn6bavdr.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string res = \"\";\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            res\
    \ = word[i];\n            break;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmkwcqah3.cpp: In function 'int main()':\n/tmp/tmpmkwcqah3.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmkwcqah3.cpp:2:\n/tmp/tmpmkwcqah3.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    std::string result = \"\";\n\tint index = word.length() - 1;\n\twhile (index >=\
    \ 0) {\n\t\tif (vowels.find(word[index]) != std::string::npos) {\n\t\t\tresult\
    \ = word[index];\n\t\t\tbreak;\n\t\t}\n\t\tindex--;\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpomtz4cdp.cpp: In function 'int main()':\n/tmp/tmpomtz4cdp.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpomtz4cdp.cpp:2:\n/tmp/tmpomtz4cdp.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    int n = word.length();\n\
    \    int i = n-1;\n    while(i>=0){\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u' || word[i]=='A' || word[i]=='E'\
    \ || word[i]=='I' || word[i]=='O' || word[i]=='U'){\n            if(i==n-1){\n\
    \                return \"\";\n            }\n            else{\n            \
    \    if(word[i-1]=='a' || word[i-1]=='e' || word[i-1]=='i' || word[i-1]=='o' ||\
    \ word[i-1]=='u' || word[i-1]=='A' || word[i-1]=='E' || word[i-1]=='I' || word[i-1]=='O'\
    \ || word[i-1]=='U'){\n                    return \"\";\n                }\n \
    \               else{\n                    return word.substr(i,1);\n        \
    \        }\n            }\n        }\n        i--;\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvbs7l9qw.cpp: In function 'int main()':\n/tmp/tmpvbs7l9qw.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvbs7l9qw.cpp:2:\n/tmp/tmpvbs7l9qw.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   result = word[i];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp20i7j2a_.cpp: In function 'int main()':\n/tmp/tmp20i7j2a_.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp20i7j2a_.cpp:2:\n/tmp/tmp20i7j2a_.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int n = word.length();\n    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            if(i == n-1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxtw8w098.cpp: In function 'int main()':\n/tmp/tmpxtw8w098.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxtw8w098.cpp:2:\n/tmp/tmpxtw8w098.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (closest_vowel_index == -1) {\n    \
    \            closest_vowel_index = i;\n                closest_vowel = word[i];\n\
    \            } else {\n                if (i < closest_vowel_index) {\n      \
    \              closest_vowel_index = i;\n                    closest_vowel = word[i];\n\
    \                }\n            }\n        } else {\n            if (closest_vowel_index\
    \ != -1) {\n                return closest_vowel;\n            }\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmr5759bj.cpp: In function 'int main()':\n/tmp/tmpmr5759bj.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmr5759bj.cpp:2:\n/tmp/tmpmr5759bj.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    for(int i = n-1; i\
    \ >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n    \
    \        if(i == n-1) {\n                return \"\";\n            }\n       \
    \     else if(vowels.find(word[i+1]) == std::string::npos) {\n               \
    \ return word.substr(i, 1);\n            }\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5en749cn.cpp: In function 'int main()':\n/tmp/tmp5en749cn.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5en749cn.cpp:2:\n/tmp/tmp5en749cn.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos == 0) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9zf75_46.cpp: In function 'int main()':\n/tmp/tmp9zf75_46.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9zf75_46.cpp:2:\n/tmp/tmp9zf75_46.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   result = word[i];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp20i7j2a_.cpp: In function 'int main()':\n/tmp/tmp20i7j2a_.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp20i7j2a_.cpp:2:\n/tmp/tmp20i7j2a_.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       i--;\n                continue;\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpymadpo_7.cpp: In function 'int main()':\n/tmp/tmpymadpo_7.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpymadpo_7.cpp:2:\n/tmp/tmpymadpo_7.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int len = word.length();\n    int i = len - 1;\n    while (i >= 0) {\n  \
    \      if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvz6p6gp8.cpp: In function 'int main()':\n/tmp/tmpvz6p6gp8.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvz6p6gp8.cpp:2:\n/tmp/tmpvz6p6gp8.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos == 0) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9zf75_46.cpp: In function 'int main()':\n/tmp/tmp9zf75_46.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9zf75_46.cpp:2:\n/tmp/tmp9zf75_46.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int pos = word.length() - 1;\n    while\
    \ (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos) {\n \
    \           result = word[pos];\n            break;\n        }\n        pos--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2sbrb6tm.cpp: In function 'int main()':\n/tmp/tmp2sbrb6tm.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2sbrb6tm.cpp:2:\n/tmp/tmp2sbrb6tm.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            if(i == n-1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsbk3nvg1.cpp: In function 'int main()':\n/tmp/tmpsbk3nvg1.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsbk3nvg1.cpp:2:\n/tmp/tmpsbk3nvg1.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int i = word.size() - 1;\n    while\
    \ (i >= 0) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u') {\n            break;\n        }\n       \
    \ i--;\n    }\n    if (i == 0) {\n        return \"\";\n    }\n    int j = i -\
    \ 1;\n    while (j >= 0) {\n        if (word[j] != 'a' && word[j] != 'e' && word[j]\
    \ != 'i' && word[j] != 'o' && word[j] != 'u') {\n            break;\n        }\n\
    \        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    return\
    \ word.substr(j + 1, i - j);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa594x8sm.cpp: In function 'int main()':\n/tmp/tmpa594x8sm.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa594x8sm.cpp:2:\n/tmp/tmpa594x8sm.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n   \
    \ for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            int distance = word.size() - i;\n        \
    \    if (closest_vowel_distance == -1 || distance < closest_vowel_distance) {\n\
    \                closest_vowel_distance = distance;\n                closest_vowel_index\
    \ = i;\n            }\n        }\n    }\n    if (closest_vowel_index == -1) {\n\
    \        return \"\";\n    }\n    for (int i = closest_vowel_index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   return word.substr(closest_vowel_index, 1);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx67npk_1.cpp: In function 'int main()':\n/tmp/tmpx67npk_1.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx67npk_1.cpp:2:\n/tmp/tmpx67npk_1.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiouAEIOU\"\
    ;\n\tint len = word.length();\n\tint i = len - 1;\n\twhile (i >= 0) {\n\t\tif\
    \ (vowels.find(word[i]) != std::string::npos) {\n\t\t\tif (i == len - 1) {\n\t\
    \t\t\treturn \"\";\n\t\t\t}\n\t\t\tif (vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n\t\t\t\treturn word.substr(i, 1);\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\treturn\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqkhludoj.cpp: In function 'int main()':\n/tmp/tmpqkhludoj.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqkhludoj.cpp:2:\n/tmp/tmpqkhludoj.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int index = word.length() - 1;\n    int vowel_index = -1;\n    while (index\
    \ >= 0) {\n        if (consonants.find(word[index]) != std::string::npos) {\n\
    \            vowel_index = index;\n            break;\n        }\n        index--;\n\
    \    }\n    if (vowel_index == -1) return \"\";\n    index = vowel_index + 1;\n\
    \    while (index < word.length()) {\n        if (vowels.find(word[index]) !=\
    \ std::string::npos) {\n            return std::string(1, word[index]);\n    \
    \    }\n        index++;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7z3vwu7j.cpp: In function 'int main()':\n/tmp/tmp7z3vwu7j.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7z3vwu7j.cpp:2:\n/tmp/tmp7z3vwu7j.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6llg_zrp.cpp: In function 'int main()':\n/tmp/tmp6llg_zrp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6llg_zrp.cpp:2:\n/tmp/tmp6llg_zrp.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       i--;\n                continue;\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpymadpo_7.cpp: In function 'int main()':\n/tmp/tmpymadpo_7.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpymadpo_7.cpp:2:\n/tmp/tmpymadpo_7.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    std::string result = \"\";\n\tint index = -1;\n\tfor (int i = word.length() -\
    \ 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\
    \tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == -1) {\n\t\treturn result;\n\
    \t}\n\tfor (int i = index - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) ==\
    \ std::string::npos) {\n\t\t\tresult = word[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw6nuc4j_.cpp: In function 'int main()':\n/tmp/tmpw6nuc4j_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw6nuc4j_.cpp:2:\n/tmp/tmpw6nuc4j_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int vowel_index = -1;\n    int distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_index = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_index == -1) {\n        return \"\";\n    }\n    for (int i = vowel_index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            distance = vowel_index - i;\n            break;\n        }\n\
    \    }\n    if (distance == INT_MAX) {\n        return \"\";\n    }\n    for (int\
    \ i = vowel_index + 1; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            if (i - vowel_index < distance) {\n   \
    \             return word.substr(vowel_index, 1);\n            }\n           \
    \ break;\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2k43cyzl.cpp: In function 'int main()':\n/tmp/tmp2k43cyzl.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2k43cyzl.cpp:2:\n/tmp/tmp2k43cyzl.cpp:51:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = 0;\n            for (int j = i + 1; j < word.size();\
    \ j++) {\n                if (vowels.find(word[j]) != std::string::npos) {\n \
    \                   break;\n                }\n                distance++;\n \
    \           }\n            if (distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_kcvob3m.cpp: In function 'int main()':\n/tmp/tmp_kcvob3m.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_kcvob3m.cpp:2:\n/tmp/tmp_kcvob3m.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    int min_distance =\
    \ INT_MAX;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = word.length() - i;\n   \
    \         if (distance < min_distance) {\n                min_distance = distance;\n\
    \                index = i;\n            }\n        }\n    }\n    if (index !=\
    \ -1) {\n        result = word[index];\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpled4hba4.cpp: In function 'int main()':\n/tmp/tmpled4hba4.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpled4hba4.cpp:2:\n/tmp/tmpled4hba4.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiouAEIOU\"\
    ;\n\tstd::string result = \"\";\n\tint index = -1;\n\tfor (int i = word.length()\
    \ - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\
    \t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == -1) {\n\t\treturn result;\n\
    \t}\n\tfor (int i = index - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) ==\
    \ std::string::npos) {\n\t\t\tresult = word[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp22lr_x9w.cpp: In function 'int main()':\n/tmp/tmp22lr_x9w.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp22lr_x9w.cpp:2:\n/tmp/tmp22lr_x9w.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n  \
    \  int closest_vowel_distance = -1;\n    for (int i = 0; i < word.length(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ left_consonant_index = -1;\n            int right_consonant_index = -1;\n  \
    \          for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    left_consonant_index = j;\n   \
    \                 break;\n                }\n            }\n            for (int\
    \ j = i + 1; j < word.length(); j++) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    right_consonant_index = j;\n  \
    \                  break;\n                }\n            }\n            if (left_consonant_index\
    \ != -1 && right_consonant_index != -1) {\n                int vowel_distance\
    \ = right_consonant_index - left_consonant_index;\n                if (closest_vowel_distance\
    \ == -1 || vowel_distance < closest_vowel_distance) {\n                    closest_vowel_distance\
    \ = vowel_distance;\n                    closest_vowel_index = i;\n          \
    \      }\n            }\n        }\n    }\n    if (closest_vowel_index != -1)\
    \ {\n        closest_vowel = word[closest_vowel_index];\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprava1zwe.cpp: In function 'int main()':\n/tmp/tmprava1zwe.cpp:53:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprava1zwe.cpp:2:\n/tmp/tmprava1zwe.cpp:54:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.length();\n    int i = len - 1;\n    while (i >= 0) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cthohuw.cpp: In function 'int main()':\n/tmp/tmp4cthohuw.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4cthohuw.cpp:2:\n/tmp/tmp4cthohuw.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string res = \"\";\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            res\
    \ = word[i];\n            break;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmkwcqah3.cpp: In function 'int main()':\n/tmp/tmpmkwcqah3.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmkwcqah3.cpp:2:\n/tmp/tmpmkwcqah3.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) return result;\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo_g7k6nz.cpp: In function 'int main()':\n/tmp/tmpo_g7k6nz.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo_g7k6nz.cpp:2:\n/tmp/tmpo_g7k6nz.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index > 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            if (vowels.find(word[index - 1]) == std::string::npos) {\n      \
    \          result = word[index];\n                break;\n            }\n    \
    \    }\n        index--;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9m0a_39h.cpp: In function 'int main()':\n/tmp/tmp9m0a_39h.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9m0a_39h.cpp:2:\n/tmp/tmp9m0a_39h.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = 0; i\
    \ < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) return result;\n    for (int i = index + 1; i < word.length(); i++) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n        index = i;\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprtvbgfem.cpp: In function 'int main()':\n/tmp/tmprtvbgfem.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprtvbgfem.cpp:2:\n/tmp/tmprtvbgfem.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    if (result == \"\") {\n        return result;\n    }\n    int index_vowel\
    \ = index;\n    while (index >= 0) {\n        if (vowels.find(word[index]) ==\
    \ std::string::npos) {\n            break;\n        }\n        index--;\n    }\n\
    \    if (index == -1) {\n        return \"\";\n    }\n    index = index_vowel\
    \ + 1;\n    while (index < word.length()) {\n        if (vowels.find(word[index])\
    \ == std::string::npos) {\n            break;\n        }\n        index++;\n \
    \   }\n    if (index == word.length()) {\n        return \"\";\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6v27zpat.cpp: In function 'int main()':\n/tmp/tmp6v27zpat.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6v27zpat.cpp:2:\n/tmp/tmp6v27zpat.cpp:55:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       i--;\n                continue;\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpymadpo_7.cpp: In function 'int main()':\n/tmp/tmpymadpo_7.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpymadpo_7.cpp:2:\n/tmp/tmpymadpo_7.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            if(i == n-1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsbk3nvg1.cpp: In function 'int main()':\n/tmp/tmpsbk3nvg1.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsbk3nvg1.cpp:2:\n/tmp/tmpsbk3nvg1.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::vector<char> vowels = {'a',\
    \ 'e', 'i', 'o', 'u'};\n    std::vector<char> consonants = {'b', 'c', 'd', 'f',\
    \ 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z'};\n    std::vector<char>::iterator it;\n    std::vector<char>::iterator\
    \ it2;\n    std::vector<char>::iterator it3;\n    std::vector<char>::iterator\
    \ it4;\n    std::vector<char>::iterator it5;\n    std::vector<char>::iterator\
    \ it6;\n    std::vector<char>::iterator it7;\n    std::vector<char>::iterator\
    \ it8;\n    std::vector<char>::iterator it9;\n    std::vector<char>::iterator\
    \ it10;\n    std::vector<char>::iterator it11;\n    std::vector<char>::iterator\
    \ it12;\n    std::vector<char>::iterator it13;\n    std::vector<char>::iterator\
    \ it14;\n    std::vector<char>::iterator it15;\n    std::vector<char>::iterator\
    \ it16;\n    std::vector<char>::iterator it17;\n    std::vector<char>::iterator\
    \ it18;\n    std::vector<char>::iterator it19;\n    std::vector<char>::iterator\
    \ it20;\n    std::vector<char>::iterator it21;\n    std::vector<char>::iterator\
    \ it22;\n    std::vector<char>::iterator it23;\n    std::vector<char>::iterator\
    \ it24;\n    std::vector<char>::iterator it25;\n    std::vector<char>::iterator\
    \ it26;\n    std::vector<char>::iterator it27;\n    std::vector<char>::iterator\
    \ it28;\n    std::vector<char>::iterator it29;\n    std::vector<char>::iterator\
    \ it30;\n    std::vector<char>::iterator it31;\n    std::vector<\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_ppgx1el.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp_ppgx1el.cpp:18:56: error: in C++98 'vowels' must be initialized by constructor,\
    \ not by '{...}'\n     std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\
    \                                                        ^\n/tmp/tmp_ppgx1el.cpp:18:56:\
    \ error: could not convert '{'a', 'e', 'i', 'o', 'u'}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<char>'\n/tmp/tmp_ppgx1el.cpp:19:140: error: in C++98\
    \ 'consonants' must be initialized by constructor, not by '{...}'\n     std::vector<char>\
    \ consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};\n                                 \
    \                                                                            \
    \                               ^\n/tmp/tmp_ppgx1el.cpp:19:140: error: could not\
    \ convert '{'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'}' from '<brace-enclosed initializer list>'\
    \ to 'std::vector<char>'\n/tmp/tmp_ppgx1el.cpp:51:16: error: template argument\
    \ 1 is invalid\n     std::vector<\n                ^\n/tmp/tmp_ppgx1el.cpp:51:16:\
    \ error: template argument 2 is invalid\n/tmp/tmp_ppgx1el.cpp:52:1: error: expected\
    \ unqualified-id before '}' token\n }\n ^\n/tmp/tmp_ppgx1el.cpp: In function 'int\
    \ main()':\n/tmp/tmp_ppgx1el.cpp:54:10: error: 'candidate' does not name a type\n\
    \     auto candidate = get_closest_vowel;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ppgx1el.cpp:2:\n/tmp/tmp_ppgx1el.cpp:55:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            if (i == word.length() - 1) {\n                return result;\n\
    \            }\n            for (int j = i + 1; j < word.length(); j++) {\n  \
    \              if (vowels.find(word[j]) != std::string::npos) {\n            \
    \        if (index == -1) {\n                        index = j;\n            \
    \        } else {\n                        if (j < index) {\n                \
    \            index = j;\n                        }\n                    }\n  \
    \              }\n            }\n            if (index != -1) {\n            \
    \    result = word[index];\n            }\n            return result;\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5lyu6ncd.cpp: In function 'int main()':\n/tmp/tmp5lyu6ncd.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5lyu6ncd.cpp:2:\n/tmp/tmp5lyu6ncd.cpp:48:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ != -1) {\n        for (int i = index - 1; i >= 0; i--) {\n            if (vowels.find(word[i])\
    \ == std::string::npos) {\n                result = word[index];\n           \
    \     break;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwld3aqky.cpp: In function 'int main()':\n/tmp/tmpwld3aqky.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwld3aqky.cpp:2:\n/tmp/tmpwld3aqky.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int len = word.length();\n    int i = len - 1;\n\
    \    while(i >= 0) {\n        if(vowels.find(word[i]) != std::string::npos) {\n\
    \            if(i == len - 1) {\n                return \"\";\n            }\n\
    \            else if(vowels.find(word[i + 1]) != std::string::npos) {\n      \
    \          return \"\";\n            }\n            else {\n                return\
    \ word.substr(i, 1);\n            }\n        }\n        i--;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppptl14v1.cpp: In function 'int main()':\n/tmp/tmppptl14v1.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppptl14v1.cpp:2:\n/tmp/tmppptl14v1.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   if (i == word.length() - 1) {\n                return \"\";\n            }\n\
    \            if (vowels.find(word[i + 1]) == std::string::npos) {\n          \
    \      return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc413wr61.cpp: In function 'int main()':\n/tmp/tmpc413wr61.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc413wr61.cpp:2:\n/tmp/tmpc413wr61.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (index == -1) {\n                index = i;\n            }\
    \ else {\n                result = word[i];\n                break;\n        \
    \    }\n        } else {\n            index = -1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7d12l31l.cpp: In function 'int main()':\n/tmp/tmp7d12l31l.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7d12l31l.cpp:2:\n/tmp/tmp7d12l31l.cpp:37:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       return \"\";\n            }\n            if (vowels.find(word[i+1]) ==\
    \ std::string::npos) {\n                return word.substr(i, 1);\n          \
    \  }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvtpupf40.cpp: In function 'int main()':\n/tmp/tmpvtpupf40.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvtpupf40.cpp:2:\n/tmp/tmpvtpupf40.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    int index = word.size() - 1;\n\twhile (index >= 0) {\n\t\tif (vowels.find(word[index])\
    \ != std::string::npos) {\n\t\t\tif (index == 0) {\n\t\t\t\treturn \"\";\n\t\t\
    \t}\n\t\t\tif (vowels.find(word[index - 1]) == std::string::npos) {\n\t\t\t\t\
    return word.substr(index, 1);\n\t\t\t}\n\t\t}\n\t\tindex--;\n\t}\n\treturn \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprkm581by.cpp: In function 'int main()':\n/tmp/tmprkm581by.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprkm581by.cpp:2:\n/tmp/tmprkm581by.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            if (index == -1) {\n                index = i;\n            }\
    \ else {\n                break;\n            }\n        } else if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (index != -1) {\n                result\
    \ = word[i];\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyxx49p71.cpp: In function 'int main()':\n/tmp/tmpyxx49p71.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyxx49p71.cpp:2:\n/tmp/tmpyxx49p71.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    int min = INT_MAX;\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int k = i + 1;\n                while (k < word.length() && vowels.find(word[k])\
    \ != std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.length()) {\n                    if (min > k - j) {\n\
    \                        min = k - j;\n                        index = i;\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ if (index != -1) {\n        return word.substr(index, 1);\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdddoogqm.cpp: In function 'int main()':\n/tmp/tmpdddoogqm.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdddoogqm.cpp:2:\n/tmp/tmpdddoogqm.cpp:48:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int pos = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3senipnm.cpp: In function 'int main()':\n/tmp/tmp3senipnm.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3senipnm.cpp:2:\n/tmp/tmp3senipnm.cpp:37:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    int index = -1;\n\
    \    int min_distance = INT_MAX;\n    for (int i = 0; i < word.length(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.length() - i;\n            if (distance < min_distance) {\n\
    \                min_distance = distance;\n                index = i;\n      \
    \      }\n        }\n    }\n    if (index != -1) {\n        result += word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvh84eky8.cpp: In function 'int main()':\n/tmp/tmpvh84eky8.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvh84eky8.cpp:2:\n/tmp/tmpvh84eky8.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    int closest_vowel_distance = -1;\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int distance = word.length() - i;\n            if (closest_vowel_distance\
    \ == -1 || distance < closest_vowel_distance) {\n                closest_vowel_distance\
    \ = distance;\n                closest_vowel_index = i;\n            }\n     \
    \   }\n    }\n    if (closest_vowel_index != -1) {\n        closest_vowel = word[closest_vowel_index];\n\
    \    }\n    return closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcul_x6nh.cpp: In function 'int main()':\n/tmp/tmpcul_x6nh.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcul_x6nh.cpp:2:\n/tmp/tmpcul_x6nh.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos > 0 && vowels.find(word[pos - 1])\
    \ == std::string::npos) {\n                return word.substr(pos, 1);\n     \
    \       }\n        }\n        pos--;\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_jc4ggtv.cpp: In function 'int main()':\n/tmp/tmp_jc4ggtv.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_jc4ggtv.cpp:2:\n/tmp/tmp_jc4ggtv.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos == 0) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9zf75_46.cpp: In function 'int main()':\n/tmp/tmp9zf75_46.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9zf75_46.cpp:2:\n/tmp/tmp9zf75_46.cpp:35:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.length();\n    int i = len - 1;\n    while (i >= 0) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cthohuw.cpp: In function 'int main()':\n/tmp/tmp4cthohuw.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4cthohuw.cpp:2:\n/tmp/tmp4cthohuw.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   result = word[i];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp20i7j2a_.cpp: In function 'int main()':\n/tmp/tmp20i7j2a_.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp20i7j2a_.cpp:2:\n/tmp/tmp20i7j2a_.cpp:30:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // your code here\n    std::string\
    \ vowels = \"aeiou\";\n    std::string result = \"\";\n    int index = -1;\n \
    \   for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return result;\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[index];\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkzs0wb8a.cpp: In function 'int main()':\n/tmp/tmpkzs0wb8a.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkzs0wb8a.cpp:2:\n/tmp/tmpkzs0wb8a.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n       \
    \ if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n   \
    \         break;\n        }\n    }\n    if (pos == -1) return \"\";\n    for (int\
    \ i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(pos, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptl5b1uf9.cpp: In function 'int main()':\n/tmp/tmptl5b1uf9.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptl5b1uf9.cpp:2:\n/tmp/tmptl5b1uf9.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    if (index == 0) {\n        return \"\";\n    }\n    index--;\n   \
    \ while (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos)\
    \ {\n            return \"\";\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptn0ipjvq.cpp: In function 'int main()':\n/tmp/tmptn0ipjvq.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptn0ipjvq.cpp:2:\n/tmp/tmptn0ipjvq.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    std::string result\
    \ = \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplmaul2_6.cpp: In function 'int main()':\n/tmp/tmplmaul2_6.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplmaul2_6.cpp:2:\n/tmp/tmplmaul2_6.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int len = word.length();\n    int\
    \ i = len - 1;\n    while(i >= 0) {\n        if(word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if(i ==\
    \ len - 1) {\n                return \"\";\n            }\n            else if(i\
    \ == 0) {\n                return \"\";\n            }\n            else if(word[i\
    \ - 1] == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o'\
    \ || word[i - 1] == 'u') {\n                i--;\n            }\n            else\
    \ if(word[i + 1] == 'a' || word[i + 1] == 'e' || word[i + 1] == 'i' || word[i\
    \ + 1] == 'o' || word[i + 1] == 'u') {\n                i--;\n            }\n\
    \            else {\n                return word.substr(i, 1);\n            }\n\
    \        }\n        else {\n            i--;\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcg7mczd5.cpp: In function 'int main()':\n/tmp/tmpcg7mczd5.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcg7mczd5.cpp:2:\n/tmp/tmpcg7mczd5.cpp:46:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int index = word.length() - 1;\n    while (index >= 0) {\n        if (consonants.find(word[index])\
    \ != std::string::npos) {\n            break;\n        }\n        index--;\n \
    \   }\n    if (index == 0) {\n        return \"\";\n    }\n    for (int i = index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word.substr(i, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdq6bu99y.cpp: In function 'int main()':\n/tmp/tmpdq6bu99y.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdq6bu99y.cpp:2:\n/tmp/tmpdq6bu99y.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    int len =\
    \ word.length();\n    int i = len - 1;\n    while(i >= 0) {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if(i == len - 1) {\n                return \"\";\n          \
    \  }\n            else if(word[i + 1] == 'a' || word[i + 1] == 'e' || word[i +\
    \ 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u') {\n                return\
    \ \"\";\n            }\n            else {\n                return word.substr(i,\
    \ 1);\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwdrntobc.cpp: In function 'int main()':\n/tmp/tmpwdrntobc.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwdrntobc.cpp:2:\n/tmp/tmpwdrntobc.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    if (index == 0) {\n        return \"\";\n    }\n    int index_vowel\
    \ = index;\n    while (index >= 0) {\n        if (vowels.find(word[index]) ==\
    \ std::string::npos) {\n            if (index_vowel - index == 1) {\n        \
    \        return result;\n            }\n            index_vowel = index;\n   \
    \     }\n        index--;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptlqokohj.cpp: In function 'int main()':\n/tmp/tmptlqokohj.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptlqokohj.cpp:2:\n/tmp/tmptlqokohj.cpp:45:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            closest_vowel = word[i];\n            closest_vowel_index\
    \ = i;\n            break;\n        }\n    }\n    if (closest_vowel_index == -1)\
    \ {\n        return \"\";\n    }\n    for (int i = closest_vowel_index - 1; i\
    \ >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n   \
    \         return closest_vowel;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0q9u0w7z.cpp: In function 'int main()':\n/tmp/tmp0q9u0w7z.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0q9u0w7z.cpp:2:\n/tmp/tmp0q9u0w7z.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiou\";\n    std::string result = \"\";\n    int pos = -1;\n   \
    \ for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return result;\n    }\n    for (int i =\
    \ pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[pos];\n            break;\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsc78kn0j.cpp: In function 'int main()':\n/tmp/tmpsc78kn0j.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsc78kn0j.cpp:2:\n/tmp/tmpsc78kn0j.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int pos = word.size() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos > 0 && vowels.find(word[pos - 1])\
    \ == std::string::npos) {\n                return word.substr(pos, 1);\n     \
    \       }\n        }\n        pos--;\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw_731w2k.cpp: In function 'int main()':\n/tmp/tmpw_731w2k.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw_731w2k.cpp:2:\n/tmp/tmpw_731w2k.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int word_size = word.size();\n    int vowel_pos = -1;\n    for (int i =\
    \ word_size - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_pos = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_pos == -1) {\n        return \"\";\n    }\n    for (int i = vowel_pos\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(vowel_pos, 1);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjqd8lcwn.cpp: In function 'int main()':\n/tmp/tmpjqd8lcwn.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjqd8lcwn.cpp:2:\n/tmp/tmpjqd8lcwn.cpp:39:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    int min_distance\
    \ = INT_MAX;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while (j >=\
    \ 0 && vowels.find(word[j]) != std::string::npos) {\n                j--;\n  \
    \          }\n            if (j >= 0) {\n                int k = i + 1;\n    \
    \            while (k < word.length() && vowels.find(word[k]) != std::string::npos)\
    \ {\n                    k++;\n                }\n                if (k < word.length())\
    \ {\n                    if (min_distance > k - j) {\n                       \
    \ min_distance = k - j;\n                        result = word[i];\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpelyem78c.cpp: In function 'int main()':\n/tmp/tmpelyem78c.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpelyem78c.cpp:2:\n/tmp/tmpelyem78c.cpp:46:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5syz_woe.cpp: In function 'int main()':\n/tmp/tmp5syz_woe.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5syz_woe.cpp:2:\n/tmp/tmp5syz_woe.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5syz_woe.cpp: In function 'int main()':\n/tmp/tmp5syz_woe.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5syz_woe.cpp:2:\n/tmp/tmp5syz_woe.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    int len = word.length();\n    int i = len - 1;\n    while(i >= 0) {\n \
    \       if(vowels.find(word[i]) != std::string::npos) {\n            if(i == len\
    \ - 1) {\n                return \"\";\n            }\n            if(consonants.find(word[i\
    \ + 1]) != std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5tb_3q5.cpp: In function 'int main()':\n/tmp/tmpg5tb_3q5.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5tb_3q5.cpp:2:\n/tmp/tmpg5tb_3q5.cpp:37:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index > 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            if (vowels.find(word[index - 1]) == std::string::npos) {\n      \
    \          result = word[index];\n                break;\n            }\n    \
    \    }\n        index--;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9m0a_39h.cpp: In function 'int main()':\n/tmp/tmp9m0a_39h.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9m0a_39h.cpp:2:\n/tmp/tmp9m0a_39h.cpp:34:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    int i = word.length() - 1;\n\twhile (i >= 0) {\n\t\tif (vowels.find(word[i]) !=\
    \ std::string::npos) {\n\t\t\tif (i == word.length() - 1) {\n\t\t\t\treturn \"\
    \";\n\t\t\t}\n\t\t\tif (vowels.find(word[i + 1]) == std::string::npos) {\n\t\t\
    \t\treturn word.substr(i, 1);\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\treturn \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6jwpd5vu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.length();\n    int i = len - 1;\n    while (i >= 0) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cthohuw.cpp: In function 'int main()':\n/tmp/tmp4cthohuw.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4cthohuw.cpp:2:\n/tmp/tmp4cthohuw.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            result = word[i];\n            index = i;\n            break;\n\
    \        }\n    }\n    if (index == -1) {\n        return \"\";\n    }\n    for\
    \ (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return result;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi3ii4qed.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n \
    \           break;\n        }\n    }\n    if (pos == -1) {\n        return \"\"\
    ;\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0fjg5w_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       i--;\n                continue;\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpymadpo_7.cpp: In function 'int main()':\n/tmp/tmpymadpo_7.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpymadpo_7.cpp:2:\n/tmp/tmpymadpo_7.cpp:36:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \        pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkp_agm1y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n \
    \   for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i + 1;\n            while (j <\
    \ word.size() && vowels.find(word[j]) != std::string::npos) {\n              \
    \  j++;\n            }\n            if (j < word.size()) {\n                if\
    \ (closest_vowel_distance == -1 || j - i < closest_vowel_distance) {\n       \
    \             closest_vowel_distance = j - i;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqu0_x2k_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int len = word.length();\n    int i = len - 1;\n\
    \    while(i >= 0) {\n        if(vowels.find(word[i]) != std::string::npos) {\n\
    \            if(i == len - 1) {\n                return \"\";\n            }\n\
    \            else if(vowels.find(word[i + 1]) != std::string::npos) {\n      \
    \          return \"\";\n            }\n            else {\n                return\
    \ word.substr(i, 1);\n            }\n        }\n        i--;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppptl14v1.cpp: In function 'int main()':\n/tmp/tmppptl14v1.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppptl14v1.cpp:2:\n/tmp/tmppptl14v1.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int pos = word.size() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (pos == 0) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwyv261yr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int i = word.size() - 1;\n    while\
    \ (i >= 0) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u') {\n            break;\n        }\n       \
    \ i--;\n    }\n    if (i == 0) {\n        return \"\";\n    }\n    int j = i -\
    \ 1;\n    while (j >= 0) {\n        if (word[j] != 'a' && word[j] != 'e' && word[j]\
    \ != 'i' && word[j] != 'o' && word[j] != 'u') {\n            break;\n        }\n\
    \        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    return\
    \ word.substr(j + 1, i - j);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa594x8sm.cpp: In function 'int main()':\n/tmp/tmpa594x8sm.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa594x8sm.cpp:2:\n/tmp/tmpa594x8sm.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n       \
    \ if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n   \
    \         break;\n        }\n    }\n    if (pos == -1) {\n        return \"\"\
    ;\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgs0ja8f3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n  \
    \  for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            closest_vowel = word[i];\n            closest_vowel_index\
    \ = i;\n            break;\n        }\n    }\n    if (closest_vowel_index == -1)\
    \ {\n        return \"\";\n    }\n    for (int i = closest_vowel_index - 1; i\
    \ >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n   \
    \         return closest_vowel;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprznjcghh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    int min_distance = word.length();\n\
    \    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while (j >=\
    \ 0 && vowels.find(word[j]) != std::string::npos) {\n                j--;\n  \
    \          }\n            if (j >= 0) {\n                int k = i + 1;\n    \
    \            while (k < word.length() && vowels.find(word[k]) != std::string::npos)\
    \ {\n                    k++;\n                }\n                if (k < word.length())\
    \ {\n                    if (k - i < min_distance) {\n                       \
    \ min_distance = k - i;\n                        index = i;\n                \
    \    }\n                }\n            }\n        }\n    }\n    if (index != -1)\
    \ {\n        result = word[index];\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5yr40v6f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int vowel_index = -1;\n    int word_length = word.length();\n    for (int\
    \ i = word_length - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_index = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_index == -1) {\n        return \"\";\n    }\n    for (int i = vowel_index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(vowel_index, 1);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp443idavu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiou\";\n \
    \ std::string result = \"\";\n  int index = -1;\n  for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos) {\n\
    \      index = i;\n      break;\n    }\n  }\n  if (index == -1) {\n    return\
    \ result;\n  }\n  for (int i = index - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      result = word[index];\n      break;\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpar_zwgt8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (closest_vowel_index == -1) {\n    \
    \            closest_vowel_index = i;\n                closest_vowel = word[i];\n\
    \            } else {\n                if (i < closest_vowel_index) {\n      \
    \              closest_vowel_index = i;\n                    closest_vowel = word[i];\n\
    \                }\n            }\n        } else {\n            if (closest_vowel_index\
    \ != -1) {\n                return closest_vowel;\n            }\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmr5759bj.cpp: In function 'int main()':\n/tmp/tmpmr5759bj.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmr5759bj.cpp:2:\n/tmp/tmpmr5759bj.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    int i = n - 1;\n    while(i >= 0) {\n     \
    \   if(vowels.find(word[i]) != std::string::npos) {\n            if(i == n - 1)\
    \ {\n                return \"\";\n            }\n            else if(vowels.find(word[i\
    \ + 1]) != std::string::npos) {\n                return \"\";\n            }\n\
    \            else {\n                return word.substr(i, 1);\n            }\n\
    \        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp46kqvk2i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        for (int j = 0; j < vowels.length(); j++) {\n \
    \           if (word[i] == vowels[j]) {\n                index = i;\n        \
    \        break;\n            }\n        }\n        if (index != -1) {\n      \
    \      break;\n        }\n    }\n    if (index != -1) {\n        for (int i =\
    \ index - 1; i >= 0; i--) {\n            for (int j = 0; j < vowels.length();\
    \ j++) {\n                if (word[i] == vowels[j]) {\n                    return\
    \ result;\n                }\n            }\n            for (int j = 0; j < vowels.length();\
    \ j++) {\n                if (word[index] == vowels[j]) {\n                  \
    \  result = word[index];\n                    return result;\n               \
    \ }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1gaa9xq5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int vowel_pos = -1;\n    int word_len = word.length();\n    for (int i\
    \ = word_len - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_pos = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_pos == -1) {\n        return \"\";\n    }\n    for (int i = vowel_pos\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(vowel_pos, 1);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpln2_wjcm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       return \"\";\n            }\n            if (vowels.find(word[i + 1])\
    \ == std::string::npos) {\n                return word.substr(i, 1);\n       \
    \     }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa_d_tpto.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.length();\n    int i = len - 1;\n    while (i >= 0) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            else if\
    \ (vowels.find(word[i + 1]) == std::string::npos) {\n                return word.substr(i,\
    \ 1);\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7lz4cf0y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = 0;\n    int min_distance =\
    \ word.length();\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = word.length() - i;\n   \
    \         if (distance < min_distance) {\n                min_distance = distance;\n\
    \                index = i;\n            }\n        }\n    }\n    if (min_distance\
    \ != word.length()) {\n        for (int i = index; i >= 0; i--) {\n          \
    \  if (consonants.find(word[i]) != std::string::npos) {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7m7vbccb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int len = word.length();\n    int i = len - 1;\n\
    \    while(i >= 0) {\n        if(vowels.find(word[i]) != std::string::npos) {\n\
    \            if(i == len - 1) {\n                return \"\";\n            }\n\
    \            else {\n                if(vowels.find(word[i+1]) != std::string::npos)\
    \ {\n                    return \"\";\n                }\n                else\
    \ {\n                    return word.substr(i, 1);\n                }\n      \
    \      }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz2225ozz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int i = word.length() - 1;\n    while (i\
    \ >= 0) {\n        if (vowels.find(word[i]) != std::string::npos) {\n        \
    \    result = word[i];\n            break;\n        }\n        i--;\n    }\n \
    \   if (result == \"\") {\n        return result;\n    }\n    i--;\n    while\
    \ (i >= 0) {\n        if (vowels.find(word[i]) != std::string::npos) {\n     \
    \       return result;\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyvrsfnl4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int min_distance = INT_MAX;\n  \
    \  int distance = 0;\n    for (int i = 0; i < word.length(); i++) {\n        if\
    \ (vowels.find(word[i]) != std::string::npos) {\n            for (int j = i +\
    \ 1; j < word.length(); j++) {\n                if (vowels.find(word[j]) != std::string::npos)\
    \ {\n                    distance = j - i;\n                    if (distance <\
    \ min_distance) {\n                        min_distance = distance;\n        \
    \                closest_vowel = word[i];\n                    }\n           \
    \         break;\n                }\n            }\n        }\n    }\n    return\
    \ closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnjxurmz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result += word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyiv_fx4v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int min_distance = word.length();\n   \
    \ for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = word.length() - i;\n   \
    \         if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpae4zeo_l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i - 1;\n            if (distance\
    \ < min_distance) {\n                min_distance = distance;\n              \
    \  result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnbxplx_b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    int min_distance =\
    \ INT_MAX;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while (j >=\
    \ 0 && vowels.find(word[j]) != std::string::npos) {\n                j--;\n  \
    \          }\n            if (j >= 0) {\n                int distance = i - j;\n\
    \                if (distance < min_distance) {\n                    min_distance\
    \ = distance;\n                    index = i;\n                }\n           \
    \ }\n        }\n    }\n    if (index != -1) {\n        result += word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_5kq42ck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int j = i - 1;\n            while (j >= 0 && vowels.find(word[j])\
    \ != std::string::npos) {\n                j--;\n            }\n            if\
    \ (j >= 0) {\n                int distance = i - j;\n                if (distance\
    \ < min_distance) {\n                    min_distance = distance;\n          \
    \          result = word[i];\n                }\n            }\n        }\n  \
    \  }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1q18qfe2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0iwdkh9f.cpp: In function 'int main()':\n/tmp/tmp0iwdkh9f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0iwdkh9f.cpp:2:\n/tmp/tmp0iwdkh9f.cpp:38:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.length();\n    for (int i = len - 1; i >= 0; i--) {\n  \
    \      if (vowels.find(word[i]) != std::string::npos) {\n            if (i ==\
    \ len - 1) {\n                return \"\";\n            }\n            if (vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf8rlahss.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n  \
    \  int closest_vowel_distance = -1;\n    for (int i = word.length() - 1; i >=\
    \ 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n      \
    \      for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    if (closest_vowel_distance == -1\
    \ || closest_vowel_distance > i - j) {\n                        closest_vowel_distance\
    \ = i - j;\n                        closest_vowel_index = i;\n               \
    \     }\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    if (closest_vowel_index != -1) {\n        closest_vowel = word.substr(closest_vowel_index,\
    \ 1);\n    }\n    return closest_vowel;\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbf_j7119.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int vowel_index = -1;\n    int vowel_distance = -1;\n    for (int i = 0;\
    \ i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (i > 0 && vowels.find(word[i-1]) == std::string::npos) {\n\
    \                if (vowel_distance == -1 || i - vowel_index < vowel_distance)\
    \ {\n                    vowel_index = i;\n                    vowel_distance\
    \ = i - vowel_index;\n                }\n            }\n        }\n    }\n   \
    \ if (vowel_index == -1) {\n        return \"\";\n    }\n    return word.substr(vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnqzmb5tk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int pos = word.length() - 1;\n    while (pos > 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp28h0q_yv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    std::string result = \"\";\n\tint index = -1;\n\tfor (int i = word.length() -\
    \ 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\
    \tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == -1) {\n\t\treturn result;\n\
    \t}\n\tfor (int i = index - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) ==\
    \ std::string::npos) {\n\t\t\treturn word[index];\n\t\t}\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprjnuwi6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    int i = n - 1;\n    while(i >= 0) {\n     \
    \   if(vowels.find(word[i]) != std::string::npos) {\n            if(i == n - 1)\
    \ {\n                return \"\";\n            }\n            if(vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpar89jh29.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\"\
    ;\n  std::string result = \"\";\n  int index = -1;\n  for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos) {\n\
    \      index = i;\n      break;\n    }\n  }\n  if (index == -1) {\n    return\
    \ result;\n  }\n  for (int i = index - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      result = word[index];\n      break;\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl6rpkc1o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            if(i == n-1) {\n                return\
    \ \"\";\n            }\n            else if(vowels.find(word[i+1]) != std::string::npos)\
    \ {\n                continue;\n            }\n            else {\n          \
    \      return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpajwtlq0a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int j = i + 1;\n            while (j < word.size() && vowels.find(word[j])\
    \ != std::string::npos) {\n                j++;\n            }\n            if\
    \ (j < word.size()) {\n                int distance = j - i;\n               \
    \ if (distance < min_distance) {\n                    min_distance = distance;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnau3dova.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphag83gyx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    int min_distance =\
    \ word.length();\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i + 1;\n            while (j <\
    \ word.length() && vowels.find(word[j]) != std::string::npos) {\n            \
    \    j++;\n            }\n            if (j < word.length()) {\n             \
    \   if (j - i < min_distance) {\n                    min_distance = j - i;\n \
    \                   index = i;\n                }\n            }\n           \
    \ i = j;\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplba09nvi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    int index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return result;\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[index];\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5rgks1zh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (closest_vowel_index == -1) {\n    \
    \            closest_vowel_index = i;\n                closest_vowel = word[i];\n\
    \            } else {\n                if (i + 1 < closest_vowel_index) {\n  \
    \                  closest_vowel_index = i;\n                    closest_vowel\
    \ = word[i];\n                }\n            }\n        } else {\n           \
    \ if (closest_vowel_index != -1) {\n                return closest_vowel;\n  \
    \          }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp986xq_h2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n  // your code here\n  int n = word.length();\n\
    \  int i;\n  for(i = n-1; i >= 0; i--) {\n    if(word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n      break;\n\
    \    }\n  }\n  if(i == 0) {\n    return \"\";\n  }\n  for(int j = i-1; j >= 0;\
    \ j--) {\n    if(word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j]\
    \ != 'o' && word[j] != 'u') {\n      return word.substr(i, 1);\n    }\n  }\n \
    \ return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqv_u8_g6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            if (index == -1) {\n                index = i;\n            }\
    \ else {\n                break;\n            }\n        } else if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (index != -1) {\n                result\
    \ = word[i];\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyxx49p71.cpp: In function 'int main()':\n/tmp/tmpyxx49p71.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyxx49p71.cpp:2:\n/tmp/tmpyxx49p71.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = 0;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == 0) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpm85294s8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiou\";\n    int index = -1;\n    for(int i = word.length() - 1;\
    \ i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n  \
    \          index = i;\n            break;\n        }\n    }\n    if(index == -1)\
    \ {\n        return \"\";\n    }\n    int count = 0;\n    for(int i = index -\
    \ 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n\
    \            count++;\n        }\n    }\n    if(count % 2 == 0) {\n        return\
    \ \"\";\n    }\n    return word.substr(index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6snf36eo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int i = word.length() - 1;\n    while (i\
    \ >= 0) {\n        if (vowels.find(word[i]) != std::string::npos) {\n        \
    \    result = word[i];\n            break;\n        }\n        i--;\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw2_buwrf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    int last_index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return result;\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            last_index = i;\n            break;\n        }\n    }\n    if\
    \ (last_index == -1) {\n        return result;\n    }\n    return word.substr(index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppbppxvcs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int min_distance = word.length();\n   \
    \ for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while (j >=\
    \ 0 && vowels.find(word[j]) != std::string::npos) {\n                j--;\n  \
    \          }\n            if (j >= 0) {\n                int k = i + 1;\n    \
    \            while (k < word.length() && vowels.find(word[k]) != std::string::npos)\
    \ {\n                    k++;\n                }\n                if (k < word.length())\
    \ {\n                    int distance = k - j - 1;\n                    if (distance\
    \ < min_distance) {\n                        min_distance = distance;\n      \
    \                  result = word.substr(i, 1);\n                    }\n      \
    \          }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3zaz8czo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(index, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2j1l16tv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpggbcdvuc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int closest_vowel_index = -1;\n    int closest_vowel_distance = INT_MAX;\n\
    \    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i;\n            while (j < word.size()\
    \ && vowels.find(word[j]) != std::string::npos) {\n                j++;\n    \
    \        }\n            if (j < word.size() && vowels.find(word[j]) == std::string::npos)\
    \ {\n                int k = j;\n                while (k < word.size() && vowels.find(word[k])\
    \ == std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.size() && vowels.find(word[k]) != std::string::npos)\
    \ {\n                    if (k - i < closest_vowel_distance) {\n             \
    \           closest_vowel_distance = k - i;\n                        closest_vowel_index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \   }\n    if (closest_vowel_index == -1) {\n        return \"\";\n    }\n   \
    \ return word.substr(closest_vowel_index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphlgb2czf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == word.size() - 1) {\n         \
    \       return \"\";\n            }\n            if (vowels.find(word[i + 1])\
    \ == std::string::npos) {\n                return word.substr(i, 1);\n       \
    \     }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa_d_tpto.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiou\";\n    int index = word.size() - 1;\n    while (index >= 0)\
    \ {\n        if (vowels.find(word[index]) != std::string::npos) {\n          \
    \  if (index == word.size() - 1) {\n                index--;\n               \
    \ continue;\n            }\n            if (vowels.find(word[index + 1]) == std::string::npos)\
    \ {\n                return word.substr(index, 1);\n            }\n        }\n\
    \        index--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp8iv1xi8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            if(i == n-1) {\n                return\
    \ \"\";\n            }\n            else if(vowels.find(word[i+1]) != std::string::npos)\
    \ {\n                continue;\n            }\n            else {\n          \
    \      return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpajwtlq0a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = 0;\n    int min_dist = INT_MAX;\n\
    \    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int dist = 0;\n            for (int j =\
    \ i + 1; j < word.length(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    dist = j - i;\n               \
    \     break;\n                }\n            }\n            if (dist < min_dist)\
    \ {\n                min_dist = dist;\n                index = i;\n          \
    \  }\n        }\n    }\n    if (min_dist != INT_MAX) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp81hg0hy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            if (index == word.size() - 1) {\n     \
    \           return \"\";\n            }\n            if (vowels.find(word[index\
    \ + 1]) == std::string::npos) {\n                return word.substr(index, 1);\n\
    \            }\n        }\n        index--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1xotgj8n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirf5xhux.cpp: In function 'int main()':\n/tmp/tmpirf5xhux.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpirf5xhux.cpp:2:\n/tmp/tmpirf5xhux.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int word_size = word.size();\n    for (int\
    \ i = word_size - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            result = word[i];\n            break;\n        }\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3p3u_tv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int closest_vowel_index = -1;\n    int closest_vowel_distance = INT_MAX;\n\
    \    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int j = i + 1;\n            while (j <\
    \ word.size() && vowels.find(word[j]) != std::string::npos) {\n              \
    \  j++;\n            }\n            if (j < word.size()) {\n                int\
    \ distance = j - i;\n                if (distance < closest_vowel_distance) {\n\
    \                    closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2c1sb2re.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = 0;\n            for (int j = i + 1; j < word.size();\
    \ j++) {\n                if (vowels.find(word[j]) != std::string::npos) {\n \
    \                   break;\n                }\n                distance++;\n \
    \           }\n            if (distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_kcvob3m.cpp: In function 'int main()':\n/tmp/tmp_kcvob3m.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_kcvob3m.cpp:2:\n/tmp/tmp_kcvob3m.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i - 1;\n            if (distance\
    \ < min_distance) {\n                min_distance = distance;\n              \
    \  result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnbxplx_b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int min_distance = INT_MAX;\n    int distance\
    \ = 0;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            for (int j = i + 1; j < word.length();\
    \ j++) {\n                if (consonants.find(word[j]) != std::string::npos) {\n\
    \                    distance = j - i;\n                    if (distance < min_distance)\
    \ {\n                        min_distance = distance;\n                      \
    \  result = word[i];\n                    }\n                    break;\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuko2beja.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int vowel_index = -1;\n    for (int i =\
    \ word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_index = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_index == -1) {\n        return result;\n    }\n    for (int i = vowel_index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[vowel_index];\n            break;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjz1kil6f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n\tstd::string vowels = \"aeiou\";\n\t\
    int index = -1;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index\
    \ == -1) {\n\t\treturn \"\";\n\t}\n\tfor (int i = index - 1; i >= 0; i--) {\n\t\
    \tif (vowels.find(word[i]) == std::string::npos) {\n\t\t\treturn word.substr(i\
    \ + 1, 1);\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7hnwzgx4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int closest_vowel_index = -1;\n    for (int i = word.length() - 1; i >=\
    \ 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n      \
    \      closest_vowel_index = i;\n            break;\n        }\n    }\n    if\
    \ (closest_vowel_index == -1) {\n        return \"\";\n    }\n    for (int i =\
    \ closest_vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) ==\
    \ std::string::npos) {\n            return word.substr(closest_vowel_index, 1);\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8vchybwv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int closest_index = -1;\n    for\
    \ (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (i > 0 && vowels.find(word[i-1]) == std::string::npos) {\n\
    \                if (closest_index == -1 || i < closest_index) {\n           \
    \         closest_index = i;\n                    closest_vowel = word[i];\n \
    \               }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6jqxw473.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    std::string result = \"\";\n    int index = 0;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            result = word[i];\n            break;\n        }\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkjhx4267.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int min_distance = INT_MAX;\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        for (int j = 0; j < vowels.size(); j++)\
    \ {\n            if (word[i] == vowels[j]) {\n                int distance = 0;\n\
    \                for (int k = i; k < word.size(); k++) {\n                   \
    \ if (vowels.find(word[k]) == std::string::npos) {\n                        distance++;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n                if (distance < min_distance) {\n\
    \                    min_distance = distance;\n                    result = word[i];\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu8fp7xrj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string closest_vowel = \"\";\n    int distance = word.length();\n\
    \    for (int i = 0; i < word.length(); i++) {\n        for (int j = 0; j < vowels.length();\
    \ j++) {\n            if (word[i] == vowels[j]) {\n                if (i < distance)\
    \ {\n                    distance = i;\n                    closest_vowel = word[i];\n\
    \                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk_cdhuvw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiou\";\n\
    \    std::string result = \"\";\n    int pos = word.length() - 1;\n    while (pos\
    \ >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos) {\n      \
    \      result = word[pos];\n            pos--;\n            break;\n        }\n\
    \        pos--;\n    }\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            result = \"\";\n            break;\n  \
    \      }\n        pos--;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_m1odm7z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n \
    \           break;\n        }\n    }\n    if (pos == -1) {\n        return \"\"\
    ;\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo671zr6l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = -1;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    for (int i = index - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n         \
    \   result = word[index];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14uzce5_.cpp: In function 'int main()':\n/tmp/tmp14uzce5_.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14uzce5_.cpp:2:\n/tmp/tmp14uzce5_.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string result = \"\";\n    int index = word.length() - 1;\n    while\
    \ (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos) {\n\
    \            result = word[index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4rf9t65t.cpp: In function 'int main()':\n/tmp/tmp4rf9t65t.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4rf9t65t.cpp:2:\n/tmp/tmp4rf9t65t.cpp:32:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int n = word.length();\n    int i = n - 1;\n    while(i >= 0) {\n     \
    \   if(vowels.find(word[i]) != std::string::npos) {\n            if(i == n - 1)\
    \ {\n                return \"\";\n            }\n            if(vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n \
    \           }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpar89jh29.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748609
