name: HumanEval_10_make_palindrome
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome\
  \ that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the\
  \ longest postfix of supplied string that is a palindrome.\n// - Append to the end\
  \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
  // >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n//\
  \ (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string\
  \ string) {\n"
tests: "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\
  \")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"\
  xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"\
  jerry\")) == (\"jerryrrej\"));\n}\n"
completions: ["    std::string result;\n    int length = string.length();\n    int\
    \ i = 0;\n    int j = length - 1;\n    while (i < j) {\n        if (string[i]\
    \ == string[j]) {\n            i++;\n            j--;\n        } else {\n    \
    \        i = 0;\n            j--;\n        }\n    }\n    result = string.substr(length\
    \ - j - 1);\n    std::reverse(result.begin(), result.end());\n    result += string;\n\
    \    return result;", "    // Find the longest postfix that is a palindrome.\n\
    \    std::string postfix;\n    for (int i = string.size() - 1; i >= 0; --i) {\n\
    \        if (string.substr(i) == std::string(postfix.rbegin(), postfix.rend()))\
    \ {\n            break;\n        }\n        postfix += string[i];\n    }\n   \
    \ // Append reverse of the prefix to the end of the string.\n    std::string prefix(string.begin(),\
    \ string.end() - postfix.size());\n    return string + std::string(prefix.rbegin(),\
    \ prefix.rend());", "    std::string result;\n    std::string reverse;\n    std::string::iterator\
    \ it;\n    std::string::reverse_iterator rit;\n    for (it = string.begin(); it\
    \ != string.end(); it++) {\n        reverse.push_back(*it);\n    }\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    std::string::iterator it2;\n    std::string::iterator it3;\n\
    \    std::string::iterator it4;\n    std::string::iterator it5;\n    std::string::iterator\
    \ it6;\n    std::string::iterator it7;\n    std::string::iterator it8;\n    std::string::iterator\
    \ it9;\n    std::string::iterator it10;\n    std::string::iterator it11;\n   \
    \ std::string::iterator it12;\n    std::string::iterator it13;\n    std::string::iterator\
    \ it14;\n    std::string::iterator it15;\n    std::string::iterator it16;\n  \
    \  std::string::iterator it17;\n    std::string::iterator it18;\n    std::string::iterator\
    \ it19;\n    std::string::iterator it20;\n    std::string::iterator it21;\n  \
    \  std::string::iterator it22;\n    std::string::iterator it23;\n    std::string::iterator\
    \ it24;\n    std::string::iterator it25;\n    std::string::iterator it26;\n  \
    \  std::string::iterator it27;\n    std::string::iterator it28;\n    std::string::iterator\
    \ it29;\n    std::string::iterator it30;\n    std::string::iterator it31;\n  \
    \  std::string::iterator it32;\n    std::string::iterator it33;\n    std::string::iterator\
    \ it34;\n    std::string::iterator it35;\n    std::string::iterator it36;\n  \
    \  std::string::iterator it37;\n    std::string::iterator it38;\n    std::string::iterator\
    \ it39;\n    std::string::iterator it40;\n    std::string::iterator it41;\n  \
    \  std::string::iterator it42;\n    std::string::iterator it43;\n    std::string::iterator\
    \ it44;\n", "    std::string result = string;\n    std::string::iterator it =\
    \ string.begin();\n    std::string::iterator it_end = string.end();\n    std::string::iterator\
    \ it_rev = string.rbegin();\n    while (it != it_end) {\n        if (std::equal(it,\
    \ it_end, it_rev)) {\n            break;\n        }\n        ++it;\n        ++it_rev;\n\
    \    }\n    std::string prefix(it, it_end);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    result += prefix;\n    return result;", "    std::string\
    \ result = string;\n    std::string reverse = string;\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    int n = string.size();\n    int i = 0;\n    while (i <\
    \ n) {\n        if (string.substr(i) == reverse.substr(0, n - i)) {\n        \
    \    break;\n        }\n        i++;\n    }\n    result.append(reverse.substr(n\
    \ - i));\n    return result;", "    // Find the longest palindromic suffix.\n\
    \    std::string suffix = \"\";\n    for (int i = string.size() - 1; i >= 0; --i)\
    \ {\n        if (string.substr(0, i) == std::string(string.substr(i).rbegin(),\
    \ string.substr(i).rend())) {\n            suffix = string.substr(i);\n      \
    \      break;\n        }\n    }\n    // Append the reverse of the prefix to the\
    \ end of the string.\n    return string + std::string(suffix.rbegin(), suffix.rend());",
  "    std::string result = string;\n    int i = 0;\n    int j = string.size() - 1;\n\
    \    while (i < j) {\n        if (string[i] == string[j]) {\n            i++;\n\
    \            j--;\n        } else {\n            i = 0;\n            j--;\n  \
    \      }\n    }\n    std::string prefix = string.substr(0, i);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    result += prefix;\n    return result;", "    if (string.size()\
    \ == 0) {\n        return string;\n    }\n    std::string reversed_string = string;\n\
    \    std::reverse(reversed_string.begin(), reversed_string.end());\n    std::string\
    \ concatenated_string = string + reversed_string;\n    std::vector<int> prefix_function\
    \ = prefix_function_of(concatenated_string);\n    int longest_palindromic_suffix_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - longest_palindromic_suffix_length);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "    std::string result = string;\n    std::string\
    \ reverse = string;\n    std::reverse(reverse.begin(), reverse.end());\n    int\
    \ n = string.size();\n    int i = 0;\n    while (i < n) {\n        if (string.substr(i)\
    \ == reverse.substr(0, n - i)) {\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    result.append(reverse.substr(n - i));\n    return result;", " \
    \   std::string reverse_string = string;\n    std::reverse(reverse_string.begin(),\
    \ reverse_string.end());\n    std::string concatenated_string = string + \"#\"\
    \ + reverse_string;\n    std::vector<int> prefix_function = prefix_function_kmp(concatenated_string);\n\
    \    int palindrome_length = prefix_function.back();\n    std::string prefix =\
    \ string.substr(0, string.size() - palindrome_length);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "  std::string result;\n  std::string\
    \ reversed = string;\n  std::reverse(reversed.begin(), reversed.end());\n  std::string\
    \ combined = string + reversed;\n  std::vector<int> prefix_function(combined.size());\n\
    \  int longest_palindrome_length = 0;\n  for (int i = 1; i < combined.size();\
    \ ++i) {\n    int j = prefix_function[i - 1];\n    while (j > 0 && combined[i]\
    \ != combined[j]) {\n      j = prefix_function[j - 1];\n    }\n    if (combined[i]\
    \ == combined[j]) {\n      ++j;\n    }\n    prefix_function[i] = j;\n    if (i\
    \ + 1 == combined.size() || j == string.size()) {\n      longest_palindrome_length\
    \ = j;\n    }\n  }\n  result = string + reversed.substr(longest_palindrome_length);\n\
    \  return result;", "    std::string result = string;\n    std::string reversed_prefix\
    \ = string;\n    std::reverse(reversed_prefix.begin(), reversed_prefix.end());\n\
    \    std::string::size_type suffix_length = 0;\n    for (std::string::size_type\
    \ i = 0; i < string.size(); ++i) {\n        if (string.substr(i) == reversed_prefix.substr(0,\
    \ string.size() - i)) {\n            suffix_length = string.size() - i;\n    \
    \        break;\n        }\n    }\n    result += reversed_prefix.substr(suffix_length);\n\
    \    return result;", "    std::string result;\n    int length = string.length();\n\
    \    if (length == 0) {\n        return result;\n    }\n    int i = 0;\n    int\
    \ j = length - 1;\n    while (i < j) {\n        if (string[i] == string[j]) {\n\
    \            i++;\n            j--;\n        } else {\n            break;\n  \
    \      }\n    }\n    if (i >= j) {\n        return string;\n    }\n    int k =\
    \ i;\n    while (k < length) {\n        result.push_back(string[k]);\n       \
    \ k++;\n    }\n    for (int i = 0; i < k; i++) {\n        result.push_back(string[i]);\n\
    \    }\n    return result;", "    std::string result = string;\n    std::string::size_type\
    \ i = 0;\n    std::string::size_type j = string.size() - 1;\n    while (i < j)\
    \ {\n        if (string[i] == string[j]) {\n            ++i;\n            --j;\n\
    \        } else {\n            i = 0;\n            --j;\n        }\n    }\n  \
    \  std::string prefix = string.substr(0, i);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    result += prefix;\n    return result;", "    std::string\
    \ reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\
    \    std::string concatenated_string = string + reversed_string;\n    std::vector<int>\
    \ prefix_function = prefix_function_kmp(concatenated_string);\n    int longest_palindromic_suffix_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - longest_palindromic_suffix_length);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "    std::string rev_string = string;\n    std::reverse(rev_string.begin(),\
    \ rev_string.end());\n    std::string rev_string_prefix = rev_string.substr(0,\
    \ string.size());\n    std::string rev_string_suffix = rev_string.substr(string.size());\n\
    \    std::string string_suffix = string.substr(0, string.size());\n    std::string\
    \ string_prefix = string.substr(string.size());\n    std::string palindrome =\
    \ string_suffix + rev_string_prefix;\n    std::string palindrome_rev = rev_string_suffix\
    \ + string_prefix;\n    return palindrome.size() < palindrome_rev.size() ? palindrome\
    \ : palindrome_rev;", "    std::string result = string;\n    std::string reverse\
    \ = string;\n    std::reverse(reverse.begin(), reverse.end());\n    std::string::size_type\
    \ i = string.find(reverse);\n    if (i != std::string::npos) {\n        result\
    \ = string + reverse.substr(reverse.size() - i);\n    }\n    return result;",
  "    std::string result;\n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    int palindrome_end = string.size();\n    for (int i =\
    \ string.size() - 1; i >= 0; --i) {\n        if (string[i] == string[palindrome_end\
    \ - 1]) {\n            --palindrome_end;\n        }\n    }\n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    result = string;\n    for (int i = palindrome_end - 1; i >= 0;\
    \ --i) {\n        result += string[i];\n    }\n    return result;", "    std::string\
    \ reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\
    \    std::string concatenated_string = string + reversed_string;\n    std::vector<int>\
    \ prefix_function = prefix_function_kmp(concatenated_string);\n    int longest_palindromic_suffix_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - longest_palindromic_suffix_length);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "    std::string reversed_string = string;\n  \
    \  std::reverse(reversed_string.begin(), reversed_string.end());\n    std::string\
    \ concatenated_string = string + \"#\" + reversed_string;\n    std::vector<int>\
    \ prefix_function = prefix_function_kmp(concatenated_string);\n    int palindrome_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - palindrome_length);\n    std::reverse(prefix.begin(), prefix.end());\n   \
    \ return string + prefix;"]
stop_tokens:
- "\n}"
