language: cpp
name: HumanEval_125_split_words
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        char c\
    \ = txt[i];\n        if (c >= 'a' && c <= 'z') {\n            if (i % 2 == 0)\
    \ {\n                count++;\n            }\n        }\n    }\n    return Union_std_vector_std_string__long(count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt6n6460c.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpt6n6460c.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpt6n6460c.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpt6n6460c.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpt6n6460c.cpp:\
    \ In function 'int main()':\n/tmp/tmpt6n6460c.cpp:54:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt6n6460c.cpp:2:\n/tmp/tmpt6n6460c.cpp:55:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpt6n6460c.cpp:55:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpt6n6460c.cpp:55:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpt6n6460c.cpp:55:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yvpk097.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp7yvpk097.cpp:\
    \ In function 'int main()':\n/tmp/tmp7yvpk097.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yvpk097.cpp:2:\n/tmp/tmp7yvpk097.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp7yvpk097.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp7yvpk097.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp7yvpk097.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyt_xi2xy.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpyt_xi2xy.cpp:\
    \ In function 'int main()':\n/tmp/tmpyt_xi2xy.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyt_xi2xy.cpp:2:\n/tmp/tmpyt_xi2xy.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpyt_xi2xy.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpyt_xi2xy.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpyt_xi2xy.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        long count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpttjxfl4g.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpttjxfl4g.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpttjxfl4g.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpttjxfl4g.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpttjxfl4g.cpp:\
    \ In function 'int main()':\n/tmp/tmpttjxfl4g.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpttjxfl4g.cpp:2:\n/tmp/tmpttjxfl4g.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpttjxfl4g.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpttjxfl4g.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpttjxfl4g.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yvpk097.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp7yvpk097.cpp:\
    \ In function 'int main()':\n/tmp/tmp7yvpk097.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yvpk097.cpp:2:\n/tmp/tmp7yvpk097.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp7yvpk097.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp7yvpk097.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp7yvpk097.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return words;\n    } else if (txt.find(',') != std::string::npos) {\n  \
    \      std::vector<std::string> words;\n        std::stringstream ss(txt);\n \
    \       std::string word;\n        while (std::getline(ss, word, ',')) {\n   \
    \         words.push_back(word);\n        }\n        return words;\n    } else\
    \ {\n        int count = 0;\n        for (int i = 0; i < txt.size(); i++) {\n\
    \            if (txt[i] - 'a' % 2 == 1) {\n                count++;\n        \
    \    }\n        }\n        return count;\n    }\n}\nint main() {\n    auto candidate\
    \ = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp80scuccf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp80scuccf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp80scuccf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp80scuccf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp80scuccf.cpp:\
    \ In function 'int main()':\n/tmp/tmp80scuccf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp80scuccf.cpp:2:\n/tmp/tmp80scuccf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp80scuccf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp80scuccf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp80scuccf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yvpk097.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp7yvpk097.cpp:\
    \ In function 'int main()':\n/tmp/tmp7yvpk097.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yvpk097.cpp:2:\n/tmp/tmp7yvpk097.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp7yvpk097.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp7yvpk097.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp7yvpk097.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() == 0) {\n        std::stringstream ss(txt);\n        std::string\
    \ word;\n        while (std::getline(ss, word, ',')) {\n            v.push_back(word);\n\
    \        }\n        if (v.size() == 0) {\n            int count = 0;\n       \
    \     for (int i = 0; i < txt.size(); i++) {\n                if (txt[i] >= 'a'\
    \ && txt[i] <= 'z') {\n                    if (i % 2 == 0) {\n               \
    \         count++;\n                    }\n                }\n            }\n\
    \            return Union_std_vector_std_string__long(count);\n        }\n   \
    \ }\n    return Union_std_vector_std_string__long(v);\n}\nint main() {\n    auto\
    \ candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphs6914vy.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmphs6914vy.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmphs6914vy.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmphs6914vy.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmphs6914vy.cpp:\
    \ In function 'int main()':\n/tmp/tmphs6914vy.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphs6914vy.cpp:2:\n/tmp/tmphs6914vy.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmphs6914vy.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmphs6914vy.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmphs6914vy.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ v;\n        std::stringstream ss(txt);\n        std::string word;\n        while\
    \ (ss >> word) {\n            v.push_back(word);\n        }\n        return v;\n\
    \    } else if (txt.find(\",\") != std::string::npos) {\n        std::vector<std::string>\
    \ v;\n        std::stringstream ss(txt);\n        std::string word;\n        while\
    \ (std::getline(ss, word, ',')) {\n            v.push_back(word);\n        }\n\
    \        return v;\n    } else {\n        int count = 0;\n        for (int i =\
    \ 0; i < txt.length(); i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z'\
    \ && i % 2 == 0) {\n                count++;\n            }\n        }\n     \
    \   return count;\n    }\n}\nint main() {\n    auto candidate = split_words;\n\
    \    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7umzr0cc.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp7umzr0cc.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp7umzr0cc.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp7umzr0cc.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp7umzr0cc.cpp:\
    \ In function 'int main()':\n/tmp/tmp7umzr0cc.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7umzr0cc.cpp:2:\n/tmp/tmp7umzr0cc.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp7umzr0cc.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp7umzr0cc.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp7umzr0cc.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::stringstream\
    \ stream(txt);\n    while (stream >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream stream2(txt);\n    while (std::getline(stream2,\
    \ word, ',')) {\n        words.push_back(word);\n    }\n    if (words.size() >\
    \ 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n    int\
    \ count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >=\
    \ 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n   \
    \ }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n \
    \   auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppvo2qk28.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmppvo2qk28.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmppvo2qk28.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmppvo2qk28.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmppvo2qk28.cpp:\
    \ In function 'int main()':\n/tmp/tmppvo2qk28.cpp:50:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvo2qk28.cpp:2:\n/tmp/tmppvo2qk28.cpp:51:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmppvo2qk28.cpp:51:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmppvo2qk28.cpp:51:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmppvo2qk28.cpp:51:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> commas;\n    std::stringstream ss2(txt);\n\
    \    std::string comma;\n    while (std::getline(ss2, comma, ',')) {\n       \
    \ commas.push_back(comma);\n    }\n    if (commas.size() > 0) {\n        return\
    \ Union_std_vector_std_string__long(commas);\n    }\n    int count = 0;\n    for\
    \ (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i] <= 'z'\
    \ && i % 2 == 0) {\n            count++;\n        }\n    }\n    return Union_std_vector_std_string__long(count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn81xjg7i.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpn81xjg7i.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpn81xjg7i.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpn81xjg7i.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpn81xjg7i.cpp:\
    \ In function 'int main()':\n/tmp/tmpn81xjg7i.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn81xjg7i.cpp:2:\n/tmp/tmpn81xjg7i.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpn81xjg7i.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpn81xjg7i.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpn81xjg7i.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    std::vector<std::string>\
    \ commas;\n    std::stringstream ss2(txt);\n    std::string comma;\n    while\
    \ (std::getline(ss2, comma, ',')) {\n        commas.push_back(comma);\n    }\n\
    \    if (commas.size() > 0) {\n        return commas;\n    }\n    long count =\
    \ 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' &&\
    \ txt[i] <= 'z') {\n            if (i % 2 == 0) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto\
    \ candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt3wry0bt.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpt3wry0bt.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpt3wry0bt.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpt3wry0bt.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpt3wry0bt.cpp:\
    \ In function 'int main()':\n/tmp/tmpt3wry0bt.cpp:54:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt3wry0bt.cpp:2:\n/tmp/tmpt3wry0bt.cpp:55:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpt3wry0bt.cpp:55:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpt3wry0bt.cpp:55:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpt3wry0bt.cpp:55:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if(txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while(ss >> word) {\n            words.push_back(word);\n        }\n    \
    \    return words;\n    }\n    else if(txt.find(',') != std::string::npos) {\n\
    \        std::vector<std::string> words;\n        std::stringstream ss(txt);\n\
    \        std::string word;\n        while(std::getline(ss, word, ',')) {\n   \
    \         words.push_back(word);\n        }\n        return words;\n    }\n  \
    \  else {\n        int count = 0;\n        for(int i = 0; i < txt.size(); i++)\
    \ {\n            if(txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n        \
    \        count++;\n            }\n        }\n        return count;\n    }\n}\n\
    int main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvs0c1yxt.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpvs0c1yxt.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpvs0c1yxt.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpvs0c1yxt.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpvs0c1yxt.cpp:\
    \ In function 'int main()':\n/tmp/tmpvs0c1yxt.cpp:54:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvs0c1yxt.cpp:2:\n/tmp/tmpvs0c1yxt.cpp:55:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpvs0c1yxt.cpp:55:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpvs0c1yxt.cpp:55:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpvs0c1yxt.cpp:55:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpapf5q5l1.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpapf5q5l1.cpp:\
    \ In function 'int main()':\n/tmp/tmpapf5q5l1.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpapf5q5l1.cpp:2:\n/tmp/tmpapf5q5l1.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpapf5q5l1.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpapf5q5l1.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpapf5q5l1.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpikigj3ju.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpikigj3ju.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpikigj3ju.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpikigj3ju.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpikigj3ju.cpp:\
    \ In function 'int main()':\n/tmp/tmpikigj3ju.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpikigj3ju.cpp:2:\n/tmp/tmpikigj3ju.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpikigj3ju.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpikigj3ju.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpikigj3ju.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> commas;\n    std::stringstream ss2(txt);\n\
    \    std::string comma;\n    while (std::getline(ss2, comma, ',')) {\n       \
    \ commas.push_back(comma);\n    }\n    if (commas.size() > 0) {\n        return\
    \ Union_std_vector_std_string__long(commas);\n    }\n    int count = 0;\n    for\
    \ (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i] <= 'z'\
    \ && i % 2 == 0) {\n            count++;\n        }\n    }\n    return Union_std_vector_std_string__long(count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn81xjg7i.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpn81xjg7i.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpn81xjg7i.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpn81xjg7i.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpn81xjg7i.cpp:\
    \ In function 'int main()':\n/tmp/tmpn81xjg7i.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn81xjg7i.cpp:2:\n/tmp/tmpn81xjg7i.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpn81xjg7i.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpn81xjg7i.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpn81xjg7i.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words = std::vector<std::string>();\n \
    \   std::string word = \"\";\n    for (int i = 0; i < txt.size(); i++) {\n   \
    \     if (txt[i] == ' ') {\n            words.push_back(word);\n            word\
    \ = \"\";\n        } else if (txt[i] == ',') {\n            words.push_back(word);\n\
    \            word = \"\";\n            break;\n        } else {\n            word\
    \ += txt[i];\n        }\n    }\n    if (word != \"\") {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n     \
    \   if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n   \
    \             count++;\n            }\n        }\n    }\n    return Union_std_vector_std_string__long(count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3flajlsg.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp3flajlsg.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp3flajlsg.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp3flajlsg.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp3flajlsg.cpp:\
    \ In function 'int main()':\n/tmp/tmp3flajlsg.cpp:56:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3flajlsg.cpp:2:\n/tmp/tmp3flajlsg.cpp:57:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp3flajlsg.cpp:57:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp3flajlsg.cpp:57:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp3flajlsg.cpp:57:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string temp;\n    while (ss >> temp)\n        v.push_back(temp);\n   \
    \ if (v.size() > 0)\n        return v;\n    std::stringstream ss2(txt);\n    std::string\
    \ temp2;\n    while (std::getline(ss2, temp2, ','))\n        v.push_back(temp2);\n\
    \    if (v.size() > 0)\n        return v;\n    int count = 0;\n    for (int i\
    \ = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i] <= 'z') {\n\
    \            if (i % 2 == 0)\n                count++;\n        }\n    }\n   \
    \ return count;\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph9do3ygm.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmph9do3ygm.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmph9do3ygm.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmph9do3ygm.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmph9do3ygm.cpp:\
    \ In function 'int main()':\n/tmp/tmph9do3ygm.cpp:48:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph9do3ygm.cpp:2:\n/tmp/tmph9do3ygm.cpp:49:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmph9do3ygm.cpp:49:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmph9do3ygm.cpp:49:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmph9do3ygm.cpp:49:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::istringstream\
    \ iss(txt);\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\
    \    if (words.size() > 0) {\n        return words;\n    }\n    std::vector<std::string>\
    \ commas;\n    std::istringstream iss2(txt);\n    while (std::getline(iss2, word,\
    \ ',')) {\n        commas.push_back(word);\n    }\n    if (commas.size() > 0)\
    \ {\n        return commas;\n    }\n    long count = 0;\n    for (int i = 0; i\
    \ < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i] <= 'z') {\n      \
    \      if (i % 2 == 0) {\n                count++;\n            }\n        }\n\
    \    }\n    return count;\n}\nint main() {\n    auto candidate = split_words;\n\
    \    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsy_6cydg.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsy_6cydg.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsy_6cydg.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsy_6cydg.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsy_6cydg.cpp:\
    \ In function 'int main()':\n/tmp/tmpsy_6cydg.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsy_6cydg.cpp:2:\n/tmp/tmpsy_6cydg.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsy_6cydg.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsy_6cydg.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsy_6cydg.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyt_xi2xy.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpyt_xi2xy.cpp:\
    \ In function 'int main()':\n/tmp/tmpyt_xi2xy.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyt_xi2xy.cpp:2:\n/tmp/tmpyt_xi2xy.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpyt_xi2xy.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpyt_xi2xy.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpyt_xi2xy.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words = std::vector<std::string>();\n        std::stringstream ss(txt);\n  \
    \      std::string word;\n        while (ss >> word) {\n            words.push_back(word);\n\
    \        }\n        return Union_std_vector_std_string__long(words);\n    } else\
    \ if (txt.find(\",\") != std::string::npos) {\n        std::vector<std::string>\
    \ words = std::vector<std::string>();\n        std::stringstream ss(txt);\n  \
    \      std::string word;\n        while (std::getline(ss, word, ',')) {\n    \
    \        words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.length();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpum4x5tag.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpum4x5tag.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpum4x5tag.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpum4x5tag.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpum4x5tag.cpp:\
    \ In function 'int main()':\n/tmp/tmpum4x5tag.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpum4x5tag.cpp:2:\n/tmp/tmpum4x5tag.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpum4x5tag.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpum4x5tag.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpum4x5tag.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> words_comma;\n    std::stringstream ss_comma(txt);\n\
    \    std::string word_comma;\n    while (std::getline(ss_comma, word_comma, ','))\
    \ {\n        words_comma.push_back(word_comma);\n    }\n    if (words_comma.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words_comma);\n   \
    \ }\n    long odd_count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n   \
    \     if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n \
    \               odd_count++;\n            }\n        }\n    }\n    return Union_std_vector_std_string__long(odd_count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsobp12do.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsobp12do.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsobp12do.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsobp12do.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsobp12do.cpp:\
    \ In function 'int main()':\n/tmp/tmpsobp12do.cpp:54:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsobp12do.cpp:2:\n/tmp/tmpsobp12do.cpp:55:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsobp12do.cpp:55:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsobp12do.cpp:55:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsobp12do.cpp:55:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> words2;\n    std::stringstream ss2(txt);\n\
    \    std::string word2;\n    while (std::getline(ss2, word2, ',')) {\n       \
    \ words2.push_back(word2);\n    }\n    if (words2.size() > 0) {\n        return\
    \ Union_std_vector_std_string__long(words2);\n    }\n    long count = 0;\n   \
    \ for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i]\
    \ <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n    return\
    \ Union_std_vector_std_string__long(count);\n}\nint main() {\n    auto candidate\
    \ = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0v9xhorw.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp0v9xhorw.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp0v9xhorw.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp0v9xhorw.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp0v9xhorw.cpp:\
    \ In function 'int main()':\n/tmp/tmp0v9xhorw.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0v9xhorw.cpp:2:\n/tmp/tmp0v9xhorw.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp0v9xhorw.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp0v9xhorw.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp0v9xhorw.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] - 'a' >= 0 && txt[i] - 'a' < 26) {\n         \
    \           if ((txt[i] - 'a') % 2 == 1) {\n                        count++;\n\
    \                    }\n                }\n            }\n            return count;\n\
    \        }\n    }\n    return words;\n}\nint main() {\n    auto candidate = split_words;\n\
    \    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp72y7icwf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp72y7icwf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp72y7icwf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp72y7icwf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp72y7icwf.cpp:\
    \ In function 'int main()':\n/tmp/tmp72y7icwf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp72y7icwf.cpp:2:\n/tmp/tmp72y7icwf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp72y7icwf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp72y7icwf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp72y7icwf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (txt[i] - 'a') % 2 == 1) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7wc6wyr.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_7wc6wyr.cpp:\
    \ In function 'int main()':\n/tmp/tmp_7wc6wyr.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_7wc6wyr.cpp:2:\n/tmp/tmp_7wc6wyr.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_7wc6wyr.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_7wc6wyr.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_7wc6wyr.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() > 0) {\n        return Union_std_vector_std_string__long(v);\n\
    \    }\n    std::stringstream ss1(txt);\n    std::string word1;\n    while (std::getline(ss1,\
    \ word1, ',')) {\n        v.push_back(word1);\n    }\n    if (v.size() > 0) {\n\
    \        return Union_std_vector_std_string__long(v);\n    }\n    int count =\
    \ 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' &&\
    \ txt[i] <= 'z') {\n            if (i % 2 == 0) {\n                count++;\n\
    \            }\n        }\n    }\n    return Union_std_vector_std_string__long(count);\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_w4skkeu.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_w4skkeu.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_w4skkeu.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_w4skkeu.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_w4skkeu.cpp:\
    \ In function 'int main()':\n/tmp/tmp_w4skkeu.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_w4skkeu.cpp:2:\n/tmp/tmp_w4skkeu.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_w4skkeu.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_w4skkeu.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_w4skkeu.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (txt[i] - 'a') % 2 == 1) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7wc6wyr.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_7wc6wyr.cpp:\
    \ In function 'int main()':\n/tmp/tmp_7wc6wyr.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_7wc6wyr.cpp:2:\n/tmp/tmp_7wc6wyr.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_7wc6wyr.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_7wc6wyr.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_7wc6wyr.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(\"\
    ,\") != std::string::npos) {\n        std::vector<std::string> words;\n      \
    \  std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss,\
    \ word, ',')) {\n            words.push_back(word);\n        }\n        return\
    \ Union_std_vector_std_string__long(words);\n    } else {\n        long count\
    \ = 0;\n        for (int i = 0; i < txt.size(); i++) {\n            if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n                count++;\n       \
    \     }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpovenio5k.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpovenio5k.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpovenio5k.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpovenio5k.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpovenio5k.cpp:\
    \ In function 'int main()':\n/tmp/tmpovenio5k.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpovenio5k.cpp:2:\n/tmp/tmpovenio5k.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpovenio5k.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpovenio5k.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpovenio5k.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphago1vfs.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmphago1vfs.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmphago1vfs.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmphago1vfs.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmphago1vfs.cpp:\
    \ In function 'int main()':\n/tmp/tmphago1vfs.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphago1vfs.cpp:2:\n/tmp/tmphago1vfs.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmphago1vfs.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmphago1vfs.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmphago1vfs.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() > 0) {\n        return v;\n    }\n    std::stringstream\
    \ ss1(txt);\n    std::string word1;\n    while (std::getline(ss1, word1, ','))\
    \ {\n        v.push_back(word1);\n    }\n    if (v.size() > 0) {\n        return\
    \ v;\n    }\n    long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n\
    \        if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy4vxm0ei.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpy4vxm0ei.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpy4vxm0ei.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpy4vxm0ei.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpy4vxm0ei.cpp:\
    \ In function 'int main()':\n/tmp/tmpy4vxm0ei.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy4vxm0ei.cpp:2:\n/tmp/tmpy4vxm0ei.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpy4vxm0ei.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpy4vxm0ei.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpy4vxm0ei.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> words2;\n    std::stringstream ss2(txt);\n\
    \    std::string word2;\n    while (std::getline(ss2, word2, ',')) {\n       \
    \ words2.push_back(word2);\n    }\n    if (words2.size() > 0) {\n        return\
    \ Union_std_vector_std_string__long(words2);\n    }\n    long count = 0;\n   \
    \ for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i]\
    \ <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n    return\
    \ Union_std_vector_std_string__long(count);\n}\nint main() {\n    auto candidate\
    \ = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0v9xhorw.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp0v9xhorw.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp0v9xhorw.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp0v9xhorw.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp0v9xhorw.cpp:\
    \ In function 'int main()':\n/tmp/tmp0v9xhorw.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0v9xhorw.cpp:2:\n/tmp/tmp0v9xhorw.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp0v9xhorw.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp0v9xhorw.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp0v9xhorw.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(\"\
    ,\") != std::string::npos) {\n        std::vector<std::string> words;\n      \
    \  std::stringstream ss(txt);\n        std::string word;\n        while (getline(ss,\
    \ word, ',')) {\n            words.push_back(word);\n        }\n        return\
    \ Union_std_vector_std_string__long(words);\n    } else {\n        int count =\
    \ 0;\n        for (int i = 0; i < txt.size(); i++) {\n            if (txt[i] -\
    \ 'a' % 2 == 1) {\n                count++;\n            }\n        }\n      \
    \  return Union_std_vector_std_string__long(count);\n    }\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjwxjdodb.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpjwxjdodb.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpjwxjdodb.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpjwxjdodb.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpjwxjdodb.cpp:\
    \ In function 'int main()':\n/tmp/tmpjwxjdodb.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwxjdodb.cpp:2:\n/tmp/tmpjwxjdodb.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpjwxjdodb.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpjwxjdodb.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpjwxjdodb.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (txt[i] - 'a') % 2 == 1) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7wc6wyr.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_7wc6wyr.cpp:\
    \ In function 'int main()':\n/tmp/tmp_7wc6wyr.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_7wc6wyr.cpp:2:\n/tmp/tmp_7wc6wyr.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_7wc6wyr.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_7wc6wyr.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_7wc6wyr.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() > 0) {\n        return v;\n    }\n    std::stringstream\
    \ ss2(txt);\n    std::string word2;\n    while (std::getline(ss2, word2, ','))\
    \ {\n        v.push_back(word2);\n    }\n    if (v.size() > 0) {\n        return\
    \ v;\n    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n\
    \        if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps4p5wsk1.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmps4p5wsk1.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmps4p5wsk1.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmps4p5wsk1.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmps4p5wsk1.cpp:\
    \ In function 'int main()':\n/tmp/tmps4p5wsk1.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps4p5wsk1.cpp:2:\n/tmp/tmps4p5wsk1.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmps4p5wsk1.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmps4p5wsk1.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmps4p5wsk1.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::stringstream\
    \ stream(txt);\n    while (stream >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    std::stringstream\
    \ stream2(txt);\n    while (std::getline(stream2, word, ',')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    int count\
    \ = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a'\
    \ && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_wu93435.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_wu93435.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_wu93435.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_wu93435.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_wu93435.cpp:\
    \ In function 'int main()':\n/tmp/tmp_wu93435.cpp:50:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_wu93435.cpp:2:\n/tmp/tmp_wu93435.cpp:51:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_wu93435.cpp:51:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_wu93435.cpp:51:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_wu93435.cpp:51:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() > 0) {\n        return v;\n    }\n    std::stringstream\
    \ ss2(txt);\n    std::string word2;\n    while (std::getline(ss2, word2, ','))\
    \ {\n        v.push_back(word2);\n    }\n    if (v.size() > 0) {\n        return\
    \ v;\n    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n\
    \        if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps4p5wsk1.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmps4p5wsk1.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmps4p5wsk1.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmps4p5wsk1.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmps4p5wsk1.cpp:\
    \ In function 'int main()':\n/tmp/tmps4p5wsk1.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps4p5wsk1.cpp:2:\n/tmp/tmps4p5wsk1.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmps4p5wsk1.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmps4p5wsk1.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmps4p5wsk1.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    std::vector<std::string>\
    \ commas;\n    std::stringstream ss2(txt);\n    std::string comma;\n    while\
    \ (std::getline(ss2, comma, ',')) {\n        commas.push_back(comma);\n    }\n\
    \    if (commas.size() > 0) {\n        return commas;\n    }\n    int count =\
    \ 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' &&\
    \ txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxsms0vor.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpxsms0vor.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpxsms0vor.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpxsms0vor.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpxsms0vor.cpp:\
    \ In function 'int main()':\n/tmp/tmpxsms0vor.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxsms0vor.cpp:2:\n/tmp/tmpxsms0vor.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpxsms0vor.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpxsms0vor.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpxsms0vor.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(\"\
    ,\") != std::string::npos) {\n        std::vector<std::string> words;\n      \
    \  std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss,\
    \ word, ',')) {\n            words.push_back(word);\n        }\n        return\
    \ Union_std_vector_std_string__long(words);\n    } else {\n        int count =\
    \ 0;\n        for (int i = 0; i < txt.size(); i++) {\n            if (txt[i] -\
    \ 'a' < 26 && txt[i] - 'a' >= 0 && (txt[i] - 'a') % 2 == 1) {\n              \
    \  count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpez7u28xs.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpez7u28xs.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpez7u28xs.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpez7u28xs.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpez7u28xs.cpp:\
    \ In function 'int main()':\n/tmp/tmpez7u28xs.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpez7u28xs.cpp:2:\n/tmp/tmpez7u28xs.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpez7u28xs.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpez7u28xs.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpez7u28xs.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyt_xi2xy.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpyt_xi2xy.cpp:\
    \ In function 'int main()':\n/tmp/tmpyt_xi2xy.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyt_xi2xy.cpp:2:\n/tmp/tmpyt_xi2xy.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpyt_xi2xy.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpyt_xi2xy.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpyt_xi2xy.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphago1vfs.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmphago1vfs.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmphago1vfs.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmphago1vfs.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmphago1vfs.cpp:\
    \ In function 'int main()':\n/tmp/tmphago1vfs.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphago1vfs.cpp:2:\n/tmp/tmphago1vfs.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmphago1vfs.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmphago1vfs.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmphago1vfs.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> v;\n    std::stringstream ss(txt);\n  \
    \  std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n \
    \   }\n    if (v.size() != 0) {\n        return v;\n    }\n    std::stringstream\
    \ ss2(txt);\n    std::string word2;\n    while (std::getline(ss2, word2, ','))\
    \ {\n        v.push_back(word2);\n    }\n    if (v.size() != 0) {\n        return\
    \ v;\n    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n\
    \        if (txt[i] >= 'a' && txt[i] <= 'z') {\n            if (i % 2 == 0) {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprfff0syq.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmprfff0syq.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmprfff0syq.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmprfff0syq.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmprfff0syq.cpp:\
    \ In function 'int main()':\n/tmp/tmprfff0syq.cpp:53:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprfff0syq.cpp:2:\n/tmp/tmprfff0syq.cpp:54:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmprfff0syq.cpp:54:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmprfff0syq.cpp:54:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmprfff0syq.cpp:54:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsg4tt4bf.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpsg4tt4bf.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpsg4tt4bf.cpp:\
    \ In function 'int main()':\n/tmp/tmpsg4tt4bf.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsg4tt4bf.cpp:2:\n/tmp/tmpsg4tt4bf.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpsg4tt4bf.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpsg4tt4bf.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpsg4tt4bf.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',')\
    \ != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream\
    \ ss(txt);\n        std::string word;\n        while (getline(ss, word, ','))\
    \ {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    } else {\n        int count = 0;\n        for (int i = 0; i < txt.size();\
    \ i++) {\n            if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n  \
    \              count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n\
    \    }\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg_sobh4o.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpg_sobh4o.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpg_sobh4o.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpg_sobh4o.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpg_sobh4o.cpp:\
    \ In function 'int main()':\n/tmp/tmpg_sobh4o.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg_sobh4o.cpp:2:\n/tmp/tmpg_sobh4o.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpg_sobh4o.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpg_sobh4o.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpg_sobh4o.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyt_xi2xy.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpyt_xi2xy.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpyt_xi2xy.cpp:\
    \ In function 'int main()':\n/tmp/tmpyt_xi2xy.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyt_xi2xy.cpp:2:\n/tmp/tmpyt_xi2xy.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpyt_xi2xy.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpyt_xi2xy.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpyt_xi2xy.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (txt[i] - 'a') % 2 == 1) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7wc6wyr.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_7wc6wyr.cpp:\
    \ In function 'int main()':\n/tmp/tmp_7wc6wyr.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_7wc6wyr.cpp:2:\n/tmp/tmp_7wc6wyr.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_7wc6wyr.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_7wc6wyr.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_7wc6wyr.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::vector<std::string> commas;\n    std::stringstream ss2(txt);\n\
    \    std::string comma;\n    while (std::getline(ss2, comma, ',')) {\n       \
    \ commas.push_back(comma);\n    }\n    if (commas.size() > 0) {\n        return\
    \ Union_std_vector_std_string__long(commas);\n    }\n    long count = 0;\n   \
    \ for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i]\
    \ <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n    return\
    \ Union_std_vector_std_string__long(count);\n}\nint main() {\n    auto candidate\
    \ = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\"))\
    \ == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world\
    \ !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"\
    !\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\"\
    )) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\"\
    )) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbivqiatt.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpbivqiatt.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpbivqiatt.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpbivqiatt.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpbivqiatt.cpp:\
    \ In function 'int main()':\n/tmp/tmpbivqiatt.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbivqiatt.cpp:2:\n/tmp/tmpbivqiatt.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpbivqiatt.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpbivqiatt.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpbivqiatt.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::stringstream ss(txt);\n    std::string word;\n    std::vector<std::string>\
    \ words;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    std::vector<std::string>\
    \ words2;\n    while (std::getline(ss2, word2, ',')) {\n        words2.push_back(word2);\n\
    \    }\n    if (words2.size() > 0) {\n        return Union_std_vector_std_string__long(words2);\n\
    \    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n     \
    \   if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppc3ncfd0.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmppc3ncfd0.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmppc3ncfd0.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmppc3ncfd0.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmppc3ncfd0.cpp:\
    \ In function 'int main()':\n/tmp/tmppc3ncfd0.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppc3ncfd0.cpp:2:\n/tmp/tmppc3ncfd0.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmppc3ncfd0.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmppc3ncfd0.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmppc3ncfd0.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words = std::vector<std::string>();\n        std::stringstream ss(txt);\n  \
    \      std::string word;\n        while (ss >> word) {\n            words.push_back(word);\n\
    \        }\n        return Union_std_vector_std_string__long(words);\n    }\n\
    \    if (txt.find(\",\") != std::string::npos) {\n        std::vector<std::string>\
    \ words = std::vector<std::string>();\n        std::stringstream ss(txt);\n  \
    \      std::string word;\n        while (std::getline(ss, word, ',')) {\n    \
    \        words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n    \
    \    if (txt[i] >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpys5kfz1v.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpys5kfz1v.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpys5kfz1v.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpys5kfz1v.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpys5kfz1v.cpp:\
    \ In function 'int main()':\n/tmp/tmpys5kfz1v.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpys5kfz1v.cpp:2:\n/tmp/tmpys5kfz1v.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpys5kfz1v.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpys5kfz1v.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpys5kfz1v.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpapf5q5l1.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpapf5q5l1.cpp:\
    \ In function 'int main()':\n/tmp/tmpapf5q5l1.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpapf5q5l1.cpp:2:\n/tmp/tmpapf5q5l1.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpapf5q5l1.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpapf5q5l1.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpapf5q5l1.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphago1vfs.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmphago1vfs.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmphago1vfs.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmphago1vfs.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmphago1vfs.cpp:\
    \ In function 'int main()':\n/tmp/tmphago1vfs.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphago1vfs.cpp:2:\n/tmp/tmphago1vfs.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmphago1vfs.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmphago1vfs.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmphago1vfs.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphago1vfs.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmphago1vfs.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmphago1vfs.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmphago1vfs.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmphago1vfs.cpp:\
    \ In function 'int main()':\n/tmp/tmphago1vfs.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphago1vfs.cpp:2:\n/tmp/tmphago1vfs.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmphago1vfs.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmphago1vfs.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmphago1vfs.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::stringstream ss(txt);\n   \
    \     std::string word;\n        while (std::getline(ss, word, ',')) {\n     \
    \       words.push_back(word);\n        }\n        if (words.size() == 0) {\n\
    \            int count = 0;\n            for (int i = 0; i < txt.size(); i++)\
    \ {\n                if (txt[i] >= 'a' && txt[i] <= 'z') {\n                 \
    \   if (i % 2 == 0) {\n                        count++;\n                    }\n\
    \                }\n            }\n            return Union_std_vector_std_string__long(count);\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(words);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpapf5q5l1.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpapf5q5l1.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpapf5q5l1.cpp:\
    \ In function 'int main()':\n/tmp/tmpapf5q5l1.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpapf5q5l1.cpp:2:\n/tmp/tmpapf5q5l1.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpapf5q5l1.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpapf5q5l1.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpapf5q5l1.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpikigj3ju.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpikigj3ju.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpikigj3ju.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpikigj3ju.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpikigj3ju.cpp:\
    \ In function 'int main()':\n/tmp/tmpikigj3ju.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpikigj3ju.cpp:2:\n/tmp/tmpikigj3ju.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpikigj3ju.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpikigj3ju.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpikigj3ju.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::stringstream\
    \ ss(txt);\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\
    \    if (words.size() > 0) {\n        return words;\n    }\n    std::stringstream\
    \ ss2(txt);\n    while (std::getline(ss2, word, ',')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    int count\
    \ = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a'\
    \ && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4y1k54x0.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp4y1k54x0.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp4y1k54x0.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp4y1k54x0.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp4y1k54x0.cpp:\
    \ In function 'int main()':\n/tmp/tmp4y1k54x0.cpp:50:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4y1k54x0.cpp:2:\n/tmp/tmp4y1k54x0.cpp:51:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp4y1k54x0.cpp:51:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp4y1k54x0.cpp:51:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp4y1k54x0.cpp:51:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yvpk097.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp7yvpk097.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp7yvpk097.cpp:\
    \ In function 'int main()':\n/tmp/tmp7yvpk097.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yvpk097.cpp:2:\n/tmp/tmp7yvpk097.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp7yvpk097.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp7yvpk097.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp7yvpk097.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pk47o79.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp6pk47o79.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp6pk47o79.cpp:\
    \ In function 'int main()':\n/tmp/tmp6pk47o79.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6pk47o79.cpp:2:\n/tmp/tmp6pk47o79.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp6pk47o79.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp6pk47o79.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp6pk47o79.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (i % 2 == 1)) {\n            count++;\n        }\n\
    \    }\n    return Union_std_vector_std_string__long(count);\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzmdyrdpo.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpzmdyrdpo.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpzmdyrdpo.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpzmdyrdpo.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpzmdyrdpo.cpp:\
    \ In function 'int main()':\n/tmp/tmpzmdyrdpo.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzmdyrdpo.cpp:2:\n/tmp/tmpzmdyrdpo.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpzmdyrdpo.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpzmdyrdpo.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpzmdyrdpo.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return Union_std_vector_std_string__long(words);\n\
    \    }\n    std::stringstream ss2(txt);\n    std::string word2;\n    while (std::getline(ss2,\
    \ word2, ',')) {\n        words.push_back(word2);\n    }\n    if (words.size()\
    \ > 0) {\n        return Union_std_vector_std_string__long(words);\n    }\n  \
    \  long count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i]\
    \ >= 'a' && txt[i] <= 'z' && (txt[i] - 'a') % 2 == 1) {\n            count++;\n\
    \        }\n    }\n    return Union_std_vector_std_string__long(count);\n}\nint\
    \ main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7wc6wyr.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_7wc6wyr.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_7wc6wyr.cpp:\
    \ In function 'int main()':\n/tmp/tmp_7wc6wyr.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_7wc6wyr.cpp:2:\n/tmp/tmp_7wc6wyr.cpp:52:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_7wc6wyr.cpp:52:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_7wc6wyr.cpp:52:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_7wc6wyr.cpp:52:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::stringstream\
    \ stream(txt);\n    while (stream >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    std::stringstream\
    \ stream2(txt);\n    while (std::getline(stream2, word, ',')) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() > 0) {\n        return words;\n    }\n    int count\
    \ = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a'\
    \ && txt[i] <= 'z' && i % 2 == 0) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"\
    Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_wu93435.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmp_wu93435.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmp_wu93435.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmp_wu93435.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmp_wu93435.cpp:\
    \ In function 'int main()':\n/tmp/tmp_wu93435.cpp:50:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_wu93435.cpp:2:\n/tmp/tmp_wu93435.cpp:51:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmp_wu93435.cpp:51:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmp_wu93435.cpp:51:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmp_wu93435.cpp:51:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string>\
    \ words;\n        std::stringstream ss(txt);\n        std::string word;\n    \
    \    while (ss >> word) {\n            words.push_back(word);\n        }\n   \
    \     return Union_std_vector_std_string__long(words);\n    } else if (txt.find(\"\
    ,\") != std::string::npos) {\n        std::vector<std::string> words;\n      \
    \  std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss,\
    \ word, ',')) {\n            words.push_back(word);\n        }\n        return\
    \ Union_std_vector_std_string__long(words);\n    } else {\n        int count =\
    \ 0;\n        for (int i = 0; i < txt.size(); i++) {\n            if (txt[i] -\
    \ 'a' % 2 == 1) {\n                count++;\n            }\n        }\n      \
    \  return Union_std_vector_std_string__long(count);\n    }\n}\nint main() {\n\
    \    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) ==\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n\
    \    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm0nkbcgz.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmpm0nkbcgz.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmpm0nkbcgz.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmpm0nkbcgz.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmpm0nkbcgz.cpp:\
    \ In function 'int main()':\n/tmp/tmpm0nkbcgz.cpp:52:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm0nkbcgz.cpp:2:\n/tmp/tmpm0nkbcgz.cpp:53:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmpm0nkbcgz.cpp:53:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmpm0nkbcgz.cpp:53:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmpm0nkbcgz.cpp:53:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n\
    \    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string>\
    \ _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1)\
    \ {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string>\
    \ f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n       \
    \ return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of\
    \ words split on whitespace, if no whitespaces exists in the text you\n// should\
    \ split on commas ',' if no commas exists you should return the number of lower-case\
    \ letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ...\
    \ ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n//\
    \ std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n\
    // >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string\
    \ txt) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n\
    \    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    if (words.size() == 0) {\n        std::vector<std::string> words2;\n\
    \        std::stringstream ss2(txt);\n        std::string word2;\n        while\
    \ (std::getline(ss2, word2, ',')) {\n            words2.push_back(word2);\n  \
    \      }\n        if (words2.size() == 0) {\n            int count = 0;\n    \
    \        for (int i = 0; i < txt.size(); i++) {\n                if (txt[i] >=\
    \ 'a' && txt[i] <= 'z') {\n                    if (i % 2 == 0) {\n           \
    \             count++;\n                    }\n                }\n           \
    \ }\n            return Union_std_vector_std_string__long(count);\n        } else\
    \ {\n            return Union_std_vector_std_string__long(words2);\n        }\n\
    \    } else {\n        return Union_std_vector_std_string__long(words);\n    }\n\
    }\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello\
    \ world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"\
    world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"\
    }));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"\
    Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\"\
    )) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"\
    aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps2iunn9p.cpp:4:30: error: member 'std::vector<std::basic_string<char>\
    \ > Union_std_vector_std_string__long::f0' with constructor not allowed in union\n\
    \     std::vector<std::string> f0;\n                              ^\n/tmp/tmps2iunn9p.cpp:4:30:\
    \ error: member 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with destructor not allowed in union\n/tmp/tmps2iunn9p.cpp:4:30: error: member\
    \ 'std::vector<std::basic_string<char> > Union_std_vector_std_string__long::f0'\
    \ with copy assignment operator not allowed in union\n/tmp/tmps2iunn9p.cpp:4:30:\
    \ note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n/tmp/tmps2iunn9p.cpp:\
    \ In function 'int main()':\n/tmp/tmps2iunn9p.cpp:56:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = split_words;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps2iunn9p.cpp:2:\n/tmp/tmps2iunn9p.cpp:57:38: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Hello world!\"\
    )) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"\
    }));\n                                      ^\n/tmp/tmps2iunn9p.cpp:57:67: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                            ^\n/tmp/tmps2iunn9p.cpp:57:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"\
    Hello\", (std::string)\"world!\"}));\n                                       \
    \                                                                          ^\n\
    /tmp/tmps2iunn9p.cpp:57:113: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by defaul"
  stdout: ''
