language: cpp
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_lower = true;\n\
    \        } else if(isupper(it->first[0])) {\n            is_upper = true;\n  \
    \      } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5xuhbb6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpg5xuhbb6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpg5xuhbb6.cpp: In function 'int main()':\n/tmp/tmpg5xuhbb6.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5xuhbb6.cpp:2:\n/tmp/tmpg5xuhbb6.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    std::map<std::string,std::string>::iterator\
    \ it;\n    bool is_lower = false;\n    bool is_upper = false;\n    for(it = dict.begin();\
    \ it != dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    if(is_lower\
    \ && is_upper)\n        return false;\n    return true;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpibwwxcyb.cpp: In function 'int main()':\n/tmp/tmpibwwxcyb.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpibwwxcyb.cpp:2:\n/tmp/tmpibwwxcyb.cpp:35:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpibwwxcyb.cpp:35:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpibwwxcyb.cpp:35:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpibwwxcyb.cpp:35:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpibwwxcyb.cpp:35:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpibwwxcyb.cpp:35:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpibwwxcyb.cpp:35:94: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/map:61:0,\n  \
    \               from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:80,\n\
    \                 from /tmp/tmpibwwxcyb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_map.h:241:9:\
    \ note: template<class _InputIterator> std::map<_Key, _Tp, _Compare, _Alloc>::map(_InputIterator,\
    \ _InputIterator, const _Compare&, const allocator_type&)\n         map(_InputIterator\
    \ __first, _InputIterator __last"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z')\n            upper\
    \ = false;\n        else if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n    \
    \        lower = false;\n        else\n            return false;\n    }\n    return\
    \ upper || lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa1bn5brs.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpa1bn5brs.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpa1bn5brs.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpa1bn5brs.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpa1bn5brs.cpp: In function 'int main()':\n/tmp/tmpa1bn5brs.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa1bn5brs.cpp:2:\n/tmp/tmpa1bn5brs.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpa1bn5brs.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpa1bn5brs.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpa1bn5brs.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpa1bn5brs.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpa1bn5brs.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_upper = false;\n\
    \        } else if(isupper(it->first[0])) {\n            is_lower = false;\n \
    \       } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4sm_okeq.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp4sm_okeq.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp4sm_okeq.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp4sm_okeq.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp4sm_okeq.cpp: In function 'int main()':\n/tmp/tmp4sm_okeq.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4sm_okeq.cpp:2:\n/tmp/tmp4sm_okeq.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp4sm_okeq.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp4sm_okeq.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp4sm_okeq.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4sm_okeq.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp4sm_okeq.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        std::string key = it->first;\n        if(key.size() == 0) return\
    \ false;\n        if(isupper(key[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return (is_lower && !is_upper) || (!is_lower && is_upper);\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5zz0jlqn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp5zz0jlqn.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp5zz0jlqn.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp5zz0jlqn.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp5zz0jlqn.cpp: In function 'int main()':\n/tmp/tmp5zz0jlqn.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5zz0jlqn.cpp:2:\n/tmp/tmp5zz0jlqn.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp5zz0jlqn.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp5zz0jlqn.cpp:31:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5zz0jlqn.cpp:31:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp5zz0jlqn.cpp:31:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp5zz0jlqn.cpp:31:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp5"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(is_lower) {\n            is_lower = is_lower && (it->first\
    \ == tolower(it->first));\n        }\n        if(is_upper) {\n            is_upper\
    \ = is_upper && (it->first == toupper(it->first));\n        }\n    }\n    return\
    \ is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo4s6s_b7.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpo4s6s_b7.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpo4s6s_b7.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpo4s6s_b7.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpo4s6s_b7.cpp: In function 'int main()':\n/tmp/tmpo4s6s_b7.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo4s6s_b7.cpp:2:\n/tmp/tmpo4s6s_b7.cpp:33:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpo4s6s_b7.cpp:33:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpo4s6s_b7.cpp:33:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpo4s6s_b7.cpp:33:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpo4s6s_b7.cpp:33:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpo4s6s_b7.cpp:33:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpo"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = false;\n \
    \   bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z') upper = true;\n  \
    \      if(it->first[0] >= 'a' && it->first[0] <= 'z') lower = true;\n    }\n \
    \   return (upper && !lower) || (!upper && lower);\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdrimn00m.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpdrimn00m.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpdrimn00m.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpdrimn00m.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpdrimn00m.cpp: In function 'int main()':\n/tmp/tmpdrimn00m.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdrimn00m.cpp:2:\n/tmp/tmpdrimn00m.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpdrimn00m.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpdrimn00m.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpdrimn00m.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpdrimn00m.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpdrimn00m.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpd"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0]))\n            is_lower = false;\n\
    \        else\n            is_upper = false;\n    }\n    return is_lower || is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftarnd74.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpftarnd74.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpftarnd74.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpftarnd74.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpftarnd74.cpp: In function 'int main()':\n/tmp/tmpftarnd74.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftarnd74.cpp:2:\n/tmp/tmpftarnd74.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpftarnd74.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpftarnd74.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpftarnd74.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpf"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    // To print results to the standard\
    \ output you can use std::cout\n    // Example: std::cout << \"Hello world!\"\
    ;\n    if(dict.size()==0)\n        return false;\n    bool is_lower=true;\n  \
    \  bool is_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++)\n  \
    \  {\n        if(islower(it->first[0]))\n            is_upper=false;\n       \
    \ else\n            is_lower=false;\n    }\n    return is_lower || is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd7as5exr.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpd7as5exr.cpp:25:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++)\n          \
    \    ^\n/tmp/tmpd7as5exr.cpp:25:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++)\n                              ^\n/tmp/tmpd7as5exr.cpp:25:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpd7as5exr.cpp: In function\
    \ 'int main()':\n/tmp/tmpd7as5exr.cpp:35:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd7as5exr.cpp:2:\n/tmp/tmpd7as5exr.cpp:36:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpd7as5exr.cpp:36:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpd7as5exr.cpp:36:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpd7as5exr.cpp:36:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpd7as5exr.cpp:36:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpd7as5exr.cpp:36:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpd7as5exr.cpp:36:94: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool is_upper = true;\n \
    \   bool is_lower = true;\n    for(auto it=dict.begin(); it!=dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0])) is_upper = false;\n        if(!islower(it->first[0]))\
    \ is_lower = false;\n    }\n    return is_upper || is_lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqaplfojg.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqaplfojg.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin(); it!=dict.end(); it++) {\n      \
    \        ^\n/tmp/tmpqaplfojg.cpp:21:31: error: expected ';' before 'it'\n    \
    \ for(auto it=dict.begin(); it!=dict.end(); it++) {\n                        \
    \       ^\n/tmp/tmpqaplfojg.cpp:21:31: error: 'it' was not declared in this scope\n\
    /tmp/tmpqaplfojg.cpp: In function 'int main()':\n/tmp/tmpqaplfojg.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqaplfojg.cpp:2:\n/tmp/tmpqaplfojg.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqaplfojg.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqaplfojg.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqaplfojg.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqaplfojg.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpqaplfojg.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpqaplfojg.cp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_upper = false;\n\
    \    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n    }\n    return is_upper ^ is_lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3zodsgd.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpa3zodsgd.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpa3zodsgd.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpa3zodsgd.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpa3zodsgd.cpp: In function 'int main()':\n/tmp/tmpa3zodsgd.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa3zodsgd.cpp:2:\n/tmp/tmpa3zodsgd.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpa3zodsgd.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpa3zodsgd.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpa3zodsgd.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpa3zodsgd.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpa3zodsgd.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpa"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(is_lower && !std::all_of(it->first.begin(), it->first.end(),\
    \ ::islower))\n            is_lower = false;\n        if(is_upper && !std::all_of(it->first.begin(),\
    \ it->first.end(), ::isupper))\n            is_upper = false;\n    }\n    return\
    \ is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfj7kpc4_.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpfj7kpc4_.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpfj7kpc4_.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpfj7kpc4_.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpfj7kpc4_.cpp:23:25: error: 'all_of' is not a member of\
    \ 'std'\n         if(is_lower && !std::all_of(it->first.begin(), it->first.end(),\
    \ ::islower))\n                         ^\n/tmp/tmpfj7kpc4_.cpp:25:25: error:\
    \ 'all_of' is not a member of 'std'\n         if(is_upper && !std::all_of(it->first.begin(),\
    \ it->first.end(), ::isupper))\n                         ^\n/tmp/tmpfj7kpc4_.cpp:\
    \ In function 'int main()':\n/tmp/tmpfj7kpc4_.cpp:31:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfj7kpc4_.cpp:2:\n/tmp/tmpfj7kpc4_.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpfj7kpc4_.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpfj7kpc4_.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpfj7kpc4_.cpp:32:94: warning: extended initializer\
    \ lists only available wi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            is_upper = false;\n\
    \        if(!islower(it->first[0]))\n            is_lower = false;\n    }\n  \
    \  return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1oil7ozn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1oil7ozn.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp1oil7ozn.cpp: In function 'int main()':\n/tmp/tmp1oil7ozn.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1oil7ozn.cpp:2:\n/tmp/tmp1oil7ozn.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            lower = false;\n        else\n      \
    \      return false;\n    }\n    return (lower || upper);\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96cfnonm.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp96cfnonm.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp96cfnonm.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp96cfnonm.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp96cfnonm.cpp: In function 'int main()':\n/tmp/tmp96cfnonm.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96cfnonm.cpp:2:\n/tmp/tmp96cfnonm.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp96cfnonm.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp96cfnonm.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp96cfnonm.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp96cfnonm.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp96cfnonm.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp9"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n        if(it->first[0]>='a'\
    \ && it->first[0]<='z')\n        {\n            for(int i=1;i<it->first.length();i++)\n\
    \            {\n                if(it->first[i]<'a' || it->first[i]>'z')\n   \
    \             {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else if(it->first[0]>='A'\
    \ && it->first[0]<='Z')\n        {\n            for(int i=1;i<it->first.length();i++)\n\
    \            {\n                if(it->first[i]<'A' || it->first[i]>'Z')\n   \
    \             {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcpxf7v9b.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpcpxf7v9b.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++)\n          \
    \    ^\n/tmp/tmpcpxf7v9b.cpp:21:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++)\n                              ^\n/tmp/tmpcpxf7v9b.cpp:21:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpcpxf7v9b.cpp: In function\
    \ 'int main()':\n/tmp/tmpcpxf7v9b.cpp:54:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcpxf7v9b.cpp:2:\n/tmp/tmpcpxf7v9b.cpp:55:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpcpxf7v9b.cpp:55:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpcpxf7v9b.cpp:55:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpcpxf7v9b.cpp:55:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpcpxf7v9b.cpp:55:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpcpxf7v9b.cpp:55:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpcpxf7v9b.cpp:55:94: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_upper = false;\n\
    \    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z') {\n        \
    \    is_upper = true;\n        }\n        if(it->first[0] >= 'a' && it->first[0]\
    \ <= 'z') {\n            is_lower = true;\n        }\n    }\n    return is_upper\
    \ ^ is_lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoexl8_q4.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpoexl8_q4.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpoexl8_q4.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpoexl8_q4.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpoexl8_q4.cpp: In function 'int main()':\n/tmp/tmpoexl8_q4.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoexl8_q4.cpp:2:\n/tmp/tmpoexl8_q4.cpp:33:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpoexl8_q4.cpp:33:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpoexl8_q4.cpp:33:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpoexl8_q4.cpp:33:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpoexl8_q4.cpp:33:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpoexl8_q4.cpp:33:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpo"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = false;\n\
    \    bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            lower = true;\n        else\
    \ if(isupper(it->first[0]))\n            upper = true;\n        else\n       \
    \     return false;\n    }\n    return lower ^ upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3n_qzep7.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3n_qzep7.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3n_qzep7.cpp: In function 'int main()':\n/tmp/tmp3n_qzep7.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3n_qzep7.cpp:2:\n/tmp/tmp3n_qzep7.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            lower = false;\n        else\n      \
    \      return false;\n    }\n    return lower || upper;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpel9w83am.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpel9w83am.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpel9w83am.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpel9w83am.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpel9w83am.cpp: In function 'int main()':\n/tmp/tmpel9w83am.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpel9w83am.cpp:2:\n/tmp/tmpel9w83am.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpel9w83am.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpel9w83am.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpel9w83am.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpe"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool flag=true;\n    for(auto\
    \ i:dict){\n        if(i.first[0]>=65 && i.first[0]<=90){\n            flag=false;\n\
    \            break;\n        }\n    }\n    if(flag) return true;\n    flag=true;\n\
    \    for(auto i:dict){\n        if(i.first[0]>=97 && i.first[0]<=122){\n     \
    \       flag=false;\n            break;\n        }\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk5ba2fem.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpk5ba2fem.cpp:20:14: error: 'i' does not\
    \ name a type\n     for(auto i:dict){\n              ^\n/tmp/tmpk5ba2fem.cpp:26:5:\
    \ error: expected ';' before 'if'\n     if(flag) return true;\n     ^\n/tmp/tmpk5ba2fem.cpp:26:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpk5ba2fem.cpp:26:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpk5ba2fem.cpp:26:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpk5ba2fem.cpp:26:5: error: expected ')' before 'if'\n/tmp/tmpk5ba2fem.cpp:28:14:\
    \ error: 'i' does not name a type\n     for(auto i:dict){\n              ^\n/tmp/tmpk5ba2fem.cpp:34:5:\
    \ error: expected ';' before 'return'\n     return flag;\n     ^\n/tmp/tmpk5ba2fem.cpp:34:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpk5ba2fem.cpp:34:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpk5ba2fem.cpp:34:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpk5ba2fem.cpp:34:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpk5ba2fem.cpp: In function 'int main()':\n/tmp/tmpk5ba2fem.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk5ba2fem.cpp:2:\n/tmp/tmpk5ba2fem.cpp:38:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpk5ba2fem.cpp:38:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpk"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool all_lower=true;\n\
    \    bool all_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(it->first[0]>='a' && it->first[0]<='z')\n            all_upper=false;\n\
    \        else\n            all_lower=false;\n    }\n    return all_lower || all_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cmow8ba.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp4cmow8ba.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++){\n         \
    \     ^\n/tmp/tmp4cmow8ba.cpp:22:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n                              ^\n/tmp/tmp4cmow8ba.cpp:22:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmp4cmow8ba.cpp: In function\
    \ 'int main()':\n/tmp/tmp4cmow8ba.cpp:31:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4cmow8ba.cpp:2:\n/tmp/tmp4cmow8ba.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp4cmow8ba.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp4cmow8ba.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp4cmow8ba.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4cmow8ba.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp4cmow8ba.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4cmow8ba.cpp:32:94"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_lower = true;\n\
    \        } else if(isupper(it->first[0])) {\n            is_upper = true;\n  \
    \      } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5xuhbb6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpg5xuhbb6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpg5xuhbb6.cpp: In function 'int main()':\n/tmp/tmpg5xuhbb6.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5xuhbb6.cpp:2:\n/tmp/tmpg5xuhbb6.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z')\n\
    \            is_lower = true;\n        else if(it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z')\n            is_upper = true;\n        else\n            return false;\n\
    \    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate =\
    \ check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm1r5xtvy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpm1r5xtvy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpm1r5xtvy.cpp: In function 'int main()':\n/tmp/tmpm1r5xtvy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm1r5xtvy.cpp:2:\n/tmp/tmpm1r5xtvy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z')\
    \ {\n            is_lower = true;\n        }\n        else if(it->first[0] >=\
    \ 'A' && it->first[0] <= 'Z') {\n            is_upper = true;\n        }\n   \
    \     else {\n            return false;\n        }\n    }\n    if(is_lower &&\
    \ is_upper)\n        return false;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqzbno8_8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqzbno8_8.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpqzbno8_8.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpqzbno8_8.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpqzbno8_8.cpp: In function 'int main()':\n/tmp/tmpqzbno8_8.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqzbno8_8.cpp:2:\n/tmp/tmpqzbno8_8.cpp:39:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqzbno8_8.cpp:39:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqzbno8_8.cpp:39:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqzbno8_8.cpp:39:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqzbno8_8.cpp:39:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpqzbno8_8.cpp:39:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpq"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyumvzn42.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpyumvzn42.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpyumvzn42.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpyumvzn42.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpyumvzn42.cpp: In function 'int main()':\n/tmp/tmpyumvzn42.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyumvzn42.cpp:2:\n/tmp/tmpyumvzn42.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpyumvzn42.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpyumvzn42.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyumvzn42.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpyumvzn42.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpyumvzn42.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpy"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower=false;\n\
    \    bool is_upper=false;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(islower(it->first[0]))\n            is_lower=true;\n        else if(isupper(it->first[0]))\n\
    \            is_upper=true;\n        else\n            return false;\n    }\n\
    \    if(is_lower && is_upper)\n        return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv5777djv.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpv5777djv.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++){\n         \
    \     ^\n/tmp/tmpv5777djv.cpp:22:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n                              ^\n/tmp/tmpv5777djv.cpp:22:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpv5777djv.cpp: In function\
    \ 'int main()':\n/tmp/tmpv5777djv.cpp:35:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv5777djv.cpp:2:\n/tmp/tmpv5777djv.cpp:36:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpv5777djv.cpp:36:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpv5777djv.cpp:36:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpv5777djv.cpp:36:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpv5777djv.cpp:36:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpv5777djv.cpp:36:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpv5777djv.cpp:36:94"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = true;\n  \
    \  bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0])) upper = false;\n        if(!islower(it->first[0]))\
    \ lower = false;\n    }\n    return upper || lower;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqyyu_rx6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqyyu_rx6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpqyyu_rx6.cpp: In function 'int main()':\n/tmp/tmpqyyu_rx6.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqyyu_rx6.cpp:2:\n/tmp/tmpqyyu_rx6.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpq"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_lower = true;\n        } else if(it->first[0] >= 'A' && it->first[0] <=\
    \ 'Z') {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdlpb0u8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzdlpb0u8.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpzdlpb0u8.cpp: In function 'int main()':\n/tmp/tmpzdlpb0u8.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdlpb0u8.cpp:2:\n/tmp/tmpzdlpb0u8.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool lower = true;\n    bool upper = true;\n    for (auto it =\
    \ dict.begin(); it != dict.end(); it++) {\n        if (islower(it->first[0]))\
    \ {\n            upper = false;\n        } else if (isupper(it->first[0])) {\n\
    \            lower = false;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return lower || upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8evrl9u1.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8evrl9u1.cpp:20:15: error: 'it' does not\
    \ name a type\n     for (auto it = dict.begin(); it != dict.end(); it++) {\n \
    \              ^\n/tmp/tmp8evrl9u1.cpp:20:34: error: expected ';' before 'it'\n\
    \     for (auto it = dict.begin(); it != dict.end(); it++) {\n               \
    \                   ^\n/tmp/tmp8evrl9u1.cpp:20:34: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8evrl9u1.cpp: In function 'int main()':\n/tmp/tmp8evrl9u1.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8evrl9u1.cpp:2:\n/tmp/tmp8evrl9u1.cpp:33:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8evrl9u1.cpp:33:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8evrl9u1.cpp:33:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8evrl9u1.cpp:33:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8evrl9u1.cpp:33:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8evrl9u1.cpp:33:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(isupper(it->first[0]))\n            upper = true;\n        else\n\
    \            lower = true;\n    }\n    return upper != lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpruei6pf6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpruei6pf6.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpruei6pf6.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpruei6pf6.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpruei6pf6.cpp: In function 'int main()':\n/tmp/tmpruei6pf6.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpruei6pf6.cpp:2:\n/tmp/tmpruei6pf6.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpruei6pf6.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpruei6pf6.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpruei6pf6.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpruei6pf6.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpruei6pf6.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpr"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code goes here\n    if(dict.size()==0)\n        return\
    \ false;\n    std::map<std::string,std::string>::iterator it;\n    bool flag =\
    \ true;\n    for(it=dict.begin();it!=dict.end();it++)\n    {\n        std::string\
    \ key = it->first;\n        for(int i=0;i<key.length();i++)\n        {\n     \
    \       if(key[i]>=65 && key[i]<=90)\n            {\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(flag==false)\n \
    \           break;\n    }\n    if(flag==false)\n    {\n        flag = true;\n\
    \        for(it=dict.begin();it!=dict.end();it++)\n        {\n            std::string\
    \ key = it->first;\n            for(int i=0;i<key.length();i++)\n            {\n\
    \                if(key[i]>=97 && key[i]<=122)\n                {\n          \
    \          flag = false;\n                    break;\n                }\n    \
    \        }\n            if(flag==false)\n                break;\n        }\n \
    \   }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpld0izwwa.cpp: In function 'int main()':\n/tmp/tmpld0izwwa.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpld0izwwa.cpp:2:\n/tmp/tmpld0izwwa.cpp:59:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpld0izwwa.cpp:59:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpld0izwwa.cpp:59:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpld0izwwa.cpp:59:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpld0izwwa.cpp:59:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpld0izwwa.cpp:59:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpld0izwwa.cpp:59:94: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/map:61:0,\n  \
    \               from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:80,\n\
    \                 from /tmp/tmpld0izwwa.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_map.h:241:9:\
    \ note: template<class _InputIterator> std::map<_Key, _Tp, _Compare, _Alloc>::map(_InputIterator,\
    \ _InputIterator, const _Compare&, const allocator_type&)\n         map(_InputIterator\
    \ __first, _InputIterator __last"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1q_xkh1y.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1q_xkh1y.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp1q_xkh1y.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp1q_xkh1y.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp1q_xkh1y.cpp: In function 'int main()':\n/tmp/tmp1q_xkh1y.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1q_xkh1y.cpp:2:\n/tmp/tmp1q_xkh1y.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1q_xkh1y.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp1q_xkh1y.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1q_xkh1y.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1q_xkh1y.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1q_xkh1y.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size() == 0)\n        return false;\n\
    \    bool is_lower = false;\n    bool is_upper = false;\n    for(auto it = dict.begin();\
    \ it != dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    if(is_lower && is_upper)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfgvgvwbu.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpfgvgvwbu.cpp:23:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpfgvgvwbu.cpp:23:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpfgvgvwbu.cpp:23:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpfgvgvwbu.cpp: In function 'int main()':\n/tmp/tmpfgvgvwbu.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgvgvwbu.cpp:2:\n/tmp/tmpfgvgvwbu.cpp:37:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpfgvgvwbu.cpp:37:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpfgvgvwbu.cpp:37:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpfgvgvwbu.cpp:37:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpfgvgvwbu.cpp:37:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpfgvgvwbu.cpp:37:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpf"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_lower = false;\n        if(islower(it->first[0]))\
    \ is_upper = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpch_tp4_n.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpch_tp4_n.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpch_tp4_n.cpp: In function 'int main()':\n/tmp/tmpch_tp4_n.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpch_tp4_n.cpp:2:\n/tmp/tmpch_tp4_n.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else if(islower(it->first[0]))\n            is_lower = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuayvfhoy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuayvfhoy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpuayvfhoy.cpp: In function 'int main()':\n/tmp/tmpuayvfhoy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuayvfhoy.cpp:2:\n/tmp/tmpuayvfhoy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpu"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    return is_upper\
    \ ^ is_lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3bdx24kl.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3bdx24kl.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3bdx24kl.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3bdx24kl.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3bdx24kl.cpp: In function 'int main()':\n/tmp/tmp3bdx24kl.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3bdx24kl.cpp:2:\n/tmp/tmp3bdx24kl.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3bdx24kl.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3bdx24kl.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3bdx24kl.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3bdx24kl.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3bdx24kl.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0])) all_upper = false;\n        if(!islower(it->first[0]))\
    \ all_lower = false;\n    }\n    return all_lower || all_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3adxd0t0.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3adxd0t0.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3adxd0t0.cpp: In function 'int main()':\n/tmp/tmp3adxd0t0.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3adxd0t0.cpp:2:\n/tmp/tmp3adxd0t0.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    bool flag1=true;\n    bool flag2=true;\n    for(auto it=dict.begin();it!=dict.end();it++)\n\
    \    {\n        if(it->first[0]>='a' && it->first[0]<='z')\n            flag1=true;\n\
    \        else\n        {\n            flag1=false;\n            break;\n     \
    \   }\n    }\n    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n     \
    \   if(it->first[0]>='A' && it->first[0]<='Z')\n            flag2=true;\n    \
    \    else\n        {\n            flag2=false;\n            break;\n        }\n\
    \    }\n    if(flag1==true || flag2==true)\n        flag=true;\n    else\n   \
    \     flag=false;\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3m3ugxwa.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3m3ugxwa.cpp:23:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++)\n          \
    \    ^\n/tmp/tmp3m3ugxwa.cpp:23:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++)\n                              ^\n/tmp/tmp3m3ugxwa.cpp:23:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmp3m3ugxwa.cpp:33:14: error:\
    \ 'it' does not name a type\n     for(auto it=dict.begin();it!=dict.end();it++)\n\
    \              ^\n/tmp/tmp3m3ugxwa.cpp:33:30: error: expected ';' before 'it'\n\
    \     for(auto it=dict.begin();it!=dict.end();it++)\n                        \
    \      ^\n/tmp/tmp3m3ugxwa.cpp:33:30: error: 'it' was not declared in this scope\n\
    /tmp/tmp3m3ugxwa.cpp: In function 'int main()':\n/tmp/tmp3m3ugxwa.cpp:50:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3m3ugxwa.cpp:2:\n/tmp/tmp3m3ugxwa.cpp:51:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3m3ugxwa.cpp:51:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3m3ugxwa.cpp:51:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3m3ugxwa.cpp:51:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = true;\n  \
    \  bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0])) upper = false;\n        if(!islower(it->first[0]))\
    \ lower = false;\n    }\n    return upper || lower;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqyyu_rx6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqyyu_rx6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpqyyu_rx6.cpp: In function 'int main()':\n/tmp/tmpqyyu_rx6.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqyyu_rx6.cpp:2:\n/tmp/tmpqyyu_rx6.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpq"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else if(islower(it->first[0]))\n            is_lower = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuayvfhoy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuayvfhoy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpuayvfhoy.cpp: In function 'int main()':\n/tmp/tmpuayvfhoy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuayvfhoy.cpp:2:\n/tmp/tmpuayvfhoy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpu"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool lower=true;\n\
    \    bool upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n  \
    \      if(islower(it->first[0]))\n            upper=false;\n        else if(isupper(it->first[0]))\n\
    \            lower=false;\n        else\n            return false;\n    }\n  \
    \  if(lower||upper)\n        return true;\n    return false;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpig8tv59u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto i:dict){\n        if(i.first[0]>='a' && i.first[0]<='z'){\n    \
    \        flag=true;\n            break;\n        }\n        else if(i.first[0]>='A'\
    \ && i.first[0]<='Z'){\n            flag=false;\n            break;\n        }\n\
    \    }\n    for(auto i:dict){\n        if(flag){\n            if(i.first[0]>='A'\
    \ && i.first[0]<='Z')\n                return false;\n        }\n        else{\n\
    \            if(i.first[0]>='a' && i.first[0]<='z')\n                return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6l8o_6j8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            is_upper = false;\n\
    \        if(!islower(it->first[0]))\n            is_lower = false;\n    }\n  \
    \  return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1oil7ozn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1oil7ozn.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp1oil7ozn.cpp: In function 'int main()':\n/tmp/tmp1oil7ozn.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1oil7ozn.cpp:2:\n/tmp/tmp1oil7ozn.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size()==0)\n        return false;\n\
    \    bool flag=true;\n    for(auto i:dict)\n    {\n        if(islower(i.first[0]))\n\
    \        {\n            for(auto j:i.first)\n            {\n                if(!islower(j))\n\
    \                {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else if(isupper(i.first[0]))\n\
    \        {\n            for(auto j:i.first)\n            {\n                if(!isupper(j))\n\
    \                {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpga20loyt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_88karc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n  if (dict.size() == 0) {\n    return false;\n  }\n  bool lower = true;\n\
    \  bool upper = true;\n  for (auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n    if (it->first[0] < 'a' || it->first[0] > 'z') {\n      lower = false;\n\
    \    }\n    if (it->first[0] < 'A' || it->first[0] > 'Z') {\n      upper = false;\n\
    \    }\n  }\n  return lower || upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp48sj7oes.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n\tif(dict.size() == 0) return false;\n\tbool is_lower = false;\n\t\
    bool is_upper = false;\n\tfor(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n\t\tif(isupper(it->first[0])) is_upper = true;\n\t\telse is_lower = true;\n\
    \t}\n\treturn is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplcbx11qb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool is_lower=true;\n   \
    \ for(auto it=dict.begin();it!=dict.end();it++){\n        if(islower(it->first[0])){\n\
    \            is_lower=true;\n            break;\n        }\n        else if(isupper(it->first[0])){\n\
    \            is_lower=false;\n            break;\n        }\n    }\n    for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n        if(is_lower){\n            if(!islower(it->first[0]))\
    \ return false;\n        }\n        else{\n            if(!isupper(it->first[0]))\
    \ return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgrlm0v5a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return (is_lower && !is_upper)\
    \ || (!is_lower && is_upper);\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa65m2wq4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower=false;\n\
    \    bool is_upper=false;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(isupper(it->first[0]))\n            is_upper=true;\n        else\n\
    \            is_lower=true;\n    }\n    if(is_lower && is_upper)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnl6j0il0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool all_lower=true;\n  \
    \  bool all_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        std::string key=it->first;\n        for(int i=0;i<key.size();i++){\n\
    \            if(isupper(key[i])){\n                all_lower=false;\n        \
    \    }\n            else if(islower(key[i])){\n                all_upper=false;\n\
    \            }\n            else{\n                return false;\n           \
    \ }\n        }\n    }\n    return all_lower || all_upper;\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp2x3y4ka.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size()==0)\n        return false;\n\
    \    bool upper = true;\n    bool lower = true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(!isupper(it->first[0]))\n            upper = false;\n        if(!islower(it->first[0]))\n\
    \            lower = false;\n    }\n    if(upper || lower)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmife1fjz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it=dict.begin(); it!=dict.end(); it++)\
    \ {\n        if(it->first.size()==0) return false;\n        if(!isupper(it->first[0]))\
    \ all_upper = false;\n        if(!islower(it->first[0])) all_lower = false;\n\
    \    }\n    return all_lower || all_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_rnvooqw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool flag = true;\n\
    \    for(auto it = dict.begin(); it != dict.end(); it++) {\n        if(islower(it->first[0]))\
    \ {\n            for(int i = 0; i < it->first.size(); i++) {\n               \
    \ if(!islower(it->first[i])) {\n                    flag = false;\n          \
    \          break;\n                }\n            }\n        }\n        else if(isupper(it->first[0]))\
    \ {\n            for(int i = 0; i < it->first.size(); i++) {\n               \
    \ if(!isupper(it->first[i])) {\n                    flag = false;\n          \
    \          break;\n                }\n            }\n        }\n        else {\n\
    \            flag = false;\n            break;\n        }\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwapbt8jj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_88karc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n            upper\
    \ = true;\n        else if(it->first[0] >= 'a' && it->first[0] <= 'z')\n     \
    \       lower = true;\n        else\n            return false;\n    }\n    if(upper\
    \ && lower)\n        return false;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkvsusga5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = false;\n\
    \    bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            lower = true;\n        else\
    \ if(isupper(it->first[0]))\n            upper = true;\n        else\n       \
    \     return false;\n    }\n    return lower ^ upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3n_qzep7.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3n_qzep7.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3n_qzep7.cpp: In function 'int main()':\n/tmp/tmp3n_qzep7.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3n_qzep7.cpp:2:\n/tmp/tmp3n_qzep7.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = true;\n    bool is_lower = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0]))\n            is_upper = false;\n\
    \        if(isupper(it->first[0]))\n            is_lower = false;\n    }\n   \
    \ return is_upper || is_lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcm2glnrf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto &i : dict) {\n        if(isupper(i.first[0]))\n\
    \            is_upper = true;\n        else\n            is_lower = true;\n  \
    \  }\n    return is_upper ^ is_lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkpde1hel.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_upper =\
    \ false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n          \
    \  is_upper = true;\n        else if(it->first[0] >= 'a' && it->first[0] <= 'z')\n\
    \            is_lower = true;\n        else\n            return false;\n    }\n\
    \    if(is_upper && is_lower)\n        return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc3ng93s8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++){\n        if(islower(it->first[0])){\n\
    \            for(int i=0;i<it->first.length();i++){\n                if(!islower(it->first[i])){\n\
    \                    flag=false;\n                    break;\n               \
    \ }\n            }\n        }\n        else if(isupper(it->first[0])){\n     \
    \       for(int i=0;i<it->first.length();i++){\n                if(!isupper(it->first[i])){\n\
    \                    flag=false;\n                    break;\n               \
    \ }\n            }\n        }\n        else{\n            flag=false;\n      \
    \      break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpodrq2d2_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return (is_lower && !is_upper) || (!is_lower &&\
    \ is_upper);\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7l356eni.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_lower = true;\n        } else if(it->first[0] >= 'A' && it->first[0] <=\
    \ 'Z') {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdlpb0u8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzdlpb0u8.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpzdlpb0u8.cpp: In function 'int main()':\n/tmp/tmpzdlpb0u8.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdlpb0u8.cpp:2:\n/tmp/tmpzdlpb0u8.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n        if(islower(it->first[0]))\n\
    \        {\n            for(int i=0;i<it->first.length();i++)\n            {\n\
    \                if(!islower(it->first[i]))\n                {\n             \
    \       flag=false;\n                    break;\n                }\n         \
    \   }\n        }\n        else if(isupper(it->first[0]))\n        {\n        \
    \    for(int i=0;i<it->first.length();i++)\n            {\n                if(!isupper(it->first[i]))\n\
    \                {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf429bf06.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool upper = true;\n    bool lower = true;\n    for (auto it =\
    \ dict.begin(); it != dict.end(); it++) {\n        if (it->first.size() == 0)\
    \ {\n            return false;\n        }\n        if (it->first[0] >= 'a' &&\
    \ it->first[0] <= 'z') {\n            upper = false;\n        }\n        if (it->first[0]\
    \ >= 'A' && it->first[0] <= 'Z') {\n            lower = false;\n        }\n  \
    \  }\n    return upper || lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzcwcsfa5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool upper=true;\n    bool\
    \ lower=true;\n    for(auto i:dict){\n        if(islower(i.first[0])){\n     \
    \       upper=false;\n        }\n        else{\n            lower=false;\n   \
    \     }\n    }\n    return upper||lower;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcjfth_66.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return (is_lower && !is_upper)\
    \ || (!is_lower && is_upper);\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa65m2wq4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0]))\n            is_lower = false;\n\
    \        else\n            is_upper = false;\n    }\n    return is_lower || is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftarnd74.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpftarnd74.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpftarnd74.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpftarnd74.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpftarnd74.cpp: In function 'int main()':\n/tmp/tmpftarnd74.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftarnd74.cpp:2:\n/tmp/tmpftarnd74.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpftarnd74.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpftarnd74.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpftarnd74.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpf"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool isUpper =\
    \ true;\n    bool isLower = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            isUpper = false;\n\
    \        if(!islower(it->first[0]))\n            isLower = false;\n    }\n   \
    \ return isUpper || isLower;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmr5898iw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdmn5qdoa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0]))\n            is_lower = false;\n\
    \        else\n            is_upper = false;\n    }\n    return is_lower || is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftarnd74.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpftarnd74.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpftarnd74.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpftarnd74.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpftarnd74.cpp: In function 'int main()':\n/tmp/tmpftarnd74.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftarnd74.cpp:2:\n/tmp/tmpftarnd74.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpftarnd74.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpftarnd74.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpftarnd74.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpftarnd74.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpf"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    std::map<std::string,std::string>::iterator it;\n    bool upper\
    \ = true;\n    bool lower = true;\n    for (it = dict.begin(); it != dict.end();\
    \ it++) {\n        if (it->first[0] >= 'a' && it->first[0] <= 'z') {\n       \
    \     upper = false;\n        }\n        if (it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z') {\n            lower = false;\n        }\n    }\n    return upper ||\
    \ lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbt7y75hr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(is_lower && !(islower(it->first[0])))\n            is_lower\
    \ = false;\n        if(is_upper && !(isupper(it->first[0])))\n            is_upper\
    \ = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7iczav7w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = false;\n \
    \   bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0])) {\n            lower = true;\n        }\
    \ else if(isupper(it->first[0])) {\n            upper = true;\n        } else\
    \ {\n            return false;\n        }\n    }\n    return lower ^ upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5xh0i265.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    return is_upper\
    \ ^ is_lower;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3bdx24kl.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3bdx24kl.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3bdx24kl.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3bdx24kl.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3bdx24kl.cpp: In function 'int main()':\n/tmp/tmp3bdx24kl.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3bdx24kl.cpp:2:\n/tmp/tmp3bdx24kl.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3bdx24kl.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3bdx24kl.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3bdx24kl.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3bdx24kl.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3bdx24kl.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else if(islower(it->first[0]))\n            is_lower = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuayvfhoy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuayvfhoy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpuayvfhoy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpuayvfhoy.cpp: In function 'int main()':\n/tmp/tmpuayvfhoy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuayvfhoy.cpp:2:\n/tmp/tmpuayvfhoy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpuayvfhoy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpuayvfhoy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpu"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size() == 0)\n        return false;\n\
    \    bool lower = true;\n    bool upper = true;\n    for(auto it = dict.begin();\
    \ it != dict.end(); it++)\n    {\n        if(islower(it->first[0]))\n        \
    \    upper = false;\n        else if(isupper(it->first[0]))\n            lower\
    \ = false;\n        else\n            return false;\n    }\n    return lower ||\
    \ upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcewhs43d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = false;\n\
    \    bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            lower = true;\n        else\
    \ if(isupper(it->first[0]))\n            upper = true;\n        else\n       \
    \     return false;\n    }\n    return lower ^ upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3n_qzep7.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3n_qzep7.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3n_qzep7.cpp: In function 'int main()':\n/tmp/tmp3n_qzep7.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3n_qzep7.cpp:2:\n/tmp/tmp3n_qzep7.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower =\
    \ true;\n    bool is_upper = true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(islower(it->first[0]))\n            is_upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            is_lower = false;\n        else\n   \
    \         return false;\n    }\n    return is_lower || is_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeal4bo27.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    int upper = 0,\
    \ lower = 0;\n    for(auto it = dict.begin(); it != dict.end(); it++) {\n    \
    \    if(isupper(it->first[0]))\n            upper++;\n        else if(islower(it->first[0]))\n\
    \            lower++;\n        else\n            return false;\n    }\n    if(upper\
    \ == 0 || lower == 0)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ps1vjgn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvk1jfx2s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z')\n\
    \            is_lower = true;\n        else if(it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z')\n            is_upper = true;\n        else\n            return false;\n\
    \    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate =\
    \ check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm1r5xtvy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpm1r5xtvy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpm1r5xtvy.cpp: In function 'int main()':\n/tmp/tmpm1r5xtvy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm1r5xtvy.cpp:2:\n/tmp/tmpm1r5xtvy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool is_upper = false;\n\
    \    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n    }\n    return is_upper ^ is_lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph1usruxr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    std::map<std::string,std::string>::iterator\
    \ it;\n    bool lower=true;\n    bool upper=true;\n    for(it=dict.begin();it!=dict.end();it++){\n\
    \        if(islower(it->first[0]))\n            upper=false;\n        else if(isupper(it->first[0]))\n\
    \            lower=false;\n        else\n            return false;\n    }\n  \
    \  if(lower || upper)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc_g9c53o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    std::string first_key =\
    \ dict.begin()->first;\n    bool is_lower = std::islower(first_key[0]);\n    for(auto\
    \ it = dict.begin(); it != dict.end(); it++) {\n        if(is_lower) {\n     \
    \       if(!std::islower(it->first[0])) return false;\n        } else {\n    \
    \        if(!std::isupper(it->first[0])) return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyorvghwp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            is_upper = false;\n\
    \        if(!islower(it->first[0]))\n            is_lower = false;\n    }\n  \
    \  return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1oil7ozn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1oil7ozn.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp1oil7ozn.cpp: In function 'int main()':\n/tmp/tmp1oil7ozn.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1oil7ozn.cpp:2:\n/tmp/tmp1oil7ozn.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n        if(islower(it->first[0]))\n\
    \        {\n            for(int i=0;i<it->first.length();i++)\n            {\n\
    \                if(!islower(it->first[i]))\n                {\n             \
    \       flag=false;\n                    break;\n                }\n         \
    \   }\n        }\n        else if(isupper(it->first[0]))\n        {\n        \
    \    for(int i=0;i<it->first.length();i++)\n            {\n                if(!isupper(it->first[i]))\n\
    \                {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf429bf06.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_upper =\
    \ true;\n    bool is_lower = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0]))\n            is_lower = false;\n\
    \        else\n            is_upper = false;\n    }\n    return is_upper || is_lower;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7wg1f_cp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = false;\n \
    \   bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0])) lower = true;\n        else if(isupper(it->first[0]))\
    \ upper = true;\n        else return false;\n    }\n    return lower ^ upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4w4de3kp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0])) is_upper = false;\n        if(!islower(it->first[0]))\
    \ is_lower = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptf2ee4g_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool lower=true;\n\
    \    bool upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n  \
    \      if(islower(it->first[0]))\n            upper=false;\n        else\n   \
    \         lower=false;\n    }\n    return lower || upper;\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3rafir88.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyumvzn42.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpyumvzn42.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpyumvzn42.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpyumvzn42.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpyumvzn42.cpp: In function 'int main()':\n/tmp/tmpyumvzn42.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyumvzn42.cpp:2:\n/tmp/tmpyumvzn42.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpyumvzn42.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpyumvzn42.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyumvzn42.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpyumvzn42.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpyumvzn42.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpy"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first.size() == 0) return false;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n        if(isupper(it->first[0])) is_upper = true;\n    }\n\
    \    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_mki4yzz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0]))\n            upper = false;\n        if(!islower(it->first[0]))\n\
    \            lower = false;\n    }\n    return upper || lower;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgn9lxdys.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(all_lower && !islower(it->first[0])) all_lower = false;\n\
    \        if(all_upper && !isupper(it->first[0])) all_upper = false;\n    }\n \
    \   return all_lower || all_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9zdnpwog.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(isupper(it->first[0]))\n            upper = true;\n        else\n\
    \            lower = true;\n    }\n    return upper ^ lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpewv07s22.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n        if(islower(it->first[0]))\n\
    \        {\n            for(int i=0;i<it->first.length();i++)\n            {\n\
    \                if(!islower(it->first[i]))\n                {\n             \
    \       flag=false;\n                    break;\n                }\n         \
    \   }\n        }\n        else if(isupper(it->first[0]))\n        {\n        \
    \    for(int i=0;i<it->first.length();i++)\n            {\n                if(!isupper(it->first[i]))\n\
    \                {\n                    flag=false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf429bf06.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool lower=false,upper=false;\n\
    \    for(auto x:dict){\n        if(islower(x.first[0]))\n            lower=true;\n\
    \        else if(isupper(x.first[0]))\n            upper=true;\n        else\n\
    \            return false;\n    }\n    if(lower && upper)\n        return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7ctrg22g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            is_upper = false;\n\
    \        if(!islower(it->first[0]))\n            is_lower = false;\n    }\n  \
    \  return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1oil7ozn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1oil7ozn.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp1oil7ozn.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp1oil7ozn.cpp: In function 'int main()':\n/tmp/tmp1oil7ozn.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1oil7ozn.cpp:2:\n/tmp/tmp1oil7ozn.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1oil7ozn.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1oil7ozn.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n\
    \            is_upper = true;\n        else if(it->first[0] >= 'a' && it->first[0]\
    \ <= 'z')\n            is_lower = true;\n        else\n            return false;\n\
    \    }\n    if(is_upper && is_lower)\n        return false;\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiod6kvem.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool all_lower\
    \ = true;\n    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            all_upper = false;\n\
    \        if(!islower(it->first[0]))\n            all_lower = false;\n    }\n \
    \   return all_lower || all_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpheeznzyw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(isupper(it->first[0]))\n            lower = false;\n        else\n\
    \            upper = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7d528q_a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // your code here\n    if(dict.size()==0)\n        return false;\n\
    \    bool flag = true;\n    for(auto i:dict){\n        if(i.first[0]>='a' && i.first[0]<='z'){\n\
    \            for(int j=0;j<i.first.length();j++){\n                if(i.first[j]<'a'\
    \ || i.first[j]>'z'){\n                    flag = false;\n                   \
    \ break;\n                }\n            }\n        }\n        else if(i.first[0]>='A'\
    \ && i.first[0]<='Z'){\n            for(int j=0;j<i.first.length();j++){\n   \
    \             if(i.first[j]<'A' || i.first[j]>'Z'){\n                    flag\
    \ = false;\n                    break;\n                }\n            }\n   \
    \     }\n        else{\n            flag = false;\n            break;\n      \
    \  }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwz5wqxha.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = false;\n \
    \   bool upper = false;\n    for(std::map<std::string,std::string>::iterator it\
    \ = dict.begin(); it != dict.end(); it++) {\n        if(islower(it->first[0]))\
    \ {\n            lower = true;\n        } else if(isupper(it->first[0])) {\n \
    \           upper = true;\n        } else {\n            return false;\n     \
    \   }\n    }\n    return lower ^ upper;\n}\nint main() {\n    auto candidate =\
    \ check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx48zdmaz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdmn5qdoa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = true;\n  \
    \  bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0])) upper = false;\n        if(isupper(it->first[0]))\
    \ lower = false;\n    }\n    return lower || upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_b2cs0m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z')\n\
    \            is_lower = true;\n        else if(it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z')\n            is_upper = true;\n        else\n            return false;\n\
    \    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate =\
    \ check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm1r5xtvy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpm1r5xtvy.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpm1r5xtvy.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpm1r5xtvy.cpp: In function 'int main()':\n/tmp/tmpm1r5xtvy.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm1r5xtvy.cpp:2:\n/tmp/tmpm1r5xtvy.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpm1r5xtvy.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpm1r5xtvy.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else\n            is_lower = true;\n    }\n    return (is_lower\
    \ && !is_upper) || (!is_lower && is_upper);\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxy362m8h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_lower = true;\n\
    \        } else if(isupper(it->first[0])) {\n            is_upper = true;\n  \
    \      } else {\n            return false;\n        }\n    }\n    return (is_lower\
    \ && !is_upper) || (!is_lower && is_upper);\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptv56lwgt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdmn5qdoa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return upper || lower;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1x23c57r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool lower=true;\n\
    \    bool upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n  \
    \      if(islower(it->first[0]))\n            upper=false;\n        else if(isupper(it->first[0]))\n\
    \            lower=false;\n        else\n            return false;\n    }\n  \
    \  if(lower || upper)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn3cs9uh4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            lower = false;\n        else\n      \
    \      return false;\n    }\n    return lower || upper;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpel9w83am.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpel9w83am.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpel9w83am.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpel9w83am.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpel9w83am.cpp: In function 'int main()':\n/tmp/tmpel9w83am.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpel9w83am.cpp:2:\n/tmp/tmpel9w83am.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpel9w83am.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpel9w83am.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpel9w83am.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpe"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(is_lower && !is_upper) {\n            if(!isupper(it->first[0]))\n\
    \                return false;\n        }\n        else if(!is_lower && is_upper)\
    \ {\n            if(!islower(it->first[0]))\n                return false;\n \
    \       }\n        else {\n            if(islower(it->first[0]))\n           \
    \     is_upper = false;\n            else if(isupper(it->first[0]))\n        \
    \        is_lower = false;\n            else\n                return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_6ou8xpp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    std::string first_key =\
    \ dict.begin()->first;\n    bool is_lower = false;\n    bool is_upper = false;\n\
    \    if(first_key[0] >= 'a' && first_key[0] <= 'z') {\n        is_lower = true;\n\
    \    } else if(first_key[0] >= 'A' && first_key[0] <= 'Z') {\n        is_upper\
    \ = true;\n    } else {\n        return false;\n    }\n    for(auto it = dict.begin();\
    \ it != dict.end(); it++) {\n        std::string key = it->first;\n        if(is_lower)\
    \ {\n            if(key[0] < 'a' || key[0] > 'z') {\n                return false;\n\
    \            }\n        } else if(is_upper) {\n            if(key[0] < 'A' ||\
    \ key[0] > 'Z') {\n                return false;\n            }\n        }\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3nvl6u3k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_upper = false;\n        } else if(it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z') {\n            is_lower = false;\n        } else {\n            return\
    \ false;\n        }\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5ji3355m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        std::string key = it->first;\n        for(int i = 0; i < key.size();\
    \ i++) {\n            if(isupper(key[i])) is_lower = false;\n            if(islower(key[i]))\
    \ is_upper = false;\n        }\n    }\n    return is_lower || is_upper;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa7qegx2g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            lower = false;\n        else\n      \
    \      return false;\n    }\n    return (lower || upper);\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96cfnonm.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp96cfnonm.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp96cfnonm.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp96cfnonm.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp96cfnonm.cpp: In function 'int main()':\n/tmp/tmp96cfnonm.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96cfnonm.cpp:2:\n/tmp/tmp96cfnonm.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp96cfnonm.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp96cfnonm.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp96cfnonm.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp96cfnonm.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp96cfnonm.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp9"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto i=dict.begin();i!=dict.end();i++)\n    {\n        if(i->first[0]>='a'\
    \ && i->first[0]<='z')\n        {\n            for(int j=0;j<i->first.length();j++)\n\
    \            {\n                if(i->first[j]<'a' || i->first[j]>'z')\n     \
    \           {\n                    flag=false;\n                    break;\n \
    \               }\n            }\n        }\n        else if(i->first[0]>='A'\
    \ && i->first[0]<='Z')\n        {\n            for(int j=0;j<i->first.length();j++)\n\
    \            {\n                if(i->first[j]<'A' || i->first[j]>'Z')\n     \
    \           {\n                    flag=false;\n                    break;\n \
    \               }\n            }\n        }\n        else\n        {\n       \
    \     flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw2q6dh3s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto i : dict) {\n        if(islower(i.first[0]))\n\
    \            lower = true;\n        else\n            upper = true;\n    }\n \
    \   return (upper && lower) ? false : true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcciryiqn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool lower=true;\n    bool\
    \ upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n        if(islower(it->first[0]))\
    \ upper=false;\n        else lower=false;\n    }\n    return lower || upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjt1s5737.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!islower(it->first[0]))\n            lower = false;\n        if(!isupper(it->first[0]))\n\
    \            upper = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps005u_mx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_lower = true;\n        } else if(it->first[0] >= 'A' && it->first[0] <=\
    \ 'Z') {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdlpb0u8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzdlpb0u8.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpzdlpb0u8.cpp: In function 'int main()':\n/tmp/tmpzdlpb0u8.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdlpb0u8.cpp:2:\n/tmp/tmpzdlpb0u8.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_88karc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return upper || lower;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2pao8zle.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_lower = true;\n        } else if(it->first[0] >= 'A' && it->first[0] <=\
    \ 'Z') {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdlpb0u8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzdlpb0u8.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpzdlpb0u8.cpp: In function 'int main()':\n/tmp/tmpzdlpb0u8.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdlpb0u8.cpp:2:\n/tmp/tmpzdlpb0u8.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n\tif(dict.size() == 0)\n\t\treturn false;\n\tbool is_lower = false;\n\
    \tbool is_upper = false;\n\tfor(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n\t\tif(islower(it->first[0]))\n\t\t\tis_lower = true;\n\t\telse if(isupper(it->first[0]))\n\
    \t\t\tis_upper = true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa7yizyr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first.length() == 0)\n            return\
    \ false;\n        if(isupper(it->first[0]))\n            is_upper = true;\n  \
    \      else\n            is_lower = true;\n    }\n    if(is_lower && is_upper)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp08w1inkk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool lower = true;\n    bool upper = true;\n    for (auto it =\
    \ dict.begin(); it != dict.end(); it++) {\n        if (islower(it->first[0]))\
    \ {\n            upper = false;\n        } else if (isupper(it->first[0])) {\n\
    \            lower = false;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return lower || upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8evrl9u1.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8evrl9u1.cpp:20:15: error: 'it' does not\
    \ name a type\n     for (auto it = dict.begin(); it != dict.end(); it++) {\n \
    \              ^\n/tmp/tmp8evrl9u1.cpp:20:34: error: expected ';' before 'it'\n\
    \     for (auto it = dict.begin(); it != dict.end(); it++) {\n               \
    \                   ^\n/tmp/tmp8evrl9u1.cpp:20:34: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8evrl9u1.cpp: In function 'int main()':\n/tmp/tmp8evrl9u1.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8evrl9u1.cpp:2:\n/tmp/tmp8evrl9u1.cpp:33:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8evrl9u1.cpp:33:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8evrl9u1.cpp:33:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8evrl9u1.cpp:33:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8evrl9u1.cpp:33:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8evrl9u1.cpp:33:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    is_lower = true;\n        } else if(it->first[0] >= 'A' && it->first[0] <=\
    \ 'Z') {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdlpb0u8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzdlpb0u8.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpzdlpb0u8.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpzdlpb0u8.cpp: In function 'int main()':\n/tmp/tmpzdlpb0u8.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdlpb0u8.cpp:2:\n/tmp/tmpzdlpb0u8.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzdlpb0u8.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpzdlpb0u8.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size()==0)\n        return false;\n\
    \    bool flag=true;\n    for(auto it=dict.begin();it!=dict.end();it++)\n    {\n\
    \        if(it->first[0]>='a' && it->first[0]<='z')\n        {\n            for(int\
    \ i=1;i<it->first.length();i++)\n            {\n                if(it->first[i]<'a'\
    \ || it->first[i]>'z')\n                {\n                    flag=false;\n \
    \                   break;\n                }\n            }\n        }\n    \
    \    else if(it->first[0]>='A' && it->first[0]<='Z')\n        {\n            for(int\
    \ i=1;i<it->first.length();i++)\n            {\n                if(it->first[i]<'A'\
    \ || it->first[i]>'Z')\n                {\n                    flag=false;\n \
    \                   break;\n                }\n            }\n        }\n    \
    \    else\n        {\n            flag=false;\n            break;\n        }\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8tdgbl79.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_lower = false;\n\
    \        }\n        else {\n            is_upper = false;\n        }\n    }\n\
    \    return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwwomuz_d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = true;\n\
    \    bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0]))\n            upper = false;\n        if(!islower(it->first[0]))\n\
    \            lower = false;\n    }\n    return upper || lower;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgn9lxdys.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n        \
    \    all_upper = false;\n        } else if(it->first[0] >= 'A' && it->first[0]\
    \ <= 'Z') {\n            all_lower = false;\n        } else {\n            return\
    \ false;\n        }\n    }\n    return all_lower || all_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpigd439d5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower=false;\n\
    \    bool is_upper=false;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(islower(it->first[0]))\n            is_lower=true;\n        else if(isupper(it->first[0]))\n\
    \            is_upper=true;\n        else\n            return false;\n    }\n\
    \    if(is_lower && is_upper)\n        return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv5777djv.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpv5777djv.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++){\n         \
    \     ^\n/tmp/tmpv5777djv.cpp:22:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n                              ^\n/tmp/tmpv5777djv.cpp:22:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpv5777djv.cpp: In function\
    \ 'int main()':\n/tmp/tmpv5777djv.cpp:35:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv5777djv.cpp:2:\n/tmp/tmpv5777djv.cpp:36:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpv5777djv.cpp:36:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpv5777djv.cpp:36:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpv5777djv.cpp:36:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpv5777djv.cpp:36:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpv5777djv.cpp:36:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpv5777djv.cpp:36:94"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0])) is_upper = false;\n        if(!islower(it->first[0]))\
    \ is_lower = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptf2ee4g_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) {\n            is_upper = true;\n\
    \        } else {\n            is_lower = true;\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppw9evtkc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmppw9evtkc.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmppw9evtkc.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmppw9evtkc.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmppw9evtkc.cpp: In function 'int main()':\n/tmp/tmppw9evtkc.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw9evtkc.cpp:2:\n/tmp/tmppw9evtkc.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppw9evtkc.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmppw9evtkc.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0])) all_upper = false;\n        if(!islower(it->first[0]))\
    \ all_lower = false;\n    }\n    return all_lower || all_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3adxd0t0.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3adxd0t0.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3adxd0t0.cpp: In function 'int main()':\n/tmp/tmp3adxd0t0.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3adxd0t0.cpp:2:\n/tmp/tmp3adxd0t0.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0) return false;\n    bool is_lower=true;\n   \
    \ bool is_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n  \
    \      if(is_lower){\n            if(isupper(it->first[0])){\n               \
    \ is_lower=false;\n            }\n        }\n        if(is_upper){\n         \
    \   if(islower(it->first[0])){\n                is_upper=false;\n            }\n\
    \        }\n    }\n    return is_lower||is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuns6wtqt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(is_lower && !std::all_of(it->first.begin(), it->first.end(),\
    \ ::islower)) {\n            is_lower = false;\n        }\n        if(is_upper\
    \ && !std::all_of(it->first.begin(), it->first.end(), ::isupper)) {\n        \
    \    is_upper = false;\n        }\n    }\n    return is_lower || is_upper;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpveshff52.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    if(dict.size() == 0)\n        return false;\n\
    \    bool lower = true;\n    bool upper = true;\n    for(auto it = dict.begin();\
    \ it != dict.end(); it++)\n    {\n        if(islower(it->first[0]))\n        \
    \    upper = false;\n        else if(isupper(it->first[0]))\n            lower\
    \ = false;\n        else\n            return false;\n    }\n    return lower ||\
    \ upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcewhs43d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    std::map<std::string,std::string>::iterator\
    \ it;\n    bool is_upper = false;\n    bool is_lower = false;\n    for(it = dict.begin();\
    \ it != dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else if(islower(it->first[0]))\n            is_lower = true;\n\
    \        else\n            return false;\n    }\n    if(is_upper && is_lower)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr9rz4476.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = false;\n \
    \   bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(isupper(it->first[0])) upper = true;\n        else lower = true;\n\
    \    }\n    return (upper && !lower) || (!upper && lower);\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9r6kpshs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    std::map<std::string,std::string>::iterator\
    \ it;\n    bool is_lower = false;\n    bool is_upper = false;\n    for(it = dict.begin();\
    \ it != dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    if(is_lower && is_upper)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpthmnc9d8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\
    \ if(isupper(it->first[0]))\n            lower = false;\n        else\n      \
    \      return false;\n    }\n    return lower || upper;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpel9w83am.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpel9w83am.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpel9w83am.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpel9w83am.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpel9w83am.cpp: In function 'int main()':\n/tmp/tmpel9w83am.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpel9w83am.cpp:2:\n/tmp/tmpel9w83am.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpel9w83am.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpel9w83am.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpel9w83am.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpel9w83am.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpe"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_lower = true;\n\
    \        } else if(isupper(it->first[0])) {\n            is_upper = true;\n  \
    \      } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5xuhbb6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpg5xuhbb6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpg5xuhbb6.cpp: In function 'int main()':\n/tmp/tmpg5xuhbb6.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5xuhbb6.cpp:2:\n/tmp/tmpg5xuhbb6.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower=true;\n\
    \    bool is_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(islower(it->first[0]))\n            is_upper=false;\n        else\n\
    \            is_lower=false;\n    }\n    return is_lower||is_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf4io5yiy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n            upper\
    \ = true;\n        else if(it->first[0] >= 'a' && it->first[0] <= 'z')\n     \
    \       lower = true;\n        else\n            return false;\n    }\n    if(upper\
    \ && lower)\n        return false;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkvsusga5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = false;\n \
    \   bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z') {\n            upper\
    \ = true;\n        }\n        else if(it->first[0] >= 'a' && it->first[0] <= 'z')\
    \ {\n            lower = true;\n        }\n        else {\n            return\
    \ false;\n        }\n    }\n    return upper ^ lower;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnoaaydb5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x8emsor.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp8x8emsor.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp8x8emsor.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp8x8emsor.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp8x8emsor.cpp: In function 'int main()':\n/tmp/tmp8x8emsor.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8emsor.cpp:2:\n/tmp/tmp8x8emsor.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8x8emsor.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp8x8emsor.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp8"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = true;\n\
    \    bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            upper = false;\n        else\n\
    \            lower = false;\n    }\n    return lower || upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_88karc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = false;\n\
    \    bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            lower = true;\n        else\
    \ if(isupper(it->first[0]))\n            upper = true;\n        else\n       \
    \     return false;\n    }\n    return lower != upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp220dngrk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) {\n            is_lower = true;\n\
    \        } else if(isupper(it->first[0])) {\n            is_upper = true;\n  \
    \      } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5xuhbb6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpg5xuhbb6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpg5xuhbb6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpg5xuhbb6.cpp: In function 'int main()':\n/tmp/tmpg5xuhbb6.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5xuhbb6.cpp:2:\n/tmp/tmpg5xuhbb6.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpg5xuhbb6.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpg5xuhbb6.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first.size() == 0) return false;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n        if(isupper(it->first[0])) is_upper = true;\n    }\n\
    \    return (is_lower && !is_upper) || (!is_lower && is_upper);\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9mr3fp4u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0])) all_upper = false;\n        if(!islower(it->first[0]))\
    \ all_lower = false;\n    }\n    return all_lower || all_upper;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3adxd0t0.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3adxd0t0.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3adxd0t0.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3adxd0t0.cpp: In function 'int main()':\n/tmp/tmp3adxd0t0.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3adxd0t0.cpp:2:\n/tmp/tmp3adxd0t0.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3adxd0t0.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3adxd0t0.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = true;\n  \
    \  bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0])) upper = false;\n        if(isupper(it->first[0]))\
    \ lower = false;\n    }\n    return lower || upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq_b2cs0m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool isUpper =\
    \ false;\n    bool isLower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0]))\n            isUpper = true;\n  \
    \      else if(islower(it->first[0]))\n            isLower = true;\n        else\n\
    \            return false;\n    }\n    if(isUpper && isLower)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoj011gpp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto i: dict) {\n        if(isupper(i.first[0]))\
    \ {\n            is_upper = true;\n        } else {\n            is_lower = true;\n\
    \        }\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ffmpgx7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return (is_lower && !is_upper)\
    \ || (!is_lower && is_upper);\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa65m2wq4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749104
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_lower = false;\n        if(islower(it->first[0]))\
    \ is_upper = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpch_tp4_n.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpch_tp4_n.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpch_tp4_n.cpp: In function 'int main()':\n/tmp/tmpch_tp4_n.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpch_tp4_n.cpp:2:\n/tmp/tmpch_tp4_n.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n\tif(dict.size() == 0)\n\t\treturn false;\n\tbool is_lower = false;\n\
    \tbool is_upper = false;\n\tfor(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n\t\tif(islower(it->first[0]))\n\t\t\tis_lower = true;\n\t\telse if(isupper(it->first[0]))\n\
    \t\t\tis_upper = true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa7yizyr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = true;\n\
    \    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_lower = false;\n        if(islower(it->first[0]))\
    \ is_upper = false;\n    }\n    return is_lower || is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpch_tp4_n.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpch_tp4_n.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpch_tp4_n.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpch_tp4_n.cpp: In function 'int main()':\n/tmp/tmpch_tp4_n.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpch_tp4_n.cpp:2:\n/tmp/tmpch_tp4_n.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpch_tp4_n.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpch_tp4_n.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!std::all_of(it->first.begin(), it->first.end(), ::islower))\
    \ {\n            all_lower = false;\n        }\n        if(!std::all_of(it->first.begin(),\
    \ it->first.end(), ::isupper)) {\n            all_upper = false;\n        }\n\
    \    }\n    return all_lower || all_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsa3bh92k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = true;\n  \
    \  bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n            upper\
    \ = false;\n        } else if(it->first[0] >= 'A' && it->first[0] <= 'Z') {\n\
    \            lower = false;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return lower || upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwzb62mu2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first.size() == 0) return false;\n        if(it->first[0]\
    \ >= 'a' && it->first[0] <= 'z') is_lower = true;\n        if(it->first[0] >=\
    \ 'A' && it->first[0] <= 'Z') is_upper = true;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx2ebgpc0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46up4u2f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp46up4u2f.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp46up4u2f.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp46up4u2f.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp46up4u2f.cpp: In function 'int main()':\n/tmp/tmp46up4u2f.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46up4u2f.cpp:2:\n/tmp/tmp46up4u2f.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp46up4u2f.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp46up4u2f.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool lower = false;\n\
    \    bool upper = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0]))\n            lower = true;\n        else\
    \ if(isupper(it->first[0]))\n            upper = true;\n        else\n       \
    \     return false;\n    }\n    return lower ^ upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3n_qzep7.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3n_qzep7.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3n_qzep7.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3n_qzep7.cpp: In function 'int main()':\n/tmp/tmp3n_qzep7.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3n_qzep7.cpp:2:\n/tmp/tmp3n_qzep7.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3n_qzep7.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3n_qzep7.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = true;\n  \
    \  bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0])) upper = false;\n        if(!islower(it->first[0]))\
    \ lower = false;\n    }\n    return upper || lower;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqyyu_rx6.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqyyu_rx6.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpqyyu_rx6.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpqyyu_rx6.cpp: In function 'int main()':\n/tmp/tmpqyyu_rx6.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqyyu_rx6.cpp:2:\n/tmp/tmpqyyu_rx6.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqyyu_rx6.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpqyyu_rx6.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpq"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto i=dict.begin();i!=dict.end();i++)\n    {\n        if(i->first[0]>='a'\
    \ && i->first[0]<='z')\n        {\n            for(int j=0;j<i->first.length();j++)\n\
    \            {\n                if(i->first[j]<'a' || i->first[j]>'z')\n     \
    \           {\n                    flag=false;\n                    break;\n \
    \               }\n            }\n        }\n        else if(i->first[0]>='A'\
    \ && i->first[0]<='Z')\n        {\n            for(int j=0;j<i->first.length();j++)\n\
    \            {\n                if(i->first[j]<'A' || i->first[j]>'Z')\n     \
    \           {\n                    flag=false;\n                    break;\n \
    \               }\n            }\n        }\n        else\n        {\n       \
    \     flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw2q6dh3s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool upper = false;\n\
    \    bool lower = false;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n            upper\
    \ = true;\n        else if(it->first[0] >= 'a' && it->first[0] <= 'z')\n     \
    \       lower = true;\n        else\n            return false;\n    }\n    if(upper\
    \ && lower)\n        return false;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpaynghix2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_upper=true;\n\
    \    bool is_lower=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(it->first[0]>='a' && it->first[0]<='z')\n            is_upper=false;\n\
    \        else if(it->first[0]>='A' && it->first[0]<='Z')\n            is_lower=false;\n\
    \        else\n            return false;\n    }\n    return is_lower || is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy2_fjkez.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749106
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdmn5qdoa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_upper\
    \ = false;\n    bool is_lower = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(it->first[0] >= 'A' && it->first[0] <= 'Z')\n\
    \            is_upper = true;\n        else if(it->first[0] >= 'a' && it->first[0]\
    \ <= 'z')\n            is_lower = true;\n        else\n            return false;\n\
    \    }\n    if(is_upper && is_lower)\n        return false;\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiod6kvem.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659749105
