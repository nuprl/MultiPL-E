language: cpp
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::vector<std::pair<int, std::string>> roman_numerals = {\n      {1000, \"\
    m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n      {90, \"\
    xc\"},  {50, \"l\"},   {40, \"xl\"}, {10, \"x\"},   {9, \"ix\"},\n      {5, \"\
    v\"},    {4, \"iv\"},   {1, \"i\"}};\n  for (auto roman_numeral : roman_numerals)\
    \ {\n    while (number >= roman_numeral.first) {\n      roman += roman_numeral.second;\n\
    \      number -= roman_numeral.first;\n    }\n  }\n  return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptzixxyaw.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmptzixxyaw.cpp:15:41: error: '>>' should be '> >' within a nested template\
    \ argument list\n   std::vector<std::pair<int, std::string>> roman_numerals =\
    \ {\n                                         ^\n/tmp/tmptzixxyaw.cpp:18:41: error:\
    \ in C++98 'roman_numerals' must be initialized by constructor, not by '{...}'\n\
    \       {5, \"v\"},    {4, \"iv\"},   {1, \"i\"}};\n                         \
    \                ^\n/tmp/tmptzixxyaw.cpp:18:41: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmptzixxyaw.cpp:18:41: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmptzixxyaw.cpp:19:13: error: 'roman_numeral' does not name a type\n\
    \   for (auto roman_numeral : roman_numerals) {\n             ^\n/tmp/tmptzixxyaw.cpp:25:3:\
    \ error: expected ';' before 'return'\n   return roman;\n   ^\n/tmp/tmptzixxyaw.cpp:25:3:\
    \ error: expected primary-expression before 'return'\n/tmp/tmptzixxyaw.cpp:25:3:\
    \ error: expected ';' before 'return'\n/tmp/tmptzixxyaw.cpp:25:3: error: expected\
    \ primary-expression before 'return'\n/tmp/tmptzixxyaw.cpp:25:3: error: expected\
    \ ')' before 'return'\n/tmp/tmptzixxyaw.cpp: In function 'int main()':\n/tmp/tmptzixxyaw.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptzixxyaw.cpp:2:\n/tmp/tmptzixxyaw.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67xq7h_o.cpp: In function 'int main()':\n/tmp/tmp67xq7h_o.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67xq7h_o.cpp:2:\n/tmp/tmp67xq7h_o.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto &i : roman_numerals)\
    \ {\n        while (number >= i.first) {\n            roman += i.second;\n   \
    \         number -= i.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpntclvb5d.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpntclvb5d.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmpntclvb5d.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpntclvb5d.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpntclvb5d.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<long int, std::basic_string<char>\
    \ > >'\n/tmp/tmpntclvb5d.cpp:20:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : roman_numerals) {\n       \
    \         ^\n/tmp/tmpntclvb5d.cpp:20:20: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n     for (auto &i : roman_numerals) {\n             \
    \       ^\n/tmp/tmpntclvb5d.cpp:21:28: error: request for member 'first' in 'i',\
    \ which is of non-class type 'int'\n         while (number >= i.first) {\n   \
    \                         ^\n/tmp/tmpntclvb5d.cpp:22:24: error: request for member\
    \ 'second' in 'i', which is of non-class type 'int'\n             roman += i.second;\n\
    \                        ^\n/tmp/tmpntclvb5d.cpp:23:25: error: request for member\
    \ 'first' in 'i', which is of non-class type 'int'\n             number -= i.first;\n\
    \                         ^\n/tmp/tmpntclvb5d.cpp: In function 'int main()':\n\
    /tmp/tmpntclvb5d.cpp:29:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = int_to_mini_roman;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpntclvb5d.cpp:2:\n/tmp/tmpntclvb5d.cpp:30:26: error:\
    \ 'candi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpumtdd_qm.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpumtdd_qm.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmpumtdd_qm.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpumtdd_qm.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpumtdd_qm.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<long int, std::basic_string<char>\
    \ > >'\n/tmp/tmpumtdd_qm.cpp:20:16: error: ISO C++ forbids declaration of 'roman_numeral'\
    \ with no type [-fpermissive]\n     for (auto& roman_numeral : roman_numerals)\
    \ {\n                ^\n/tmp/tmpumtdd_qm.cpp:20:32: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto& roman_numeral : roman_numerals)\
    \ {\n                                ^\n/tmp/tmpumtdd_qm.cpp:21:40: error: request\
    \ for member 'first' in 'roman_numeral', which is of non-class type 'int'\n  \
    \       while (number >= roman_numeral.first) {\n                            \
    \            ^\n/tmp/tmpumtdd_qm.cpp:22:36: error: request for member 'second'\
    \ in 'roman_numeral', which is of non-class type 'int'\n             roman +=\
    \ roman_numeral.second;\n                                    ^\n/tmp/tmpumtdd_qm.cpp:23:37:\
    \ error: request for member 'first' in 'roman_numeral', which is of non-class\
    \ type 'int'\n             number -= roman_numeral.first;\n                  \
    \                   ^\n/tmp/tmpumtdd_qm.cpp: In function 'int main()':\n/tmp/tmpumtdd_qm.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \           "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx1q1_7fp.cpp: In function 'int main()':\n/tmp/tmpx1q1_7fp.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx1q1_7fp.cpp:2:\n/tmp/tmpx1q1_7fp.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& rn : roman_numerals)\
    \ {\n        while (number >= rn.first) {\n            roman += rn.second;\n \
    \           number -= rn.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcejxjz_9.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpcejxjz_9.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpcejxjz_9.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpcejxjz_9.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpcejxjz_9.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpcejxjz_9.cpp:19:16:\
    \ error: ISO C++ forbids declaration of 'rn' with no type [-fpermissive]\n   \
    \  for (auto& rn : roman_numerals) {\n                ^\n/tmp/tmpcejxjz_9.cpp:19:21:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto&\
    \ rn : roman_numerals) {\n                     ^\n/tmp/tmpcejxjz_9.cpp:20:29:\
    \ error: request for member 'first' in 'rn', which is of non-class type 'int'\n\
    \         while (number >= rn.first) {\n                             ^\n/tmp/tmpcejxjz_9.cpp:21:25:\
    \ error: request for member 'second' in 'rn', which is of non-class type 'int'\n\
    \             roman += rn.second;\n                         ^\n/tmp/tmpcejxjz_9.cpp:22:26:\
    \ error: request for member 'first' in 'rn', which is of non-class type 'int'\n\
    \             number -= rn.first;\n                          ^\n/tmp/tmpcejxjz_9.cpp:\
    \ In function 'int main()':\n/tmp/tmpcejxjz_9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpce"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n\
    \    std::string sym[] = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\",\
    \ \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"};\n    int i = 12;\n    while (number\
    \ > 0) {\n        int div = number / num[i];\n        number = number % num[i];\n\
    \        while (div--) {\n            roman += sym[i];\n        }\n        i--;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7e86jqax.cpp: In function 'int main()':\n/tmp/tmp7e86jqax.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7e86jqax.cpp:2:\n/tmp/tmp7e86jqax.cpp:30:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& p : roman_numerals)\
    \ {\n        while (number >= p.first) {\n            result += p.second;\n  \
    \          number -= p.first;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpexvcqszh.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpexvcqszh.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpexvcqszh.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpexvcqszh.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpexvcqszh.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmpexvcqszh.cpp:20:16: error: ISO C++ forbids declaration of 'p'\
    \ with no type [-fpermissive]\n     for (auto& p : roman_numerals) {\n       \
    \         ^\n/tmp/tmpexvcqszh.cpp:20:20: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n     for (auto& p : roman_numerals) {\n             \
    \       ^\n/tmp/tmpexvcqszh.cpp:21:28: error: request for member 'first' in 'p',\
    \ which is of non-class type 'int'\n         while (number >= p.first) {\n   \
    \                         ^\n/tmp/tmpexvcqszh.cpp:22:25: error: request for member\
    \ 'second' in 'p', which is of non-class type 'int'\n             result += p.second;\n\
    \                         ^\n/tmp/tmpexvcqszh.cpp:23:25: error: request for member\
    \ 'first' in 'p', which is of non-class type 'int'\n             number -= p.first;\n\
    \                         ^\n/tmp/tmpexvcqszh.cpp: In function 'int main()':\n\
    /tmp/tmpexvcqszh.cpp:29:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = int_to_mini_roman;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpexvcqszh.cpp:2:\n/tmp/tmpexvcqszh.cpp:30:26: error:\
    \ 'candidate'"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ydkanuz.cpp: In function 'int main()':\n/tmp/tmp8ydkanuz.cpp:61:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ydkanuz.cpp:2:\n/tmp/tmp8ydkanuz.cpp:62:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    // Write your\
    \ code here\n    std::string roman;\n    int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\n\
    \    std::string sym[] = {\"i\",\"iv\",\"v\",\"ix\",\"x\",\"xl\",\"l\",\"xc\"\
    ,\"c\",\"cd\",\"d\",\"cm\",\"m\"};\n    int i=12;\n    while(number>0)\n    {\n\
    \        int div = number/num[i];\n        number = number%num[i];\n        while(div--)\n\
    \        {\n            roman+=sym[i];\n        }\n        i--;\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpegz2mpg5.cpp: In function 'int main()':\n/tmp/tmpegz2mpg5.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpegz2mpg5.cpp:2:\n/tmp/tmpegz2mpg5.cpp:33:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int i = 0;\n\
    \    while (number > 0) {\n        while (number >= decimal_numerals[i]) {\n \
    \           number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n        i++;\n    }\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyfk_ku__.cpp: In function 'int main()':\n/tmp/tmpyfk_ku__.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyfk_ku__.cpp:2:\n/tmp/tmpyfk_ku__.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman = \"\";\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\",\
    \ \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n\
    \    std::string hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\"\
    , \"mm\", \"mmm\"};\n    roman += thousands[number / 1000];\n    roman += hundreds[(number\
    \ % 1000) / 100];\n    roman += tens[(number % 100) / 10];\n    roman += ones[number\
    \ % 10];\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7phvxnte.cpp: In function 'int main()':\n/tmp/tmp7phvxnte.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7phvxnte.cpp:2:\n/tmp/tmp7phvxnte.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdvc9zmu_.cpp: In function 'int main()':\n/tmp/tmpdvc9zmu_.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdvc9zmu_.cpp:2:\n/tmp/tmpdvc9zmu_.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman = thousands[number / 1000] + hundreds[(number % 1000) / 100] + tens[(number\
    \ % 100) / 10] + ones[number % 10];\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3qncm_aw.cpp: In function 'int main()':\n/tmp/tmp3qncm_aw.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3qncm_aw.cpp:2:\n/tmp/tmp3qncm_aw.cpp:24:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto pair : roman_numerals)\
    \ {\n        while (number >= pair.first) {\n            roman += pair.second;\n\
    \            number -= pair.first;\n        }\n    }\n    return roman;\n}\nint\
    \ main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb1sqadd7.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpb1sqadd7.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpb1sqadd7.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpb1sqadd7.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpb1sqadd7.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpb1sqadd7.cpp:19:15:\
    \ error: 'pair' does not name a type\n     for (auto pair : roman_numerals) {\n\
    \               ^\n/tmp/tmpb1sqadd7.cpp:25:5: error: expected ';' before 'return'\n\
    \     return roman;\n     ^\n/tmp/tmpb1sqadd7.cpp:25:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpb1sqadd7.cpp:25:5: error: expected ';' before 'return'\n\
    /tmp/tmpb1sqadd7.cpp:25:5: error: expected primary-expression before 'return'\n\
    /tmp/tmpb1sqadd7.cpp:25:5: error: expected ')' before 'return'\n/tmp/tmpb1sqadd7.cpp:\
    \ In function 'int main()':\n/tmp/tmpb1sqadd7.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb1sqadd7.cpp:2:\n/tmp/tmpb1sqadd7.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67xq7h_o.cpp: In function 'int main()':\n/tmp/tmp67xq7h_o.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67xq7h_o.cpp:2:\n/tmp/tmp67xq7h_o.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdvc9zmu_.cpp: In function 'int main()':\n/tmp/tmpdvc9zmu_.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdvc9zmu_.cpp:2:\n/tmp/tmpdvc9zmu_.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjzhwafbm.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpjzhwafbm.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpjzhwafbm.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpjzhwafbm.cpp:19:15:\
    \ error: 'roman_numeral' does not name a type\n     for (auto roman_numeral :\
    \ roman_numerals) {\n               ^\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return result;\n     ^\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpjzhwafbm.cpp: In function 'int main()':\n/tmp/tmpjzhwafbm.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjzhwafbm.cpp:2:\n/tmp/tmpjzhwafbm.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    std::string result;\n    std::vector<std::pair<int,\
    \ std::string>> roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"\
    },\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n   \
    \     {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10,\
    \ \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n \
    \       {1, \"i\"},\n    };\n    for (auto roman_numeral : roman_numerals) {\n\
    \        while (number >= roman_numeral.first) {\n            result += roman_numeral.second;\n\
    \            number -= roman_numeral.first;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphhgdwqg0.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmphhgdwqg0.cpp:17:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmphhgdwqg0.cpp:31:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmphhgdwqg0.cpp:31:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmphhgdwqg0.cpp:31:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmphhgdwqg0.cpp:32:15: error: 'roman_numeral' does not name a type\n\
    \     for (auto roman_numeral : roman_numerals) {\n               ^\n/tmp/tmphhgdwqg0.cpp:38:5:\
    \ error: expected ';' before 'return'\n     return result;\n     ^\n/tmp/tmphhgdwqg0.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmphhgdwqg0.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmphhgdwqg0.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmphhgdwqg0.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmphhgdwqg0.cpp: In function 'int main()':\n/tmp/tmphhgdwqg0.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphhgdwqg0.cpp:2:\n/tmp/tmphhgdwqg0.cpp:42:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman_numerals[] = {\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"};\n    int i = 0;\n    while (number > 0) {\n       \
    \ int digit = number % 10;\n        if (digit == 9) {\n            result = roman_numerals[i]\
    \ + roman_numerals[i + 2] + result;\n        } else if (digit == 4) {\n      \
    \      result = roman_numerals[i] + roman_numerals[i + 1] + result;\n        }\
    \ else {\n            if (digit >= 5) {\n                result = roman_numerals[i\
    \ + 1] + result;\n                digit -= 5;\n            }\n            for\
    \ (int j = 0; j < digit; j++) {\n                result = roman_numerals[i] +\
    \ result;\n            }\n        }\n        number /= 10;\n        i += 2;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9d88i0_v.cpp: In function 'int main()':\n/tmp/tmp9d88i0_v.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9d88i0_v.cpp:2:\n/tmp/tmp9d88i0_v.cpp:39:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67xq7h_o.cpp: In function 'int main()':\n/tmp/tmp67xq7h_o.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67xq7h_o.cpp:2:\n/tmp/tmp67xq7h_o.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    std::string result;\n    std::string\
    \ roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[] = {1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0; i < 13; i++) {\n    \
    \    while (number >= values[i]) {\n            number -= values[i];\n       \
    \     result += roman_numerals[i];\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpose3bihm.cpp: In function 'int main()':\n/tmp/tmpose3bihm.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpose3bihm.cpp:2:\n/tmp/tmpose3bihm.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num = number;\n    while(num>0){\n        if(num>=1000){\n \
    \           roman+=\"m\";\n            num-=1000;\n        }\n        else if(num>=900){\n\
    \            roman+=\"cm\";\n            num-=900;\n        }\n        else if(num>=500){\n\
    \            roman+=\"d\";\n            num-=500;\n        }\n        else if(num>=400){\n\
    \            roman+=\"cd\";\n            num-=400;\n        }\n        else if(num>=100){\n\
    \            roman+=\"c\";\n            num-=100;\n        }\n        else if(num>=90){\n\
    \            roman+=\"xc\";\n            num-=90;\n        }\n        else if(num>=50){\n\
    \            roman+=\"l\";\n            num-=50;\n        }\n        else if(num>=40){\n\
    \            roman+=\"xl\";\n            num-=40;\n        }\n        else if(num>=10){\n\
    \            roman+=\"x\";\n            num-=10;\n        }\n        else if(num>=9){\n\
    \            roman+=\"ix\";\n            num-=9;\n        }\n        else if(num>=5){\n\
    \            roman+=\"v\";\n            num-=5;\n        }\n        else if(num>=4){\n\
    \            roman+=\"iv\";\n            num-=4;\n        }\n        else if(num>=1){\n\
    \            roman+=\"i\";\n            num-=1;\n        }\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpytzp1n4o.cpp: In function 'int main()':\n/tmp/tmpytzp1n4o.cpp:73:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpytzp1n4o.cpp:2:\n/tmp/tmpytzp1n4o.cpp:74:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman_numeral;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  \
    \  for (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n   \
    \         number -= values[i];\n            roman_numeral += roman_numerals[i];\n\
    \        }\n    }\n    return roman_numeral;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpldhqxr6y.cpp: In function 'int main()':\n/tmp/tmpldhqxr6y.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpldhqxr6y.cpp:2:\n/tmp/tmpldhqxr6y.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67xq7h_o.cpp: In function 'int main()':\n/tmp/tmp67xq7h_o.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67xq7h_o.cpp:2:\n/tmp/tmp67xq7h_o.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto const &roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph73r6r9b.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmph73r6r9b.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmph73r6r9b.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmph73r6r9b.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmph73r6r9b.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<long int, std::basic_string<char> > >'\n/tmp/tmph73r6r9b.cpp:19:22:\
    \ error: ISO C++ forbids declaration of 'roman_numeral' with no type [-fpermissive]\n\
    \     for (auto const &roman_numeral : roman_numerals) {\n                   \
    \   ^\n/tmp/tmph73r6r9b.cpp:19:38: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto const &roman_numeral : roman_numerals) {\n   \
    \                                   ^\n/tmp/tmph73r6r9b.cpp:20:40: error: request\
    \ for member 'first' in 'roman_numeral', which is of non-class type 'const int'\n\
    \         while (number >= roman_numeral.first) {\n                          \
    \              ^\n/tmp/tmph73r6r9b.cpp:21:36: error: request for member 'second'\
    \ in 'roman_numeral', which is of non-class type 'const int'\n             roman\
    \ += roman_numeral.second;\n                                    ^\n/tmp/tmph73r6r9b.cpp:22:37:\
    \ error: request for member 'first' in 'roman_numeral', which is of non-class\
    \ type 'const int'\n             number -= roman_numeral.first;\n            \
    \                         ^\n/tmp/tmph73r6r9b.cpp: In function 'int main()':\n\
    /tmp/tmph73r6r9b.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = int_to_mini_r"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwaaob158.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpwaaob158.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpwaaob158.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpwaaob158.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpwaaob158.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmpwaaob158.cpp:20:15: error: 'roman_numeral' does not name a type\n\
    \     for (auto roman_numeral : roman_numerals) {\n               ^\n/tmp/tmpwaaob158.cpp:26:5:\
    \ error: expected ';' before 'return'\n     return result;\n     ^\n/tmp/tmpwaaob158.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpwaaob158.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpwaaob158.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpwaaob158.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpwaaob158.cpp: In function 'int main()':\n/tmp/tmpwaaob158.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwaaob158.cpp:2:\n/tmp/tmpwaaob158.cpp:30:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number > 0) {\n        if(number >= 1000) {\n            roman\
    \ += \"m\";\n            number -= 1000;\n        } else if(number >= 900) {\n\
    \            roman += \"cm\";\n            number -= 900;\n        } else if(number\
    \ >= 500) {\n            roman += \"d\";\n            number -= 500;\n       \
    \ } else if(number >= 400) {\n            roman += \"cd\";\n            number\
    \ -= 400;\n        } else if(number >= 100) {\n            roman += \"c\";\n \
    \           number -= 100;\n        } else if(number >= 90) {\n            roman\
    \ += \"xc\";\n            number -= 90;\n        } else if(number >= 50) {\n \
    \           roman += \"l\";\n            number -= 50;\n        } else if(number\
    \ >= 40) {\n            roman += \"xl\";\n            number -= 40;\n        }\
    \ else if(number >= 10) {\n            roman += \"x\";\n            number -=\
    \ 10;\n        } else if(number >= 9) {\n            roman += \"ix\";\n      \
    \      number -= 9;\n        } else if(number >= 5) {\n            roman += \"\
    v\";\n            number -= 5;\n        } else if(number >= 4) {\n           \
    \ roman += \"iv\";\n            number -= 4;\n        } else if(number >= 1) {\n\
    \            roman += \"i\";\n            number -= 1;\n        }\n    }\n   \
    \ return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n  \
    \  assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"\
    ));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1kywfdu6.cpp: In function 'int main()':\n/tmp/tmp1kywfdu6.cpp:60:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1kywfdu6.cpp:2:\n/tmp/tmp1kywfdu6.cpp:61:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk06vm4ya.cpp: In function 'int main()':\n/tmp/tmpk06vm4ya.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk06vm4ya.cpp:2:\n/tmp/tmpk06vm4ya.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ydkanuz.cpp: In function 'int main()':\n/tmp/tmp8ydkanuz.cpp:61:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ydkanuz.cpp:2:\n/tmp/tmp8ydkanuz.cpp:62:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::vector<std::pair<std::string, int>> roman_numerals = {\n      {\"m\",\
    \ 1000}, {\"cm\", 900}, {\"d\", 500}, {\"cd\", 400}, {\"c\", 100},\n      {\"\
    xc\", 90},  {\"l\", 50},   {\"xl\", 40}, {\"x\", 10},   {\"ix\", 9},\n      {\"\
    v\", 5},    {\"iv\", 4},   {\"i\", 1}};\n  for (auto &numeral : roman_numerals)\
    \ {\n    while (number >= numeral.second) {\n      roman += numeral.first;\n \
    \     number -= numeral.second;\n    }\n  }\n  return roman;\n}\nint main() {\n\
    \    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"\
    ));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfk4tqxhn.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpfk4tqxhn.cpp:15:41: error: '>>' should be '> >' within a nested template\
    \ argument list\n   std::vector<std::pair<std::string, int>> roman_numerals =\
    \ {\n                                         ^\n/tmp/tmpfk4tqxhn.cpp:18:41: error:\
    \ in C++98 'roman_numerals' must be initialized by constructor, not by '{...}'\n\
    \       {\"v\", 5},    {\"iv\", 4},   {\"i\", 1}};\n                         \
    \                ^\n/tmp/tmpfk4tqxhn.cpp:18:41: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpfk4tqxhn.cpp:18:41: error: could not convert '{{\"m\", 1000}, {\"cm\"\
    , 900}, {\"d\", 500}, {\"cd\", 400}, {\"c\", 100}, {\"xc\", 90}, {\"l\", 50},\
    \ {\"xl\", 40}, {\"x\", 10}, {\"ix\", 9}, {\"v\", 5}, {\"iv\", 4}, {\"i\", 1}}'\
    \ from '<brace-enclosed initializer list>' to 'std::vector<std::pair<std::basic_string<char>,\
    \ int> >'\n/tmp/tmpfk4tqxhn.cpp:19:14: error: ISO C++ forbids declaration of 'numeral'\
    \ with no type [-fpermissive]\n   for (auto &numeral : roman_numerals) {\n   \
    \           ^\n/tmp/tmpfk4tqxhn.cpp:19:24: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n   for (auto &numeral : roman_numerals) {\n     \
    \                   ^\n/tmp/tmpfk4tqxhn.cpp:20:30: error: request for member 'second'\
    \ in 'numeral', which is of non-class type 'int'\n     while (number >= numeral.second)\
    \ {\n                              ^\n/tmp/tmpfk4tqxhn.cpp:21:24: error: request\
    \ for member 'first' in 'numeral', which is of non-class type 'int'\n       roman\
    \ += numeral.first;\n                        ^\n/tmp/tmpfk4tqxhn.cpp:22:25: error:\
    \ request for member 'second' in 'numeral', which is of non-class type 'int'\n\
    \       number -= numeral.second;\n                         ^\n/tmp/tmpfk4tqxhn.cpp:\
    \ In function 'int main()':\n/tmp/tmpfk4tqxhn.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int values[] = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; i < 13;\
    \ i++) {\n    while (number >= values[i]) {\n      number -= values[i];\n    \
    \  result += roman_numerals[i];\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"\
    ));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7f49wrfg.cpp: In function 'int main()':\n/tmp/tmp7f49wrfg.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7f49wrfg.cpp:2:\n/tmp/tmp7f49wrfg.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>0){\n        if(number>=1000){\n            roman+=\"\
    m\";\n            number-=1000;\n        }\n        else if(number>=900){\n  \
    \          roman+=\"cm\";\n            number-=900;\n        }\n        else if(number>=500){\n\
    \            roman+=\"d\";\n            number-=500;\n        }\n        else\
    \ if(number>=400){\n            roman+=\"cd\";\n            number-=400;\n   \
    \     }\n        else if(number>=100){\n            roman+=\"c\";\n          \
    \  number-=100;\n        }\n        else if(number>=90){\n            roman+=\"\
    xc\";\n            number-=90;\n        }\n        else if(number>=50){\n    \
    \        roman+=\"l\";\n            number-=50;\n        }\n        else if(number>=40){\n\
    \            roman+=\"xl\";\n            number-=40;\n        }\n        else\
    \ if(number>=10){\n            roman+=\"x\";\n            number-=10;\n      \
    \  }\n        else if(number>=9){\n            roman+=\"ix\";\n            number-=9;\n\
    \        }\n        else if(number>=5){\n            roman+=\"v\";\n         \
    \   number-=5;\n        }\n        else if(number>=4){\n            roman+=\"\
    iv\";\n            number-=4;\n        }\n        else if(number>=1){\n      \
    \      roman+=\"i\";\n            number-=1;\n        }\n    }\n    return roman;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp3ipvk9v.cpp: In function 'int main()':\n/tmp/tmpp3ipvk9v.cpp:72:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp3ipvk9v.cpp:2:\n/tmp/tmpp3ipvk9v.cpp:73:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67xq7h_o.cpp: In function 'int main()':\n/tmp/tmp67xq7h_o.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67xq7h_o.cpp:2:\n/tmp/tmp67xq7h_o.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman = thousands[number / 1000] + hundreds[(number % 1000) / 100] + tens[(number\
    \ % 100) / 10] + ones[number % 10];\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3qncm_aw.cpp: In function 'int main()':\n/tmp/tmp3qncm_aw.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3qncm_aw.cpp:2:\n/tmp/tmp3qncm_aw.cpp:24:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_vopudyz.cpp: In function 'int main()':\n/tmp/tmp_vopudyz.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vopudyz.cpp:2:\n/tmp/tmp_vopudyz.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<int> nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1};\n    std::vector<std::string> romans = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  for (int i = 0; i < nums.size(); i++) {\n        while (number >= nums[i])\
    \ {\n            number -= nums[i];\n            roman += romans[i];\n       \
    \ }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxqvwcl8t.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpxqvwcl8t.cpp:15:82: error: in C++98 'nums' must be initialized by constructor,\
    \ not by '{...}'\n     std::vector<int> nums = {1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1};\n                                                 \
    \                                 ^\n/tmp/tmpxqvwcl8t.cpp:15:82: error: could\
    \ not convert '{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}' from '<brace-enclosed\
    \ initializer list>' to 'std::vector<int>'\n/tmp/tmpxqvwcl8t.cpp:16:109: error:\
    \ in C++98 'romans' must be initialized by constructor, not by '{...}'\n     std::vector<std::string>\
    \ romans = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\"\
    , \"ix\", \"v\", \"iv\", \"i\"};\n                                           \
    \                                                                  ^\n/tmp/tmpxqvwcl8t.cpp:16:109:\
    \ error: could not convert '{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::basic_string<char> >'\n/tmp/tmpxqvwcl8t.cpp: In\
    \ function 'int main()':\n/tmp/tmpxqvwcl8t.cpp:26:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxqvwcl8t.cpp:2:\n/tmp/tmpxqvwcl8t.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>=1000){\n        roman+=\"m\";\n        number-=1000;\n\
    \    }\n    if(number>=900){\n        roman+=\"cm\";\n        number-=900;\n \
    \   }\n    if(number>=500){\n        roman+=\"d\";\n        number-=500;\n   \
    \ }\n    if(number>=400){\n        roman+=\"cd\";\n        number-=400;\n    }\n\
    \    while(number>=100){\n        roman+=\"c\";\n        number-=100;\n    }\n\
    \    if(number>=90){\n        roman+=\"xc\";\n        number-=90;\n    }\n   \
    \ if(number>=50){\n        roman+=\"l\";\n        number-=50;\n    }\n    if(number>=40){\n\
    \        roman+=\"xl\";\n        number-=40;\n    }\n    while(number>=10){\n\
    \        roman+=\"x\";\n        number-=10;\n    }\n    if(number>=9){\n     \
    \   roman+=\"ix\";\n        number-=9;\n    }\n    if(number>=5){\n        roman+=\"\
    v\";\n        number-=5;\n    }\n    if(number>=4){\n        roman+=\"iv\";\n\
    \        number-=4;\n    }\n    while(number>=1){\n        roman+=\"i\";\n   \
    \     number-=1;\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6weov8g5.cpp: In function 'int main()':\n/tmp/tmp6weov8g5.cpp:70:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6weov8g5.cpp:2:\n/tmp/tmp6weov8g5.cpp:71:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i89o52i.cpp: In function 'int main()':\n/tmp/tmp2i89o52i.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2i89o52i.cpp:2:\n/tmp/tmp2i89o52i.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgiqf3f5f.cpp: In function 'int main()':\n/tmp/tmpgiqf3f5f.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgiqf3f5f.cpp:2:\n/tmp/tmpgiqf3f5f.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv2tiaewn.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpv2tiaewn.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpv2tiaewn.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpv2tiaewn.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpv2tiaewn.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpv2tiaewn.cpp:19:15:\
    \ error: 'roman_numeral' does not name a type\n     for (auto roman_numeral :\
    \ roman_numerals) {\n               ^\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return roman;\n     ^\n/tmp/tmpv2tiaewn.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpv2tiaewn.cpp: In function 'int main()':\n/tmp/tmpv2tiaewn.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv2tiaewn.cpp:2:\n/tmp/tmpv2tiaewn.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2tvf1c9l.cpp: In function 'int main()':\n/tmp/tmp2tvf1c9l.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2tvf1c9l.cpp:2:\n/tmp/tmp2tvf1c9l.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::string> roman_numerals = {\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"};\n    std::vector<int> numbers = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1};\n    for (int i = 0; i < numbers.size(); i++) {\n        while\
    \ (number >= numbers[i]) {\n            result += roman_numerals[i];\n       \
    \     number -= numbers[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd83c21j8.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpd83c21j8.cpp:15:117: error: in C++98 'roman_numerals' must be initialized\
    \ by constructor, not by '{...}'\n     std::vector<std::string> roman_numerals\
    \ = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"};\n                                                   \
    \                                                                  ^\n/tmp/tmpd83c21j8.cpp:15:117:\
    \ error: could not convert '{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::basic_string<char> >'\n/tmp/tmpd83c21j8.cpp:16:85:\
    \ error: in C++98 'numbers' must be initialized by constructor, not by '{...}'\n\
    \     std::vector<int> numbers = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1};\n                                                                \
    \                     ^\n/tmp/tmpd83c21j8.cpp:16:85: error: could not convert\
    \ '{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}' from '<brace-enclosed\
    \ initializer list>' to 'std::vector<int>'\n/tmp/tmpd83c21j8.cpp: In function\
    \ 'int main()':\n/tmp/tmpd83c21j8.cpp:26:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd83c21j8.cpp:2:\n/tmp/tmpd83c21j8.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto numeral\
    \ : roman_numerals) {\n        while (number >= numeral.first) {\n           \
    \ roman += numeral.second;\n            number -= numeral.first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp10afr0j3.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmp10afr0j3.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmp10afr0j3.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmp10afr0j3.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp10afr0j3.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<long int, std::basic_string<char>\
    \ > >'\n/tmp/tmp10afr0j3.cpp:20:15: error: 'numeral' does not name a type\n  \
    \   for (auto numeral : roman_numerals) {\n               ^\n/tmp/tmp10afr0j3.cpp:26:5:\
    \ error: expected ';' before 'return'\n     return roman;\n     ^\n/tmp/tmp10afr0j3.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp10afr0j3.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp10afr0j3.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp10afr0j3.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp10afr0j3.cpp: In function 'int main()':\n/tmp/tmp10afr0j3.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10afr0j3.cpp:2:\n/tmp/tmp10afr0j3.cpp:30:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\",\
    \ \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int value[] = {1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; number != 0; i++)\
    \ {\n    while (number >= value[i]) {\n      number -= value[i];\n      result\
    \ += roman[i];\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzh7_h566.cpp: In function 'int main()':\n/tmp/tmpzh7_h566.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzh7_h566.cpp:2:\n/tmp/tmpzh7_h566.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2tvf1c9l.cpp: In function 'int main()':\n/tmp/tmp2tvf1c9l.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2tvf1c9l.cpp:2:\n/tmp/tmp2tvf1c9l.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1};\n    std::vector<std::string> numerals = {\"m\", \"cm\", \"\
    d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\
    };\n    for (int i = 0; i < values.size(); i++) {\n        while (number >= values[i])\
    \ {\n            number -= values[i];\n            roman += numerals[i];\n   \
    \     }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2uoxv4a9.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmp2uoxv4a9.cpp:15:84: error: in C++98 'values' must be initialized by constructor,\
    \ not by '{...}'\n     std::vector<int> values = {1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1};\n                                                 \
    \                                   ^\n/tmp/tmp2uoxv4a9.cpp:15:84: error: could\
    \ not convert '{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}' from '<brace-enclosed\
    \ initializer list>' to 'std::vector<int>'\n/tmp/tmp2uoxv4a9.cpp:16:111: error:\
    \ in C++98 'numerals' must be initialized by constructor, not by '{...}'\n   \
    \  std::vector<std::string> numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n                 \
    \                                                                            \
    \                  ^\n/tmp/tmp2uoxv4a9.cpp:16:111: error: could not convert '{\"\
    m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\"}' from '<brace-enclosed initializer list>' to 'std::vector<std::basic_string<char>\
    \ >'\n/tmp/tmp2uoxv4a9.cpp: In function 'int main()':\n/tmp/tmp2uoxv4a9.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2uoxv4a9.cpp:2:\n/tmp/tmp2uoxv4a9.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxosbswu4.cpp: In function 'int main()':\n/tmp/tmpxosbswu4.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxosbswu4.cpp:2:\n/tmp/tmpxosbswu4.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx1q1_7fp.cpp: In function 'int main()':\n/tmp/tmpx1q1_7fp.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx1q1_7fp.cpp:2:\n/tmp/tmpx1q1_7fp.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx1q1_7fp.cpp: In function 'int main()':\n/tmp/tmpx1q1_7fp.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx1q1_7fp.cpp:2:\n/tmp/tmpx1q1_7fp.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjzhwafbm.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpjzhwafbm.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpjzhwafbm.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpjzhwafbm.cpp:19:15:\
    \ error: 'roman_numeral' does not name a type\n     for (auto roman_numeral :\
    \ roman_numerals) {\n               ^\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return result;\n     ^\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpjzhwafbm.cpp: In function 'int main()':\n/tmp/tmpjzhwafbm.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjzhwafbm.cpp:2:\n/tmp/tmpjzhwafbm.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv2tiaewn.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpv2tiaewn.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpv2tiaewn.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpv2tiaewn.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpv2tiaewn.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpv2tiaewn.cpp:19:15:\
    \ error: 'roman_numeral' does not name a type\n     for (auto roman_numeral :\
    \ roman_numerals) {\n               ^\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return roman;\n     ^\n/tmp/tmpv2tiaewn.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpv2tiaewn.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpv2tiaewn.cpp: In function 'int main()':\n/tmp/tmpv2tiaewn.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv2tiaewn.cpp:2:\n/tmp/tmpv2tiaewn.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::vector<std::pair<long, std::string>> roman_numerals = {\n    {1000, \"\
    m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n    {90, \"xc\"\
    }, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n    {4, \"\
    iv\"}, {1, \"i\"}\n  };\n  for (auto &pair : roman_numerals) {\n    while (number\
    \ >= pair.first) {\n      result += pair.second;\n      number -= pair.first;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9rpx_qpt.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmp9rpx_qpt.cpp:15:42: error: '>>' should be '> >' within a nested template\
    \ argument list\n   std::vector<std::pair<long, std::string>> roman_numerals =\
    \ {\n                                          ^\n/tmp/tmp9rpx_qpt.cpp:19:3: error:\
    \ in C++98 'roman_numerals' must be initialized by constructor, not by '{...}'\n\
    \   };\n   ^\n/tmp/tmp9rpx_qpt.cpp:19:3: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp9rpx_qpt.cpp:19:3:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<long int, std::basic_string<char> > >'\n/tmp/tmp9rpx_qpt.cpp:20:14:\
    \ error: ISO C++ forbids declaration of 'pair' with no type [-fpermissive]\n \
    \  for (auto &pair : roman_numerals) {\n              ^\n/tmp/tmp9rpx_qpt.cpp:20:21:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n   for (auto &pair\
    \ : roman_numerals) {\n                     ^\n/tmp/tmp9rpx_qpt.cpp:21:27: error:\
    \ request for member 'first' in 'pair', which is of non-class type 'int'\n   \
    \  while (number >= pair.first) {\n                           ^\n/tmp/tmp9rpx_qpt.cpp:22:22:\
    \ error: request for member 'second' in 'pair', which is of non-class type 'int'\n\
    \       result += pair.second;\n                      ^\n/tmp/tmp9rpx_qpt.cpp:23:22:\
    \ error: request for member 'first' in 'pair', which is of non-class type 'int'\n\
    \       number -= pair.first;\n                      ^\n/tmp/tmp9rpx_qpt.cpp:\
    \ In function 'int main()':\n/tmp/tmp9rpx_qpt.cpp:29:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9rpx_qpt.cpp:2:\n/tmp/tmp9rpx_qpt.cpp:30:26: error:\
    \ 'candidate' w"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ decimals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n   \
    \ for (int i = 0; i < 13; i++) {\n        while (number >= decimals[i]) {\n  \
    \          number -= decimals[i];\n            roman += roman_numerals[i];\n \
    \       }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_xl4l6b9.cpp: In function 'int main()':\n/tmp/tmp_xl4l6b9.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_xl4l6b9.cpp:2:\n/tmp/tmp_xl4l6b9.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i89o52i.cpp: In function 'int main()':\n/tmp/tmp2i89o52i.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2i89o52i.cpp:2:\n/tmp/tmp2i89o52i.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ydkanuz.cpp: In function 'int main()':\n/tmp/tmp8ydkanuz.cpp:61:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ydkanuz.cpp:2:\n/tmp/tmp8ydkanuz.cpp:62:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto numeral : roman_numerals)\
    \ {\n        while (number >= numeral.first) {\n            roman += numeral.second;\n\
    \            number -= numeral.first;\n        }\n    }\n    return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphqjzli9t.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmphqjzli9t.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmphqjzli9t.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmphqjzli9t.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmphqjzli9t.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmphqjzli9t.cpp:19:15:\
    \ error: 'numeral' does not name a type\n     for (auto numeral : roman_numerals)\
    \ {\n               ^\n/tmp/tmphqjzli9t.cpp:25:5: error: expected ';' before 'return'\n\
    \     return roman;\n     ^\n/tmp/tmphqjzli9t.cpp:25:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmphqjzli9t.cpp:25:5: error: expected ';' before 'return'\n\
    /tmp/tmphqjzli9t.cpp:25:5: error: expected primary-expression before 'return'\n\
    /tmp/tmphqjzli9t.cpp:25:5: error: expected ')' before 'return'\n/tmp/tmphqjzli9t.cpp:\
    \ In function 'int main()':\n/tmp/tmphqjzli9t.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = int_to_mini_roman;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphqjzli9t.cpp:2:\n/tmp/tmphqjzli9t.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            result += roman_numerals[i];\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxbuplg7i.cpp: In function 'int main()':\n/tmp/tmpxbuplg7i.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxbuplg7i.cpp:2:\n/tmp/tmpxbuplg7i.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjzhwafbm.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpjzhwafbm.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpjzhwafbm.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpjzhwafbm.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpjzhwafbm.cpp:19:15:\
    \ error: 'roman_numeral' does not name a type\n     for (auto roman_numeral :\
    \ roman_numerals) {\n               ^\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return result;\n     ^\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpjzhwafbm.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpjzhwafbm.cpp: In function 'int main()':\n/tmp/tmpjzhwafbm.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjzhwafbm.cpp:2:\n/tmp/tmpjzhwafbm.cpp:29:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto const& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptnks1sx3.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmptnks1sx3.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmptnks1sx3.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmptnks1sx3.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmptnks1sx3.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmptnks1sx3.cpp:20:22: error: ISO C++ forbids declaration of 'roman_numeral'\
    \ with no type [-fpermissive]\n     for (auto const& roman_numeral : roman_numerals)\
    \ {\n                      ^\n/tmp/tmptnks1sx3.cpp:20:38: error: range-based 'for'\
    \ loops are not allowed in C++98 mode\n     for (auto const& roman_numeral : roman_numerals)\
    \ {\n                                      ^\n/tmp/tmptnks1sx3.cpp:21:40: error:\
    \ request for member 'first' in 'roman_numeral', which is of non-class type 'const\
    \ int'\n         while (number >= roman_numeral.first) {\n                   \
    \                     ^\n/tmp/tmptnks1sx3.cpp:22:37: error: request for member\
    \ 'second' in 'roman_numeral', which is of non-class type 'const int'\n      \
    \       result += roman_numeral.second;\n                                    \
    \ ^\n/tmp/tmptnks1sx3.cpp:23:37: error: request for member 'first' in 'roman_numeral',\
    \ which is of non-class type 'const int'\n             number -= roman_numeral.first;\n\
    \                                     ^\n/tmp/tmptnks1sx3.cpp: In function 'int\
    \ main()':\n/tmp/tmptnks1sx3.cpp:29:10: error: 'candidate' does not name a type\n\
    \     auto candidate = int_to_mini_roman;\n          ^\nIn file included from\
    \ /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::map<int, std::string> roman_map = {\n      {1, \"i\"}, {4, \"iv\"}, {5,\
    \ \"v\"}, {9, \"ix\"}, {10, \"x\"}, {40, \"xl\"},\n      {50, \"l\"}, {90, \"\
    xc\"}, {100, \"c\"}, {400, \"cd\"}, {500, \"d\"}, {900, \"cm\"},\n      {1000,\
    \ \"m\"}};\n  std::map<int, std::string>::reverse_iterator it;\n  for (it = roman_map.rbegin();\
    \ it != roman_map.rend(); ++it) {\n    while (number >= it->first) {\n      roman\
    \ += it->second;\n      number -= it->first;\n    }\n  }\n  return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6v4ylqzt.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmp6v4ylqzt.cpp:18:18: error: in C++98 'roman_map' must be initialized by\
    \ constructor, not by '{...}'\n       {1000, \"m\"}};\n                  ^\n/tmp/tmp6v4ylqzt.cpp:18:18:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6v4ylqzt.cpp:18:18: error: could not convert '{{1,\
    \ \"i\"}, {4, \"iv\"}, {5, \"v\"}, {9, \"ix\"}, {10, \"x\"}, {40, \"xl\"}, {50,\
    \ \"l\"}, {90, \"xc\"}, {100, \"c\"}, {400, \"cd\"}, {500, \"d\"}, {900, \"cm\"\
    }, {1000, \"m\"}}' from '<brace-enclosed initializer list>' to 'std::map<int,\
    \ std::basic_string<char> >'\n/tmp/tmp6v4ylqzt.cpp: In function 'int main()':\n\
    /tmp/tmp6v4ylqzt.cpp:29:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = int_to_mini_roman;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6v4ylqzt.cpp:2:\n/tmp/tmp6v4ylqzt.cpp:30:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcwm9bpus.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpcwm9bpus.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmpcwm9bpus.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpcwm9bpus.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpcwm9bpus.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<long int, std::basic_string<char>\
    \ > >'\n/tmp/tmpcwm9bpus.cpp:20:15: error: 'roman_numeral' does not name a type\n\
    \     for (auto roman_numeral : roman_numerals) {\n               ^\n/tmp/tmpcwm9bpus.cpp:26:5:\
    \ error: expected ';' before 'return'\n     return roman;\n     ^\n/tmp/tmpcwm9bpus.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpcwm9bpus.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpcwm9bpus.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpcwm9bpus.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpcwm9bpus.cpp: In function 'int main()':\n/tmp/tmpcwm9bpus.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcwm9bpus.cpp:2:\n/tmp/tmpcwm9bpus.cpp:30:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n  \
    \  for (auto roman_numeral : roman_numerals) {\n        while (number >= roman_numeral.first)\
    \ {\n            result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpko53zplx.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpko53zplx.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpko53zplx.cpp:29:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpko53zplx.cpp:29:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpko53zplx.cpp:29:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmpko53zplx.cpp:30:15: error: 'roman_numeral' does not name a type\n\
    \     for (auto roman_numeral : roman_numerals) {\n               ^\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected ';' before 'return'\n     return result;\n     ^\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpko53zplx.cpp:36:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpko53zplx.cpp:36:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpko53zplx.cpp: In function 'int main()':\n/tmp/tmpko53zplx.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpko53zplx.cpp:2:\n/tmp/tmpko53zplx.cpp:40:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk06vm4ya.cpp: In function 'int main()':\n/tmp/tmpk06vm4ya.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk06vm4ya.cpp:2:\n/tmp/tmpk06vm4ya.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgiqf3f5f.cpp: In function 'int main()':\n/tmp/tmpgiqf3f5f.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgiqf3f5f.cpp:2:\n/tmp/tmpgiqf3f5f.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpumtdd_qm.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpumtdd_qm.cpp:15:44: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<long, std::string>> roman_numerals\
    \ = {\n                                            ^\n/tmp/tmpumtdd_qm.cpp:19:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpumtdd_qm.cpp:19:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpumtdd_qm.cpp:19:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<long int, std::basic_string<char>\
    \ > >'\n/tmp/tmpumtdd_qm.cpp:20:16: error: ISO C++ forbids declaration of 'roman_numeral'\
    \ with no type [-fpermissive]\n     for (auto& roman_numeral : roman_numerals)\
    \ {\n                ^\n/tmp/tmpumtdd_qm.cpp:20:32: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto& roman_numeral : roman_numerals)\
    \ {\n                                ^\n/tmp/tmpumtdd_qm.cpp:21:40: error: request\
    \ for member 'first' in 'roman_numeral', which is of non-class type 'int'\n  \
    \       while (number >= roman_numeral.first) {\n                            \
    \            ^\n/tmp/tmpumtdd_qm.cpp:22:36: error: request for member 'second'\
    \ in 'roman_numeral', which is of non-class type 'int'\n             roman +=\
    \ roman_numeral.second;\n                                    ^\n/tmp/tmpumtdd_qm.cpp:23:37:\
    \ error: request for member 'first' in 'roman_numeral', which is of non-class\
    \ type 'int'\n             number -= roman_numeral.first;\n                  \
    \                   ^\n/tmp/tmpumtdd_qm.cpp: In function 'int main()':\n/tmp/tmpumtdd_qm.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \           "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n  \
    \  for (auto roman_numeral : roman_numerals) {\n        while (number >= roman_numeral.first)\
    \ {\n            result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpko53zplx.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpko53zplx.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpko53zplx.cpp:29:5:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n     };\n     ^\n/tmp/tmpko53zplx.cpp:29:5: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpko53zplx.cpp:29:5: error: could not convert '{{1000, \"m\"}, {900, \"\
    cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40,\
    \ \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from\
    \ '<brace-enclosed initializer list>' to 'std::vector<std::pair<int, std::basic_string<char>\
    \ > >'\n/tmp/tmpko53zplx.cpp:30:15: error: 'roman_numeral' does not name a type\n\
    \     for (auto roman_numeral : roman_numerals) {\n               ^\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected ';' before 'return'\n     return result;\n     ^\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpko53zplx.cpp:36:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpko53zplx.cpp:36:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpko53zplx.cpp:36:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpko53zplx.cpp: In function 'int main()':\n/tmp/tmpko53zplx.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpko53zplx.cpp:2:\n/tmp/tmpko53zplx.cpp:40:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk06vm4ya.cpp: In function 'int main()':\n/tmp/tmpk06vm4ya.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk06vm4ya.cpp:2:\n/tmp/tmpk06vm4ya.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>0){\n        if(number>=1000){\n            roman+=\"\
    m\";\n            number-=1000;\n        }\n        else if(number>=900){\n  \
    \          roman+=\"cm\";\n            number-=900;\n        }\n        else if(number>=500){\n\
    \            roman+=\"d\";\n            number-=500;\n        }\n        else\
    \ if(number>=400){\n            roman+=\"cd\";\n            number-=400;\n   \
    \     }\n        else if(number>=100){\n            roman+=\"c\";\n          \
    \  number-=100;\n        }\n        else if(number>=90){\n            roman+=\"\
    xc\";\n            number-=90;\n        }\n        else if(number>=50){\n    \
    \        roman+=\"l\";\n            number-=50;\n        }\n        else if(number>=40){\n\
    \            roman+=\"xl\";\n            number-=40;\n        }\n        else\
    \ if(number>=10){\n            roman+=\"x\";\n            number-=10;\n      \
    \  }\n        else if(number>=9){\n            roman+=\"ix\";\n            number-=9;\n\
    \        }\n        else if(number>=5){\n            roman+=\"v\";\n         \
    \   number-=5;\n        }\n        else if(number>=4){\n            roman+=\"\
    iv\";\n            number-=4;\n        }\n        else if(number>=1){\n      \
    \      roman+=\"i\";\n            number-=1;\n        }\n    }\n    return roman;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp3ipvk9v.cpp: In function 'int main()':\n/tmp/tmpp3ipvk9v.cpp:72:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp3ipvk9v.cpp:2:\n/tmp/tmpp3ipvk9v.cpp:73:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd1pabvvy.cpp: In function 'int main()':\n/tmp/tmpd1pabvvy.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = int_to_mini_roman;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd1pabvvy.cpp:2:\n/tmp/tmpd1pabvvy.cpp:27:26: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((19)) == (\"\
    xix\"));\n                          ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& [num, roman]\
    \ : roman_numerals) {\n        while (number >= num) {\n            result +=\
    \ roman;\n            number -= num;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdnjhwvs4.cpp: In function 'std::string int_to_mini_roman(long int)':\n\
    /tmp/tmpdnjhwvs4.cpp:15:43: error: '>>' should be '> >' within a nested template\
    \ argument list\n     std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n                                           ^\n/tmp/tmpdnjhwvs4.cpp:18:28:\
    \ error: in C++98 'roman_numerals' must be initialized by constructor, not by\
    \ '{...}'\n         {4, \"iv\"}, {1, \"i\"}};\n                            ^\n\
    /tmp/tmpdnjhwvs4.cpp:18:28: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpdnjhwvs4.cpp:18:28:\
    \ error: could not convert '{{1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400,\
    \ \"cd\"}, {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\
    \ {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}}' from '<brace-enclosed initializer\
    \ list>' to 'std::vector<std::pair<int, std::basic_string<char> > >'\n/tmp/tmpdnjhwvs4.cpp:19:16:\
    \ error: expected unqualified-id before '[' token\n     for (auto& [num, roman]\
    \ : roman_numerals) {\n                ^\n/tmp/tmpdnjhwvs4.cpp:19:16: error: expected\
    \ ';' before '[' token\n/tmp/tmpdnjhwvs4.cpp:19:17: error: 'num' was not declared\
    \ in this scope\n     for (auto& [num, roman] : roman_numerals) {\n          \
    \       ^\n/tmp/tmpdnjhwvs4.cpp:19:22: error: 'roman' was not declared in this\
    \ scope\n     for (auto& [num, roman] : roman_numerals) {\n                  \
    \    ^\n/tmp/tmpdnjhwvs4.cpp: In lambda function:\n/tmp/tmpdnjhwvs4.cpp:19:29:\
    \ error: expected '{' before ':' token\n     for (auto& [num, roman] : roman_numerals)\
    \ {\n                             ^\n/tmp/tmpdnjhwvs4.cpp: In function 'std::string\
    \ int_to_mini_roman(long int)':\n/tmp/tmpdnjhwvs4.cpp:19:29: warning: lambda expressions\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpdnjhwvs4.cpp:19:29:\
    \ error: expected ';' before ':' token\n/tmp/tmpdnjhwvs4.cpp:19:29: error: expected\
    \ primary-expression before ':' token\n/tmp/tmpdnjhwvs4.cpp:19:29: error: expected\
    \ ')' before ':' token\n/tmp/tmpdnjhwvs4.cpp:19:29: error: expected primary-expressi"
  stdout: ''
