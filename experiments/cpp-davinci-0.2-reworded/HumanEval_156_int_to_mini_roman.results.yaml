language: cpp
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::vector<std::pair<int, std::string>> roman_numerals = {\n      {1000, \"\
    m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n      {90, \"\
    xc\"},  {50, \"l\"},   {40, \"xl\"}, {10, \"x\"},   {9, \"ix\"},\n      {5, \"\
    v\"},    {4, \"iv\"},   {1, \"i\"}};\n  for (auto roman_numeral : roman_numerals)\
    \ {\n    while (number >= roman_numeral.first) {\n      roman += roman_numeral.second;\n\
    \      number -= roman_numeral.first;\n    }\n  }\n  return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto &i : roman_numerals)\
    \ {\n        while (number >= i.first) {\n            roman += i.second;\n   \
    \         number -= i.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& rn : roman_numerals)\
    \ {\n        while (number >= rn.first) {\n            roman += rn.second;\n \
    \           number -= rn.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n\
    \    std::string sym[] = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\",\
    \ \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"};\n    int i = 12;\n    while (number\
    \ > 0) {\n        int div = number / num[i];\n        number = number % num[i];\n\
    \        while (div--) {\n            roman += sym[i];\n        }\n        i--;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& p : roman_numerals)\
    \ {\n        while (number >= p.first) {\n            result += p.second;\n  \
    \          number -= p.first;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    // Write your\
    \ code here\n    std::string roman;\n    int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\n\
    \    std::string sym[] = {\"i\",\"iv\",\"v\",\"ix\",\"x\",\"xl\",\"l\",\"xc\"\
    ,\"c\",\"cd\",\"d\",\"cm\",\"m\"};\n    int i=12;\n    while(number>0)\n    {\n\
    \        int div = number/num[i];\n        number = number%num[i];\n        while(div--)\n\
    \        {\n            roman+=sym[i];\n        }\n        i--;\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int i = 0;\n\
    \    while (number > 0) {\n        while (number >= decimal_numerals[i]) {\n \
    \           number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n        i++;\n    }\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman = \"\";\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\",\
    \ \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n\
    \    std::string hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\"\
    , \"mm\", \"mmm\"};\n    roman += thousands[number / 1000];\n    roman += hundreds[(number\
    \ % 1000) / 100];\n    roman += tens[(number % 100) / 10];\n    roman += ones[number\
    \ % 10];\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman = thousands[number / 1000] + hundreds[(number % 1000) / 100] + tens[(number\
    \ % 100) / 10] + ones[number % 10];\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto pair : roman_numerals)\
    \ {\n        while (number >= pair.first) {\n            roman += pair.second;\n\
    \            number -= pair.first;\n        }\n    }\n    return roman;\n}\nint\
    \ main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    std::string result;\n    std::vector<std::pair<int,\
    \ std::string>> roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"\
    },\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n   \
    \     {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10,\
    \ \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n \
    \       {1, \"i\"},\n    };\n    for (auto roman_numeral : roman_numerals) {\n\
    \        while (number >= roman_numeral.first) {\n            result += roman_numeral.second;\n\
    \            number -= roman_numeral.first;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman_numerals[] = {\"i\", \"v\", \"x\", \"\
    l\", \"c\", \"d\", \"m\"};\n    int i = 0;\n    while (number > 0) {\n       \
    \ int digit = number % 10;\n        if (digit == 9) {\n            result = roman_numerals[i]\
    \ + roman_numerals[i + 2] + result;\n        } else if (digit == 4) {\n      \
    \      result = roman_numerals[i] + roman_numerals[i + 1] + result;\n        }\
    \ else {\n            if (digit >= 5) {\n                result = roman_numerals[i\
    \ + 1] + result;\n                digit -= 5;\n            }\n            for\
    \ (int j = 0; j < digit; j++) {\n                result = roman_numerals[i] +\
    \ result;\n            }\n        }\n        number /= 10;\n        i += 2;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: Exception
  stderr: 'tmpc_dnf2zp: /tmp/tmpc_dnf2zp.cpp:42: int main(): Assertion `candidate((426))
    == ("cdxxvi")'' failed.

    '
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    std::string result;\n    std::string\
    \ roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[] = {1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0; i < 13; i++) {\n    \
    \    while (number >= values[i]) {\n            number -= values[i];\n       \
    \     result += roman_numerals[i];\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num = number;\n    while(num>0){\n        if(num>=1000){\n \
    \           roman+=\"m\";\n            num-=1000;\n        }\n        else if(num>=900){\n\
    \            roman+=\"cm\";\n            num-=900;\n        }\n        else if(num>=500){\n\
    \            roman+=\"d\";\n            num-=500;\n        }\n        else if(num>=400){\n\
    \            roman+=\"cd\";\n            num-=400;\n        }\n        else if(num>=100){\n\
    \            roman+=\"c\";\n            num-=100;\n        }\n        else if(num>=90){\n\
    \            roman+=\"xc\";\n            num-=90;\n        }\n        else if(num>=50){\n\
    \            roman+=\"l\";\n            num-=50;\n        }\n        else if(num>=40){\n\
    \            roman+=\"xl\";\n            num-=40;\n        }\n        else if(num>=10){\n\
    \            roman+=\"x\";\n            num-=10;\n        }\n        else if(num>=9){\n\
    \            roman+=\"ix\";\n            num-=9;\n        }\n        else if(num>=5){\n\
    \            roman+=\"v\";\n            num-=5;\n        }\n        else if(num>=4){\n\
    \            roman+=\"iv\";\n            num-=4;\n        }\n        else if(num>=1){\n\
    \            roman+=\"i\";\n            num-=1;\n        }\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman_numeral;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  \
    \  for (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n   \
    \         number -= values[i];\n            roman_numeral += roman_numerals[i];\n\
    \        }\n    }\n    return roman_numeral;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto const &roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number > 0) {\n        if(number >= 1000) {\n            roman\
    \ += \"m\";\n            number -= 1000;\n        } else if(number >= 900) {\n\
    \            roman += \"cm\";\n            number -= 900;\n        } else if(number\
    \ >= 500) {\n            roman += \"d\";\n            number -= 500;\n       \
    \ } else if(number >= 400) {\n            roman += \"cd\";\n            number\
    \ -= 400;\n        } else if(number >= 100) {\n            roman += \"c\";\n \
    \           number -= 100;\n        } else if(number >= 90) {\n            roman\
    \ += \"xc\";\n            number -= 90;\n        } else if(number >= 50) {\n \
    \           roman += \"l\";\n            number -= 50;\n        } else if(number\
    \ >= 40) {\n            roman += \"xl\";\n            number -= 40;\n        }\
    \ else if(number >= 10) {\n            roman += \"x\";\n            number -=\
    \ 10;\n        } else if(number >= 9) {\n            roman += \"ix\";\n      \
    \      number -= 9;\n        } else if(number >= 5) {\n            roman += \"\
    v\";\n            number -= 5;\n        } else if(number >= 4) {\n           \
    \ roman += \"iv\";\n            number -= 4;\n        } else if(number >= 1) {\n\
    \            roman += \"i\";\n            number -= 1;\n        }\n    }\n   \
    \ return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n  \
    \  assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"\
    ));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::vector<std::pair<std::string, int>> roman_numerals = {\n      {\"m\",\
    \ 1000}, {\"cm\", 900}, {\"d\", 500}, {\"cd\", 400}, {\"c\", 100},\n      {\"\
    xc\", 90},  {\"l\", 50},   {\"xl\", 40}, {\"x\", 10},   {\"ix\", 9},\n      {\"\
    v\", 5},    {\"iv\", 4},   {\"i\", 1}};\n  for (auto &numeral : roman_numerals)\
    \ {\n    while (number >= numeral.second) {\n      roman += numeral.first;\n \
    \     number -= numeral.second;\n    }\n  }\n  return roman;\n}\nint main() {\n\
    \    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"\
    ));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int values[] = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; i < 13;\
    \ i++) {\n    while (number >= values[i]) {\n      number -= values[i];\n    \
    \  result += roman_numerals[i];\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"\
    ));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>0){\n        if(number>=1000){\n            roman+=\"\
    m\";\n            number-=1000;\n        }\n        else if(number>=900){\n  \
    \          roman+=\"cm\";\n            number-=900;\n        }\n        else if(number>=500){\n\
    \            roman+=\"d\";\n            number-=500;\n        }\n        else\
    \ if(number>=400){\n            roman+=\"cd\";\n            number-=400;\n   \
    \     }\n        else if(number>=100){\n            roman+=\"c\";\n          \
    \  number-=100;\n        }\n        else if(number>=90){\n            roman+=\"\
    xc\";\n            number-=90;\n        }\n        else if(number>=50){\n    \
    \        roman+=\"l\";\n            number-=50;\n        }\n        else if(number>=40){\n\
    \            roman+=\"xl\";\n            number-=40;\n        }\n        else\
    \ if(number>=10){\n            roman+=\"x\";\n            number-=10;\n      \
    \  }\n        else if(number>=9){\n            roman+=\"ix\";\n            number-=9;\n\
    \        }\n        else if(number>=5){\n            roman+=\"v\";\n         \
    \   number-=5;\n        }\n        else if(number>=4){\n            roman+=\"\
    iv\";\n            number-=4;\n        }\n        else if(number>=1){\n      \
    \      roman+=\"i\";\n            number-=1;\n        }\n    }\n    return roman;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman = thousands[number / 1000] + hundreds[(number % 1000) / 100] + tens[(number\
    \ % 100) / 10] + ones[number % 10];\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<int> nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1};\n    std::vector<std::string> romans = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  for (int i = 0; i < nums.size(); i++) {\n        while (number >= nums[i])\
    \ {\n            number -= nums[i];\n            roman += romans[i];\n       \
    \ }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>=1000){\n        roman+=\"m\";\n        number-=1000;\n\
    \    }\n    if(number>=900){\n        roman+=\"cm\";\n        number-=900;\n \
    \   }\n    if(number>=500){\n        roman+=\"d\";\n        number-=500;\n   \
    \ }\n    if(number>=400){\n        roman+=\"cd\";\n        number-=400;\n    }\n\
    \    while(number>=100){\n        roman+=\"c\";\n        number-=100;\n    }\n\
    \    if(number>=90){\n        roman+=\"xc\";\n        number-=90;\n    }\n   \
    \ if(number>=50){\n        roman+=\"l\";\n        number-=50;\n    }\n    if(number>=40){\n\
    \        roman+=\"xl\";\n        number-=40;\n    }\n    while(number>=10){\n\
    \        roman+=\"x\";\n        number-=10;\n    }\n    if(number>=9){\n     \
    \   roman+=\"ix\";\n        number-=9;\n    }\n    if(number>=5){\n        roman+=\"\
    v\";\n        number-=5;\n    }\n    if(number>=4){\n        roman+=\"iv\";\n\
    \        number-=4;\n    }\n    while(number>=1){\n        roman+=\"i\";\n   \
    \     number-=1;\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::string> roman_numerals = {\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"};\n    std::vector<int> numbers = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1};\n    for (int i = 0; i < numbers.size(); i++) {\n        while\
    \ (number >= numbers[i]) {\n            result += roman_numerals[i];\n       \
    \     number -= numbers[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto numeral\
    \ : roman_numerals) {\n        while (number >= numeral.first) {\n           \
    \ roman += numeral.second;\n            number -= numeral.first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\",\
    \ \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int value[] = {1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; number != 0; i++)\
    \ {\n    while (number >= value[i]) {\n      number -= value[i];\n      result\
    \ += roman[i];\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1};\n    std::vector<std::string> numerals = {\"m\", \"cm\", \"\
    d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\
    };\n    for (int i = 0; i < values.size(); i++) {\n        while (number >= values[i])\
    \ {\n            number -= values[i];\n            roman += numerals[i];\n   \
    \     }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::vector<std::pair<long, std::string>> roman_numerals = {\n    {1000, \"\
    m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n    {90, \"xc\"\
    }, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n    {4, \"\
    iv\"}, {1, \"i\"}\n  };\n  for (auto &pair : roman_numerals) {\n    while (number\
    \ >= pair.first) {\n      result += pair.second;\n      number -= pair.first;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ decimals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n   \
    \ for (int i = 0; i < 13; i++) {\n        while (number >= decimals[i]) {\n  \
    \          number -= decimals[i];\n            roman += roman_numerals[i];\n \
    \       }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number > 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto numeral : roman_numerals)\
    \ {\n        while (number >= numeral.first) {\n            roman += numeral.second;\n\
    \            number -= numeral.first;\n        }\n    }\n    return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            result += roman_numerals[i];\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto const& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::map<int, std::string> roman_map = {\n      {1, \"i\"}, {4, \"iv\"}, {5,\
    \ \"v\"}, {9, \"ix\"}, {10, \"x\"}, {40, \"xl\"},\n      {50, \"l\"}, {90, \"\
    xc\"}, {100, \"c\"}, {400, \"cd\"}, {500, \"d\"}, {900, \"cm\"},\n      {1000,\
    \ \"m\"}};\n  std::map<int, std::string>::reverse_iterator it;\n  for (it = roman_map.rbegin();\
    \ it != roman_map.rend(); ++it) {\n    while (number >= it->first) {\n      roman\
    \ += it->second;\n      number -= it->first;\n    }\n  }\n  return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n  \
    \  for (auto roman_numeral : roman_numerals) {\n        while (number >= roman_numeral.first)\
    \ {\n            result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n  \
    \  for (auto roman_numeral : roman_numerals) {\n        while (number >= roman_numeral.first)\
    \ {\n            result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>0){\n        if(number>=1000){\n            roman+=\"\
    m\";\n            number-=1000;\n        }\n        else if(number>=900){\n  \
    \          roman+=\"cm\";\n            number-=900;\n        }\n        else if(number>=500){\n\
    \            roman+=\"d\";\n            number-=500;\n        }\n        else\
    \ if(number>=400){\n            roman+=\"cd\";\n            number-=400;\n   \
    \     }\n        else if(number>=100){\n            roman+=\"c\";\n          \
    \  number-=100;\n        }\n        else if(number>=90){\n            roman+=\"\
    xc\";\n            number-=90;\n        }\n        else if(number>=50){\n    \
    \        roman+=\"l\";\n            number-=50;\n        }\n        else if(number>=40){\n\
    \            roman+=\"xl\";\n            number-=40;\n        }\n        else\
    \ if(number>=10){\n            roman+=\"x\";\n            number-=10;\n      \
    \  }\n        else if(number>=9){\n            roman+=\"ix\";\n            number-=9;\n\
    \        }\n        else if(number>=5){\n            roman+=\"v\";\n         \
    \   number-=5;\n        }\n        else if(number>=4){\n            roman+=\"\
    iv\";\n            number-=4;\n        }\n        else if(number>=1){\n      \
    \      roman+=\"i\";\n            number-=1;\n        }\n    }\n    return roman;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& [num, roman]\
    \ : roman_numerals) {\n        while (number >= num) {\n            result +=\
    \ roman;\n            number -= num;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman += thousands[number / 1000];\n    roman += hundreds[(number % 1000)\
    \ / 100];\n    roman += tens[(number % 100) / 10];\n    roman += ones[number %\
    \ 10];\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto &roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& numeral\
    \ : roman_numerals) {\n        while (number >= numeral.first) {\n           \
    \ roman += numeral.second;\n            number -= numeral.first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto const& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int i = 0;\n    while (number != 0) {\n        if (number >= 1000)\
    \ {\n            roman += \"m\";\n            number -= 1000;\n        } else\
    \ if (number >= 900) {\n            roman += \"cm\";\n            number -= 900;\n\
    \        } else if (number >= 500) {\n            roman += \"d\";\n          \
    \  number -= 500;\n        } else if (number >= 400) {\n            roman += \"\
    cd\";\n            number -= 400;\n        } else if (number >= 100) {\n     \
    \       roman += \"c\";\n            number -= 100;\n        } else if (number\
    \ >= 90) {\n            roman += \"xc\";\n            number -= 90;\n        }\
    \ else if (number >= 50) {\n            roman += \"l\";\n            number -=\
    \ 50;\n        } else if (number >= 40) {\n            roman += \"xl\";\n    \
    \        number -= 40;\n        } else if (number >= 10) {\n            roman\
    \ += \"x\";\n            number -= 10;\n        } else if (number >= 9) {\n  \
    \          roman += \"ix\";\n            number -= 9;\n        } else if (number\
    \ >= 5) {\n            roman += \"v\";\n            number -= 5;\n        } else\
    \ if (number >= 4) {\n            roman += \"iv\";\n            number -= 4;\n\
    \        } else if (number >= 1) {\n            roman += \"i\";\n            number\
    \ -= 1;\n        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman = \"\";\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  \
    \  for (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n   \
    \         number -= values[i];\n            roman += roman_numerals[i];\n    \
    \    }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n\
    \    std::string sym[] = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\",\
    \ \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"};\n    int i = 12;\n    while (number\
    \ > 0) {\n        int div = number / num[i];\n        number = number % num[i];\n\
    \        while (div--) {\n            roman += sym[i];\n        }\n        i--;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number>=1000){\n        roman+=\"m\";\n        number-=1000;\n\
    \    }\n    if(number>=900){\n        roman+=\"cm\";\n        number-=900;\n \
    \   }\n    if(number>=500){\n        roman+=\"d\";\n        number-=500;\n   \
    \ }\n    if(number>=400){\n        roman+=\"cd\";\n        number-=400;\n    }\n\
    \    while(number>=100){\n        roman+=\"c\";\n        number-=100;\n    }\n\
    \    if(number>=90){\n        roman+=\"xc\";\n        number-=90;\n    }\n   \
    \ if(number>=50){\n        roman+=\"l\";\n        number-=50;\n    }\n    if(number>=40){\n\
    \        roman+=\"xl\";\n        number-=40;\n    }\n    while(number>=10){\n\
    \        roman+=\"x\";\n        number-=10;\n    }\n    if(number>=9){\n     \
    \   roman+=\"ix\";\n        number-=9;\n    }\n    if(number>=5){\n        roman+=\"\
    v\";\n        number-=5;\n    }\n    if(number>=4){\n        roman+=\"iv\";\n\
    \        number-=4;\n    }\n    while(number>=1){\n        roman+=\"i\";\n   \
    \     number-=1;\n    }\n    return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int i = 0;\n\
    \    while (number > 0) {\n        while (number >= decimal_numerals[i]) {\n \
    \           number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n        i++;\n    }\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            result += roman_numerals[i];\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto numeral : roman_numerals)\
    \ {\n        while (number >= numeral.first) {\n            roman += numeral.second;\n\
    \            number -= numeral.first;\n        }\n    }\n    return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto numeral\
    \ : roman_numerals) {\n        while (number >= numeral.first) {\n           \
    \ roman += numeral.second;\n            number -= numeral.first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ arabic_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_numerals[i])\
    \ {\n            number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int arabic_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= arabic_numerals[i]) {\n        \
    \    number -= arabic_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto &i : roman_numerals)\
    \ {\n        while (number >= i.first) {\n            roman += i.second;\n   \
    \         number -= i.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\n    std::string\
    \ sym[] = {\"i\",\"iv\",\"v\",\"ix\",\"x\",\"xl\",\"l\",\"xc\",\"c\",\"cd\",\"\
    d\",\"cm\",\"m\"};\n    int i=12;\n    while(number>0)\n    {\n        int div\
    \ = number/num[i];\n        number = number%num[i];\n        while(div--)\n  \
    \      {\n            roman+=sym[i];\n        }\n        i--;\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            result += roman_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  while (number > 0) {\n    if (number >= 1000) {\n      roman += \"m\";\n  \
    \    number -= 1000;\n    } else if (number >= 900) {\n      roman += \"cm\";\n\
    \      number -= 900;\n    } else if (number >= 500) {\n      roman += \"d\";\n\
    \      number -= 500;\n    } else if (number >= 400) {\n      roman += \"cd\"\
    ;\n      number -= 400;\n    } else if (number >= 100) {\n      roman += \"c\"\
    ;\n      number -= 100;\n    } else if (number >= 90) {\n      roman += \"xc\"\
    ;\n      number -= 90;\n    } else if (number >= 50) {\n      roman += \"l\";\n\
    \      number -= 50;\n    } else if (number >= 40) {\n      roman += \"xl\";\n\
    \      number -= 40;\n    } else if (number >= 10) {\n      roman += \"x\";\n\
    \      number -= 10;\n    } else if (number >= 9) {\n      roman += \"ix\";\n\
    \      number -= 9;\n    } else if (number >= 5) {\n      roman += \"v\";\n  \
    \    number -= 5;\n    } else if (number >= 4) {\n      roman += \"iv\";\n   \
    \   number -= 4;\n    } else if (number >= 1) {\n      roman += \"i\";\n     \
    \ number -= 1;\n    }\n  }\n  return roman;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    while(number > 0) {\n        if(number >= 1000) {\n            roman\
    \ += \"m\";\n            number -= 1000;\n        } else if(number >= 900) {\n\
    \            roman += \"cm\";\n            number -= 900;\n        } else if(number\
    \ >= 500) {\n            roman += \"d\";\n            number -= 500;\n       \
    \ } else if(number >= 400) {\n            roman += \"cd\";\n            number\
    \ -= 400;\n        } else if(number >= 100) {\n            roman += \"c\";\n \
    \           number -= 100;\n        } else if(number >= 90) {\n            roman\
    \ += \"xc\";\n            number -= 90;\n        } else if(number >= 50) {\n \
    \           roman += \"l\";\n            number -= 50;\n        } else if(number\
    \ >= 40) {\n            roman += \"xl\";\n            number -= 40;\n        }\
    \ else if(number >= 10) {\n            roman += \"x\";\n            number -=\
    \ 10;\n        } else if(number >= 9) {\n            roman += \"ix\";\n      \
    \      number -= 9;\n        } else if(number >= 5) {\n            roman += \"\
    v\";\n            number -= 5;\n        } else if(number >= 4) {\n           \
    \ roman += \"iv\";\n            number -= 4;\n        } else if(number >= 1) {\n\
    \            roman += \"i\";\n            number -= 1;\n        }\n    }\n   \
    \ return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n  \
    \  assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"\
    ));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto const &numeral\
    \ : roman_numerals) {\n        while (number >= numeral.first) {\n           \
    \ roman += numeral.second;\n            number -= numeral.first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& r : roman_numerals)\
    \ {\n        while (number >= r.first) {\n            roman += r.second;\n   \
    \         number -= r.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= decimal_numerals[i]) {\n       \
    \     number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto it = roman_numerals.begin();\
    \ it != roman_numerals.end(); ++it) {\n        while (number >= it->first) {\n\
    \            roman += it->second;\n            number -= it->first;\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman = \"\";\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  int decimal_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1};\n    for (int i = 0; i < 13; i++) {\n        while (number >= decimal_numerals[i])\
    \ {\n            number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n\
    \    std::string sym[] = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\",\
    \ \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"};\n    int i = 12;\n    while (number\
    \ > 0) {\n        int div = number / num[i];\n        number = number % num[i];\n\
    \        while (div--) {\n            roman += sym[i];\n        }\n        i--;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    if(number>=1000){\n        roman+=\"m\";\n        number-=1000;\n\
    \    }\n    if(number>=900){\n        roman+=\"cm\";\n        number-=900;\n \
    \   }\n    if(number>=500){\n        roman+=\"d\";\n        number-=500;\n   \
    \ }\n    if(number>=400){\n        roman+=\"cd\";\n        number-=400;\n    }\n\
    \    if(number>=100){\n        roman+=\"c\";\n        number-=100;\n    }\n  \
    \  if(number>=90){\n        roman+=\"xc\";\n        number-=90;\n    }\n    if(number>=50){\n\
    \        roman+=\"l\";\n        number-=50;\n    }\n    if(number>=40){\n    \
    \    roman+=\"xl\";\n        number-=40;\n    }\n    if(number>=10){\n       \
    \ roman+=\"x\";\n        number-=10;\n    }\n    if(number>=9){\n        roman+=\"\
    ix\";\n        number-=9;\n    }\n    if(number>=5){\n        roman+=\"v\";\n\
    \        number-=5;\n    }\n    if(number>=4){\n        roman+=\"iv\";\n     \
    \   number-=4;\n    }\n    if(number>=1){\n        roman+=\"i\";\n        number-=1;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: Exception
  stderr: 'tmp4c84qend: /tmp/tmp4c84qend.cpp:72: int main(): Assertion `candidate((152))
    == ("clii")'' failed.

    '
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\n    std::string\
    \ sym[] = {\"i\",\"iv\",\"v\",\"ix\",\"x\",\"xl\",\"l\",\"xc\",\"c\",\"cd\",\"\
    d\",\"cm\",\"m\"};\n    int i=12;\n    while(number>0)\n    {\n        int div\
    \ = number/num[i];\n        number = number%num[i];\n        while(div--)\n  \
    \      {\n            roman+=sym[i];\n        }\n        i--;\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman = thousands[number / 1000] + hundreds[(number % 1000) / 100] + tens[(number\
    \ % 100) / 10] + ones[number % 10];\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; i < 13; i++) {\n        while (number >= values[i]) {\n            number\
    \ -= values[i];\n            roman += roman_numerals[i];\n        }\n    }\n \
    \   return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal_numerals[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int i = 0;\n\
    \    while (number > 0) {\n        while (number >= decimal_numerals[i]) {\n \
    \           number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n        i++;\n    }\n    return roman;\n}\nint main() {\n    auto\
    \ candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n\
    \    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"\
    ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n\
    \        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ decimal_numerals[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\
    \    for (int i = 0; i < 13; i++) {\n        while (number >= decimal_numerals[i])\
    \ {\n            number -= decimal_numerals[i];\n            roman += roman_numerals[i];\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[] = {\"i\", \"v\", \"x\", \"l\", \"c\"\
    , \"d\", \"m\"};\n    int decimal_values[] = {1, 5, 10, 50, 100, 500, 1000};\n\
    \    int decimal_place = 0;\n    while (number > 0) {\n        int digit = number\
    \ % 10;\n        if (digit < 4) {\n            roman = std::string(digit, roman_numerals[decimal_place][0])\
    \ + roman;\n        } else if (digit == 4) {\n            roman = roman_numerals[decimal_place][0]\
    \ + roman_numerals[decimal_place + 1] + roman;\n        } else if (digit == 5)\
    \ {\n            roman = roman_numerals[decimal_place + 1] + roman;\n        }\
    \ else if (digit < 9) {\n            roman = std::string(digit - 5, roman_numerals[decimal_place][0])\
    \ + roman_numerals[decimal_place + 1] + roman;\n        } else if (digit == 9)\
    \ {\n            roman = roman_numerals[decimal_place][0] + roman_numerals[decimal_place\
    \ + 2] + roman;\n        }\n        number /= 10;\n        decimal_place += 2;\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: Exception
  stderr: 'tmpo81dh5g5: /tmp/tmpo81dh5g5.cpp:41: int main(): Assertion `candidate((426))
    == ("cdxxvi")'' failed.

    '
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n \
    \       {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto it = roman_numerals.begin();\
    \ it != roman_numerals.end(); ++it) {\n        while (number >= it->first) {\n\
    \            result += it->second;\n            number -= it->first;\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n  \
    \  for (auto rn : roman_numerals) {\n        while (number >= rn.first) {\n  \
    \          result += rn.second;\n            number -= rn.first;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::map<int, std::string> roman_map = {\n        {1, \"i\"},\n\
    \        {5, \"v\"},\n        {10, \"x\"},\n        {50, \"l\"},\n        {100,\
    \ \"c\"},\n        {500, \"d\"},\n        {1000, \"m\"}\n    };\n    std::map<int,\
    \ std::string>::iterator it;\n    int i = 0;\n    while (number > 0) {\n     \
    \   int digit = number % 10;\n        if (digit == 4) {\n            it = roman_map.find(pow(10,\
    \ i));\n            roman = roman_map[it->first] + roman_map[it->first * 5] +\
    \ roman;\n        } else if (digit == 9) {\n            it = roman_map.find(pow(10,\
    \ i));\n            roman = roman_map[it->first] + roman_map[it->first * 10] +\
    \ roman;\n        } else {\n            if (digit >= 5) {\n                it\
    \ = roman_map.find(pow(10, i) * 5);\n                roman = roman_map[it->first]\
    \ + roman;\n                digit -= 5;\n            }\n            while (digit\
    \ > 0) {\n                it = roman_map.find(pow(10, i));\n                roman\
    \ = roman_map[it->first] + roman;\n                digit--;\n            }\n \
    \       }\n        number /= 10;\n        i++;\n    }\n    return roman;\n}\n\
    int main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: Exception
  stderr: 'tmp5zg51by_: /tmp/tmp5zg51by_.cpp:56: int main(): Assertion `candidate((426))
    == ("cdxxvi")'' failed.

    '
  stdout: ''
  timestamp: 1660057580
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result = \"\";\n    std::string roman = \"ivxlcdm\";\n    int i = 0;\n    while\
    \ (number > 0) {\n        int digit = number % 10;\n        if (digit == 9) {\n\
    \            result = roman[i] + roman[i + 2] + result;\n        } else if (digit\
    \ >= 5) {\n            result = roman[i + 1] + std::string(digit - 5, roman[i])\
    \ + result;\n        } else if (digit == 4) {\n            result = roman[i] +\
    \ roman[i + 1] + result;\n        } else {\n            result = std::string(digit,\
    \ roman[i]) + result;\n        }\n        number /= 10;\n        i += 2;\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgp5jx8av.cpp: In function \u2018std::string int_to_mini_roman(long\
    \ int)\u2019:\n/tmp/tmpgp5jx8av.cpp:20:46: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |             result = roman[i] + roman[i + 2] + result;\n      |  \
    \                                            ^ ~~~~~~\n      |               \
    \                                 |\n      |                                 \
    \               std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpgp5jx8av.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpgp5jx8av.cpp:20:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |             result = roman[i] + roman[i + 2] + result;\n      |          \
    \               "
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[4][10] = {\n        {\"\", \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"},\n        {\"\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"},\n      \
    \  {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"},\n        {\"\", \"m\", \"mm\", \"mmm\", \"\", \"\", \"\", \"\", \"\", \"\
    \"}\n    };\n    int i = 0;\n    while (number > 0) {\n        result = roman[i][number\
    \ % 10] + result;\n        number /= 10;\n        i++;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result;\n\
    \  std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\",\
    \ \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int values[] = {1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; i < 13; i++)\
    \ {\n    while (number >= values[i]) {\n      number -= values[i];\n      result\
    \ += roman[i];\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string symbol[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; ++i) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += symbol[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ str;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[] = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0; number\
    \ != 0; i++) {\n        while (number >= decimal[i]) {\n            number -=\
    \ decimal[i];\n            str += roman[i];\n        }\n    }\n    return str;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    std::string result;\n    std::vector<int>\
    \ digits;\n    while (number > 0) {\n        digits.push_back(number % 10);\n\
    \        number /= 10;\n    }\n    std::reverse(digits.begin(), digits.end());\n\
    \    for (int i = 0; i < digits.size(); i++) {\n        if (digits[i] == 0) {\n\
    \            continue;\n        }\n        if (digits[i] < 4) {\n            result\
    \ += std::string(digits[i], \"ixcm\"[i]);\n        } else if (digits[i] == 4)\
    \ {\n            result += \"ixcm\"[i];\n            result += \"ixcm\"[i + 1];\n\
    \        } else if (digits[i] == 5) {\n            result += \"ixcm\"[i + 1];\n\
    \        } else if (digits[i] < 9) {\n            result += \"ixcm\"[i + 1];\n\
    \            result += std::string(digits[i] - 5, \"ixcm\"[i]);\n        } else\
    \ {\n            result += \"ixcm\"[i];\n            result += \"ixcm\"[i + 2];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: Exception
  stderr: 'tmpiqbolqqs: /tmp/tmpiqbolqqs.cpp:46: int main(): Assertion `candidate((19))
    == ("xix")'' failed.

    '
  stdout: ''
  timestamp: 1660057580
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n\
    \  std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int values[] = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  for (int i = 0; i < 13;\
    \ i++) {\n    while (number >= values[i]) {\n      number -= values[i];\n    \
    \  roman += roman_numerals[i];\n    }\n  }\n  return roman;\n}\nint main() {\n\
    \    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"\
    ));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_numerals =\
    \ {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100,\
    \ \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"\
    ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto& rn\
    \ : roman_numerals) {\n        while (number >= rn.first) {\n            roman\
    \ += rn.second;\n            number -= rn.first;\n        }\n    }\n    return\
    \ roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       roman += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::vector<std::pair<long, std::string>> roman_numerals = {\n\
    \        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto roman_numeral\
    \ : roman_numerals) {\n        while (number >= roman_numeral.first) {\n     \
    \       result += roman_numeral.second;\n            number -= roman_numeral.first;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057580
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            result += roman[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numeral[] = {\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int decimal[]\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i =\
    \ 0; number != 0; i++) {\n        while (number >= decimal[i]) {\n           \
    \ number -= decimal[i];\n            roman += roman_numeral[i];\n        }\n \
    \   }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string roman_numerals[13] = {\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int\
    \ values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for\
    \ (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n        \
    \    number -= values[i];\n            roman += roman_numerals[i];\n        }\n\
    \    }\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::string ones[] = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"};\n    std::string tens[] = {\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    std::string\
    \ hundreds[] = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\"};\n    std::string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"\
    };\n    roman += thousands[number / 1000];\n    roman += hundreds[(number % 1000)\
    \ / 100];\n    roman += tens[(number % 100) / 10];\n    roman += ones[number %\
    \ 10];\n    return roman;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n\
    \    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"\
    clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057578
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int value[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ number != 0; i++) {\n        while (number >= value[i]) {\n            number\
    \ -= value[i];\n            result += roman[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman_numeral;\n    std::string roman_numerals[] = {\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  \
    \  int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  \
    \  for (int i = 0; i < 13; i++) {\n        while (number >= values[i]) {\n   \
    \         number -= values[i];\n            roman_numeral += roman_numerals[i];\n\
    \        }\n    }\n    return roman_numeral;\n}\nint main() {\n    auto candidate\
    \ = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152))\
    \ == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426))\
    \ == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1))\
    \ == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43))\
    \ == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94))\
    \ == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900))\
    \ == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000))\
    \ == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057577
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ result;\n    std::string roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int values[] =\
    \ {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0;\
    \ i < 13; i++) {\n        while (number >= values[i]) {\n            number -=\
    \ values[i];\n            result += roman[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19))\
    \ == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057579
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n\
    // Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n\
    // (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n\
    // (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string\
    \ roman;\n    std::vector<std::pair<int, std::string>> roman_numerals = {\n  \
    \      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"\
    },\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"},\
    \ {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}};\n    for (auto& rn : roman_numerals)\
    \ {\n        while (number >= rn.first) {\n            roman += rn.second;\n \
    \           number -= rn.first;\n        }\n    }\n    return roman;\n}\nint main()\
    \ {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"\
    xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251))\
    \ == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500))\
    \ == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4))\
    \ == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90))\
    \ == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532))\
    \ == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994))\
    \ == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057576
