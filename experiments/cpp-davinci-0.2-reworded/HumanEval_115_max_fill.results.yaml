language: cpp
name: HumanEval_115_max_fill
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum/capacity);\n        if(sum%capacity\
    \ != 0)\n            ans++;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    int n = grid.size();\n  \
    \  int m = grid[0].size();\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        int sum = 0;\n        for(int j = 0; j < m; j++){\n            sum +=\
    \ grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpj7o4c045: /tmp/tmpj7o4c045.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ 0));\n    for(long i = 0; i < n; i++) {\n        for(long j = 0; j < m; j++)\
    \ {\n            if(grid[i][j] == 1) {\n                dp[i][j] = 1;\n      \
    \      }\n        }\n    }\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < m; j++) {\n            if(dp[i][j] == 1) {\n                if(i\
    \ > 0) {\n                    dp[i][j] += dp[i-1][j];\n                }\n   \
    \             if(j > 0) {\n                    dp[i][j] += dp[i][j-1];\n     \
    \           }\n                if(i > 0 && j > 0) {\n                    dp[i][j]\
    \ -= dp[i-1][j-1];\n                }\n            }\n        }\n    }\n    long\
    \ ans = 0;\n    for(long i = 0; i < n; i++) {\n        for(long j = 0; j < m;\
    \ j++) {\n            for(long k = i; k < n; k++) {\n                for(long\
    \ l = j; l < m; l++) {\n                    long sum = dp[k][l];\n           \
    \         if(i > 0) {\n                        sum -= dp[i-1][l];\n          \
    \          }\n                    if(j > 0) {\n                        sum -=\
    \ dp[k][j-1];\n                    }\n                    if(i > 0 && j > 0) {\n\
    \                        sum += dp[i-1][j-1];\n                    }\n       \
    \             if(sum <= capacity) {\n                        ans = std::max(ans,\
    \ sum);\n                    }\n                }\n            }\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n   \
    \ assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp3ic7wh13: /tmp/tmp3ic7wh13.cpp:77: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum / capacity);\n        if (sum % capacity != 0) {\n\
    \            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = i; k < n; k++) {\n                \
    \    for (long l = j; l < m; l++) {\n                        if (grid[k][l] ==\
    \ 1) {\n                            grid[k][l] = 0;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp4vfnvf8p: /tmp/tmp4vfnvf8p.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8pamaghv: /tmp/tmp8pamaghv.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long row = grid.size();\n    long col = grid[0].size();\n\
    \    long max_fill = 0;\n    for (long i = 0; i < row; i++) {\n        for (long\
    \ j = 0; j < col; j++) {\n            if (grid[i][j] == 1) {\n               \
    \ max_fill += capacity;\n            }\n        }\n    }\n    return max_fill;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpbj1q03o8: /tmp/tmpbj1q03o8.cpp:40: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpgrq3_1pi: /tmp/tmpgrq3_1pi.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long max_fill = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                max_fill += capacity;\n   \
    \         }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpcf5ix7sp: /tmp/tmpcf5ix7sp.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = i + 1; k < n; k++) {\n            \
    \        if (grid[k][j] == 1) {\n                        grid[k][j] = 0;\n   \
    \                 } else {\n                        break;\n                 \
    \   }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpqgse5kfp: /tmp/tmpqgse5kfp.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans++;\n                grid[i][j] = 0;\n                if(i > 0\
    \ && grid[i-1][j] == 1){\n                    grid[i-1][j] = 0;\n            \
    \    }\n                if(j > 0 && grid[i][j-1] == 1){\n                    grid[i][j-1]\
    \ = 0;\n                }\n                if(i < n-1 && grid[i+1][j] == 1){\n\
    \                    grid[i+1][j] = 0;\n                }\n                if(j\
    \ < m-1 && grid[i][j+1] == 1){\n                    grid[i][j+1] = 0;\n      \
    \          }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpcabwzoou: /tmp/tmpcabwzoou.cpp:53: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long total_water = 0;\n    for (long i = 0; i < rows; i++) {\n        for\
    \ (long j = 0; j < cols; j++) {\n            total_water += grid[i][j];\n    \
    \    }\n    }\n    long water_per_bucket = total_water / capacity;\n    if (total_water\
    \ % capacity != 0) {\n        water_per_bucket++;\n    }\n    return water_per_bucket;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpr98q2zit: /tmp/tmpr98q2zit.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,
    (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1,
    (long)1, (long)1})})), (9)) == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0L, capacity - sum);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpuhjqzmcg: /tmp/tmpuhjqzmcg.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp417jkp7_: /tmp/tmp417jkp7_.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans++;\n\
    \                long cur = capacity;\n                for (long k = i; k < n\
    \ && cur > 0; k++) {\n                    for (long l = j; l < m && cur > 0; l++)\
    \ {\n                        if (grid[k][l] == 1) {\n                        \
    \    grid[k][l] = 0;\n                            cur--;\n                   \
    \     }\n                    }\n                }\n            }\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n   \
    \ assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmprolgaz05: /tmp/tmprolgaz05.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,
    (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1,
    (long)1, (long)1})})), (9)) == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (auto row : grid) {\n\
    \        for (auto cell : row) {\n            if (cell == 1) {\n             \
    \   max_fill += capacity;\n            }\n        }\n    }\n    return max_fill;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpgr2wk7oh: /tmp/tmpgr2wk7oh.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum / capacity;\n        if(sum %\
    \ capacity != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long rows = grid.size();\n\
    \    long cols = grid[0].size();\n    long count = 0;\n    for(long i = 0; i <\
    \ rows; i++){\n        for(long j = 0; j < cols; j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i+1 < rows && grid[i+1][j] == 1){\n                    grid[i+1][j]\
    \ = 0;\n                }\n                if(j+1 < cols && grid[i][j+1] == 1){\n\
    \                    grid[i][j+1] = 0;\n                }\n            }\n   \
    \     }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpixwvzov4: /tmp/tmpixwvzov4.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpj7o4c045: /tmp/tmpj7o4c045.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n            }\n        }\n    }\n    return\
    \ count/capacity;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpfmxaiuf1: /tmp/tmpfmxaiuf1.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long total = 0;\n    for (int i = 0; i < grid.size();\
    \ i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j]\
    \ == 1) {\n                total += capacity;\n            }\n        }\n    }\n\
    \    return total;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8zearhzz: /tmp/tmp8zearhzz.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill_count = 0;\n    for (long i = 0; i\
    \ < grid.size(); i++) {\n        for (long j = 0; j < grid[i].size(); j++) {\n\
    \            if (grid[i][j] == 1) {\n                max_fill_count++;\n     \
    \           if (capacity > 1) {\n                    for (long k = i + 1; k <\
    \ grid.size(); k++) {\n                        if (grid[k][j] == 1) {\n      \
    \                      max_fill_count++;\n                            capacity--;\n\
    \                        }\n                        else {\n                 \
    \           break;\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return max_fill_count;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmprixbuefn: /tmp/tmprixbuefn.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n\t// Your code here\n\tlong n = grid.size();\n\tlong\
    \ m = grid[0].size();\n\tlong ans = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\t\
    long sum = 0;\n\t\tfor (long j = 0; j < m; j++) {\n\t\t\tsum += grid[i][j];\n\t\
    \t}\n\t\tans += (sum / capacity);\n\t\tif (sum % capacity != 0) {\n\t\t\tans++;\n\
    \t\t}\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate = max_fill;\n \
    \   assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum/capacity);\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                grid[i][j] = 0;\n                if (i + 1 < rows\
    \ && grid[i + 1][j] == 1) {\n                    grid[i + 1][j] = 0;\n       \
    \         }\n                if (j + 1 < cols && grid[i][j + 1] == 1) {\n    \
    \                grid[i][j + 1] = 0;\n                }\n            }\n     \
    \   }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpc5hw7a9v: /tmp/tmpc5hw7a9v.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long max_fill = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                max_fill += capacity;\n   \
    \         }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp4y2m8vlm: /tmp/tmp4y2m8vlm.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = 0; k < n; k++) {\n                \
    \    for (long l = 0; l < m; l++) {\n                        if (grid[k][l] ==\
    \ 1) {\n                            ans += std::abs(i - k) + std::abs(j - l);\n\
    \                        }\n                    }\n                }\n       \
    \         return ans;\n            }\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpc5fpwkb1: /tmp/tmpc5fpwkb1.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                if (i > 0) {\n                    grid[i-1][j] =\
    \ 1;\n                }\n                if (j > 0) {\n                    grid[i][j-1]\
    \ = 1;\n                }\n                if (i < rows-1) {\n               \
    \     grid[i+1][j] = 1;\n                }\n                if (j < cols-1) {\n\
    \                    grid[i][j+1] = 1;\n                }\n            }\n   \
    \     }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwa8h15c4: /tmp/tmpwa8h15c4.cpp:51: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                if (i > 0) {\n                    ans -= std::min(capacity,\
    \ grid[i - 1][j]);\n                }\n                if (j > 0) {\n        \
    \            ans -= std::min(capacity, grid[i][j - 1]);\n                }\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp5kdjsx8o: /tmp/tmp5kdjsx8o.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = i + 1; k < n; k++) {\n            \
    \        if (grid[k][j] == 1) {\n                        ans--;\n            \
    \        }\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpemzmm88e: /tmp/tmpemzmm88e.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (auto row : grid) {\n\
    \        long row_fill = 0;\n        for (auto well : row) {\n            if (well\
    \ == 1) {\n                row_fill += capacity;\n            }\n        }\n \
    \       max_fill = std::max(max_fill, row_fill);\n    }\n    return max_fill;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpg1935lkj: /tmp/tmpg1935lkj.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        if (sum > 0) {\n            ans += sum / capacity;\n         \
    \   if (sum % capacity > 0) {\n                ans++;\n            }\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code goes here\n    long n = grid.size();\n\
    \    long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum / capacity;\n        if(sum %\
    \ capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long result = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                result += capacity;\n     \
    \       }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpykjjv622: /tmp/tmpykjjv622.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum + capacity - 1) / capacity;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0l, capacity - sum);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpyhosygyf: /tmp/tmpyhosygyf.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    long\
    \ n = grid.size();\n    long m = grid[0].size();\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        if(sum > 0){\n            count += sum/capacity;\n\
    \            if(sum%capacity != 0){\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0l, (sum - capacity));\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp_t9niulm: /tmp/tmp_t9niulm.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ 1;\n                grid[i][j] = 0;\n                std::queue<std::pair<long,\
    \ long>> q;\n                q.push({i, j});\n                while (!q.empty())\
    \ {\n                    auto [x, y] = q.front();\n                    q.pop();\n\
    \                    if (x > 0 && grid[x - 1][y] == 1) {\n                   \
    \     grid[x - 1][y] = 0;\n                        q.push({x - 1, y});\n     \
    \               }\n                    if (x < n - 1 && grid[x + 1][y] == 1) {\n\
    \                        grid[x + 1][y] = 0;\n                        q.push({x\
    \ + 1, y});\n                    }\n                    if (y > 0 && grid[x][y\
    \ - 1] == 1) {\n                        grid[x][y - 1] = 0;\n                \
    \        q.push({x, y - 1});\n                    }\n                    if (y\
    \ < m - 1 && grid[x][y + 1] == 1) {\n                        grid[x][y + 1] =\
    \ 0;\n                        q.push({x, y + 1});\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp435zdab_: /tmp/tmp435zdab_.cpp:62: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(int j = 0; j < m; j++){\n            sum +=\
    \ grid[i][j];\n        }\n        ans += sum / capacity;\n        if(sum % capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                grid[i][j] = 0;\n                long k = i + 1;\n\
    \                while (k < rows && capacity > 0) {\n                    if (grid[k][j]\
    \ == 1) {\n                        grid[k][j] = 0;\n                        capacity--;\n\
    \                    }\n                    k++;\n                }\n        \
    \        k = i - 1;\n                while (k >= 0 && capacity > 0) {\n      \
    \              if (grid[k][j] == 1) {\n                        grid[k][j] = 0;\n\
    \                        capacity--;\n                    }\n                \
    \    k--;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpa924kgkl: /tmp/tmpa924kgkl.cpp:56: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    int n = grid.size();\n  \
    \  int m = grid[0].size();\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        int sum = 0;\n        for(int j = 0; j < m; j++){\n            sum +=\
    \ grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum % capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum + capacity - 1) / capacity;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum/capacity);\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    return 0;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpumynrfmu: /tmp/tmpumynrfmu.cpp:30: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    int n = grid.size();\n  \
    \  int m = grid[0].size();\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpf2c30x3q: /tmp/tmpf2c30x3q.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans += capacity;\n\
    \                if (i > 0) {\n                    ans -= std::min(capacity, grid[i\
    \ - 1][j]);\n                }\n                if (j > 0) {\n               \
    \     ans -= std::min(capacity, grid[i][j - 1]);\n                }\n        \
    \    }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpq3g3ab27: /tmp/tmpq3g3ab27.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long ans = 0;\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            if(grid[i][j]\
    \ == 1) {\n                ans += capacity;\n                for(int k = i - 1;\
    \ k >= 0; k--) {\n                    if(grid[k][j] == 1) {\n                \
    \        ans -= capacity;\n                        break;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp22pkbc23: /tmp/tmp22pkbc23.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        if(sum == 0) continue;\n        if(sum <=\
    \ capacity){\n            ans += sum;\n        }else{\n            ans += capacity;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwoalpar9: /tmp/tmpwoalpar9.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            if(i == 0){\n                    ans += capacity;\n             \
    \   }\n                else{\n                    long temp = capacity;\n    \
    \                for(long k = i - 1; k >= 0; k--){\n                        if(grid[k][j]\
    \ == 1){\n                            temp--;\n                        }\n   \
    \                     else{\n                            break;\n            \
    \            }\n                    }\n                    ans += temp;\n    \
    \            }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpzp6jjmzq: /tmp/tmpzp6jjmzq.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        if(sum > 0){\n            if(sum <= capacity){\n\
    \                ans += 1;\n            }\n            else{\n               \
    \ ans += (sum / capacity);\n                if(sum % capacity != 0){\n       \
    \             ans += 1;\n                }\n            }\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size();\
    \ i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j]\
    \ == 1) {\n                max_fill += capacity;\n            }\n        }\n \
    \   }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp06e3mjac: /tmp/tmp06e3mjac.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count=0;\n    for(int\
    \ i=0;i<grid.size();i++){\n        for(int j=0;j<grid[i].size();j++){\n      \
    \      if(grid[i][j]==1){\n                count++;\n            }\n        }\n\
    \    }\n    return count/capacity;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpxhmlgb1p: /tmp/tmpxhmlgb1p.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    int n = grid.size();\n  \
    \  int m = grid[0].size();\n    int count = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           count++;\n            }\n        }\n    }\n    return count * capacity;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpcpk8yr1s: /tmp/tmpcpk8yr1s.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8pamaghv: /tmp/tmp8pamaghv.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp417jkp7_: /tmp/tmp417jkp7_.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long result = 0;\n    for (auto row : grid) {\n\
    \        long count = 0;\n        for (auto cell : row) {\n            if (cell\
    \ == 1) {\n                count++;\n            }\n        }\n        result\
    \ += count / capacity;\n        if (count % capacity != 0) {\n            result++;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp417jkp7_: /tmp/tmp417jkp7_.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count += capacity;\n      \
    \      }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpji_yzxf2: /tmp/tmpji_yzxf2.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp417jkp7_: /tmp/tmp417jkp7_.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8pamaghv: /tmp/tmp8pamaghv.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long ans = 0;\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            if(grid[i][j]\
    \ == 1) {\n                ans += capacity;\n                for(int k = i; k\
    \ >= 0; k--) {\n                    if(grid[k][j] == 1) {\n                  \
    \      grid[k][j] = 0;\n                    } else {\n                       \
    \ break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n   \
    \ assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpf_bk_2m4: /tmp/tmpf_bk_2m4.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    int ans = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j\
    \ < m; j++) {\n            if(grid[i][j] == 1) {\n                ans += capacity;\n\
    \                for(int k = i; k < n; k++) {\n                    for(int l =\
    \ j; l < m; l++) {\n                        if(grid[k][l] == 1) {\n          \
    \                  grid[k][l] = 0;\n                        }\n              \
    \      }\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmptav3mja6: /tmp/tmptav3mja6.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans += capacity;\n\
    \                for (int k = i; k < n; k++) {\n                    if (grid[k][j]\
    \ == 1) {\n                        grid[k][j] = 0;\n                    } else\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpjix52gz5: /tmp/tmpjix52gz5.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    return 0;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpumynrfmu: /tmp/tmpumynrfmu.cpp:30: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpj7o4c045: /tmp/tmpj7o4c045.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0l, sum - capacity);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpprwgehe8: /tmp/tmpprwgehe8.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (auto row : grid) {\n\
    \        long fill = 0;\n        for (auto well : row) {\n            if (well\
    \ == 1) {\n                fill++;\n            } else {\n                max_fill\
    \ += fill / capacity;\n                fill = 0;\n            }\n        }\n \
    \       max_fill += fill / capacity;\n    }\n    return max_fill;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmptwn8tq1u: /tmp/tmptwn8tq1u.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count / capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp6fpgvasc: /tmp/tmp6fpgvasc.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0)\n            ans++;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += (cnt\
    \ / capacity);\n        if(cnt % capacity != 0){\n            ans++;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt\
    \ / capacity;\n        if(cnt % capacity != 0){\n            ans++;\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n   \
    \ assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += sum / capacity;\n        if(sum %\
    \ capacity != 0) ans++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum / capacity);\n        if (sum % capacity) {\n    \
    \        ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += (cnt/capacity);\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum / capacity);\n        if (sum % capacity != 0) {\n\
    \            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0L, capacity - sum);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpuhjqzmcg: /tmp/tmpuhjqzmcg.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count += capacity;\n      \
    \      }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpji_yzxf2: /tmp/tmpji_yzxf2.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long count = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n            }\n        }\n        ans += count/capacity;\n\
    \        if(count%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    long\
    \ row = grid.size();\n    long col = grid[0].size();\n    for(long i = 0; i <\
    \ row; i++){\n        for(long j = 0; j < col; j++){\n            if(grid[i][j]\
    \ == 1){\n                count += capacity;\n                if(i-1 >= 0){\n\
    \                    grid[i-1][j] = 1;\n                }\n                if(i+1\
    \ < row){\n                    grid[i+1][j] = 1;\n                }\n        \
    \        if(j-1 >= 0){\n                    grid[i][j-1] = 1;\n              \
    \  }\n                if(j+1 < col){\n                    grid[i][j+1] = 1;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\nint\
    \ main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpqhd82bur: /tmp/tmpqhd82bur.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(int j = 0; j < m; j++){\n            sum +=\
    \ grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0)\n            ans++;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpgrq3_1pi: /tmp/tmpgrq3_1pi.cpp:38: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long ans = 0;\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            if(grid[i][j]\
    \ == 1) {\n                ans += capacity;\n                for(int k = i + 1;\
    \ k < grid.size(); k++) {\n                    if(grid[k][j] == 1) {\n       \
    \                 ans--;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp1dziyku0: /tmp/tmp1dziyku0.cpp:42: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += (cnt\
    \ / capacity);\n        if(cnt % capacity != 0){\n            ans++;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    // return 0;\n    long n\
    \ = grid.size();\n    long m = grid[0].size();\n    long ans = 0;\n    for(long\
    \ i = 0; i < n; i++){\n        long cnt = 0;\n        for(long j = 0; j < m; j++){\n\
    \            if(grid[i][j] == 1){\n                cnt++;\n            }\n   \
    \     }\n        ans += (cnt/capacity);\n        if(cnt%capacity != 0){\n    \
    \        ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8pamaghv: /tmp/tmp8pamaghv.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                grid[i][j] = 0;\n                if (i - 1 >= 0 &&\
    \ grid[i - 1][j] == 1) {\n                    grid[i - 1][j] = 0;\n          \
    \      }\n                if (i + 1 < rows && grid[i + 1][j] == 1) {\n       \
    \             grid[i + 1][j] = 0;\n                }\n                if (j -\
    \ 1 >= 0 && grid[i][j - 1] == 1) {\n                    grid[i][j - 1] = 0;\n\
    \                }\n                if (j + 1 < cols && grid[i][j + 1] == 1) {\n\
    \                    grid[i][j + 1] = 0;\n                }\n            }\n \
    \       }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp60glkrf5: /tmp/tmp60glkrf5.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n \
    \               cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += (cnt/capacity);\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long ans = 0;\n    for(long i = 0; i < rows; i++) {\n        for(long j =\
    \ 0; j < cols; j++) {\n            if(grid[i][j] == 1) {\n                ans\
    \ += capacity;\n                if(i > 0) {\n                    ans -= std::min(capacity,\
    \ grid[i-1][j]);\n                }\n                if(j > 0) {\n           \
    \         ans -= std::min(capacity, grid[i][j-1]);\n                }\n      \
    \      }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp6pic_78x: /tmp/tmp6pic_78x.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long ans = 0;\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            if(grid[i][j]\
    \ == 1) {\n                ans += capacity;\n                if(i-1 >= 0) {\n\
    \                    ans -= capacity - grid[i-1][j];\n                }\n    \
    \            if(j-1 >= 0) {\n                    ans -= capacity - grid[i][j-1];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpbpee6qal: /tmp/tmpbpee6qal.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (auto row : grid) {\n\
    \        long fill = 0;\n        for (auto well : row) {\n            if (well\
    \ == 1) {\n                fill++;\n            } else {\n                if (fill\
    \ > 0) {\n                    max_fill += fill / capacity;\n                 \
    \   fill = 0;\n                }\n            }\n        }\n        if (fill >\
    \ 0) {\n            max_fill += fill / capacity;\n        }\n    }\n    return\
    \ max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpxps_lepx: /tmp/tmpxps_lepx.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i > 0 && grid[i-1][j] == 1){\n                    grid[i-1][j] = 0;\n\
    \                }\n                if(j > 0 && grid[i][j-1] == 1){\n        \
    \            grid[i][j-1] = 0;\n                }\n            }\n        }\n\
    \    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n \
    \   assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpsyeaitls: /tmp/tmpsyeaitls.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    long i = 0;\n    while(i\
    \ < n) {\n        long j = 0;\n        while(j < m) {\n            if(grid[i][j]\
    \ == 1) {\n                grid[i][j] = 0;\n                ans++;\n         \
    \       for(long k = i; k < i + capacity && k < n; k++) {\n                  \
    \  for(long l = j; l < j + capacity && l < m; l++) {\n                       \
    \ grid[k][l] = 0;\n                    }\n                }\n            }\n \
    \           j++;\n        }\n        i++;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpicnl5779: /tmp/tmpicnl5779.cpp:51: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity + (count%capacity != 0);\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpua1o9wxr: /tmp/tmpua1o9wxr.cpp:42: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,
    (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1,
    (long)1, (long)1})})), (9)) == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660055948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count / capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp6fpgvasc: /tmp/tmp6fpgvasc.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                if(j+1 < grid[i].size() &&\
    \ grid[i][j+1] == 1){\n                    count--;\n                }\n     \
    \       }\n        }\n    }\n    return count * capacity;\n}\nint main() {\n \
    \   auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpu2gz424x: /tmp/tmpu2gz424x.cpp:40: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long result = 0;\n    for (int i = 0; i < grid.size();\
    \ i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j]\
    \ == 1) {\n                result += capacity;\n                if (i > 0) {\n\
    \                    result -= grid[i - 1][j];\n                }\n          \
    \      if (j > 0) {\n                    result -= grid[i][j - 1];\n         \
    \       }\n                if (i > 0 && j > 0) {\n                    result +=\
    \ grid[i - 1][j - 1];\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp1r0woqw9: /tmp/tmp1r0woqw9.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpj7o4c045: /tmp/tmpj7o4c045.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp417jkp7_: /tmp/tmp417jkp7_.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cur = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cur++;\n            }\n        }\n        ans += (cur / capacity);\n\
    \        if (cur % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long max_fill_count = 0;\n\
    \    for(int i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size();\
    \ j++){\n            if(grid[i][j] == 1){\n                max_fill_count += capacity;\n\
    \            }\n        }\n    }\n    return max_fill_count;\n}\nint main() {\n\
    \    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp3sq165y3: /tmp/tmp3sq165y3.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long ans = 0;\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            if(grid[i][j]\
    \ == 1) {\n                ans += capacity;\n                for(int k = i; k\
    \ < grid.size(); k++) {\n                    if(grid[k][j] == 1) {\n         \
    \               grid[k][j] = 0;\n                    } else {\n              \
    \          break;\n                    }\n                }\n            }\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp036bbplc: /tmp/tmp036bbplc.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long max_fill = 0;\n    long\
    \ rows = grid.size();\n    long cols = grid[0].size();\n    for(long i = 0; i\
    \ < rows; i++){\n        for(long j = 0; j < cols; j++){\n            if(grid[i][j]\
    \ == 1){\n                max_fill += capacity;\n            }\n        }\n  \
    \  }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpv67011u1: /tmp/tmpv67011u1.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long max_fill = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                max_fill += capacity;\n   \
    \         }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp4y2m8vlm: /tmp/tmp4y2m8vlm.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long max_fill = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                max_fill += capacity;\n   \
    \         }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpcf5ix7sp: /tmp/tmpcf5ix7sp.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans++;\n\
    \                grid[i][j] = 0;\n                long cur = capacity;\n     \
    \           while (cur > 0) {\n                    if (i - 1 >= 0 && grid[i -\
    \ 1][j] == 1) {\n                        grid[i - 1][j] = 0;\n               \
    \         cur--;\n                    }\n                    if (i + 1 < n &&\
    \ grid[i + 1][j] == 1) {\n                        grid[i + 1][j] = 0;\n      \
    \                  cur--;\n                    }\n                    if (j -\
    \ 1 >= 0 && grid[i][j - 1] == 1) {\n                        grid[i][j - 1] = 0;\n\
    \                        cur--;\n                    }\n                    if\
    \ (j + 1 < m && grid[i][j + 1] == 1) {\n                        grid[i][j + 1]\
    \ = 0;\n                        cur--;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660055955
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = 0; k < n; k++) {\n                \
    \    if (grid[k][j] == 1) {\n                        grid[k][j] = 0;\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp9186cw_m: /tmp/tmp9186cw_m.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i + 1 < grid.size()){\n                    grid[i+1][j] = 1;\n   \
    \             }\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwcs2ufkj: /tmp/tmpwcs2ufkj.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum + capacity - 1) / capacity;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long count = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n            }\n        }\n        ans += (count\
    \ / capacity);\n        if(count % capacity != 0){\n            ans++;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = i + 1; k < n; k++) {\n            \
    \        if (grid[k][j] == 1) {\n                        ans--;\n            \
    \        }\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpemzmm88e: /tmp/tmpemzmm88e.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long num_rows = grid.size();\n\
    \    long num_cols = grid[0].size();\n    long num_buckets = 0;\n    for (long\
    \ i = 0; i < num_rows; i++) {\n        for (long j = 0; j < num_cols; j++) {\n\
    \            if (grid[i][j] == 1) {\n                num_buckets++;\n        \
    \    }\n        }\n    }\n    return num_buckets * capacity;\n}\nint main() {\n\
    \    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpcfsv1i9x: /tmp/tmpcfsv1i9x.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += (sum / capacity);\n        if (sum % capacity != 0) {\n\
    \            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp8pamaghv: /tmp/tmp8pamaghv.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    return 0;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpp03corh2: /tmp/tmpp03corh2.cpp:30: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp219kx6cv: /tmp/tmp219kx6cv.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            if(i == 0){\n                    ans += capacity;\n             \
    \   }\n                else{\n                    ans += capacity - grid[i-1][j];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp19roduf2: /tmp/tmp19roduf2.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count += capacity;\n      \
    \      }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpji_yzxf2: /tmp/tmpji_yzxf2.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i+1 < grid.size()){\n                    grid[i+1][j] = 1;\n     \
    \           }\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmprboxjltx: /tmp/tmprboxjltx.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if\
    \ (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n\
    \    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            if (dp[i][j] == 1) {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n \
    \       std::sort(dp[i].begin(), dp[i].end());\n    }\n    long ans = 0;\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       ans += dp[i][j] / capacity;\n            if (dp[i][j] % capacity != 0)\
    \ {\n                ans++;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpvuss8yu4: /tmp/tmpvuss8yu4.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                for (long k = i; k < rows; k++) {\n             \
    \       for (long l = j; l < cols; l++) {\n                        if (grid[k][l]\
    \ == 1) {\n                            grid[k][l] = 0;\n                     \
    \   }\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n   \
    \ assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpfrgnul41: /tmp/tmpfrgnul41.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += cnt / capacity;\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                if (i > 0) {\n                    ans -= std::min(capacity,\
    \ grid[i - 1][j]);\n                }\n                if (j > 0) {\n        \
    \            ans -= std::min(capacity, grid[i][j - 1]);\n                }\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp5kdjsx8o: /tmp/tmp5kdjsx8o.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity) {\n      \
    \      ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           ans++;\n                grid[i][j] = 0;\n                for(int k\
    \ = i; k < n; k++){\n                    for(int l = j; l < m; l++){\n       \
    \                 if(grid[k][l] == 1){\n                            grid[k][l]\
    \ = 0;\n                            ans++;\n                        }\n      \
    \              }\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpe51kwg5y: /tmp/tmpe51kwg5y.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n \
    \               cnt++;\n            }\n        }\n        ans += (cnt + capacity\
    \ - 1) / capacity;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans++;\n                long k = i;\n                while(k < n\
    \ && grid[k][j] == 1){\n                    grid[k][j] = 0;\n                \
    \    k++;\n                }\n                k = i - 1;\n                while(k\
    \ >= 0 && grid[k][j] == 1){\n                    grid[k][j] = 0;\n           \
    \         k--;\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwp1i9kxw: /tmp/tmpwp1i9kxw.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long result = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  result += capacity;\n                for (long k = i + 1; k < rows; k++) {\n\
    \                    if (grid[k][j] == 1) {\n                        grid[k][j]\
    \ = 0;\n                    } else {\n                        break;\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpztcxcrkk: /tmp/tmpztcxcrkk.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0l, capacity - sum);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpyhosygyf: /tmp/tmpyhosygyf.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n\
    \    long count = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long\
    \ j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n              \
    \  count++;\n                grid[i][j] = 0;\n                if (i + 1 < rows\
    \ && grid[i + 1][j] == 1) {\n                    grid[i + 1][j] = 0;\n       \
    \         }\n                if (j + 1 < cols && grid[i][j + 1] == 1) {\n    \
    \                grid[i][j + 1] = 0;\n                }\n            }\n     \
    \   }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n\
    \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpc5hw7a9v: /tmp/tmpc5hw7a9v.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long max_fill = 0;\n    for (auto row : grid) {\n\
    \        long fill = 0;\n        for (auto well : row) {\n            if (well\
    \ == 1) {\n                fill++;\n            } else {\n                if (fill\
    \ > 0) {\n                    max_fill += fill / capacity;\n                 \
    \   fill = fill % capacity;\n                }\n            }\n        }\n   \
    \     if (fill > 0) {\n            max_fill += fill / capacity;\n            fill\
    \ = fill % capacity;\n        }\n    }\n    return max_fill;\n}\nint main() {\n\
    \    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp16jlf_1x: /tmp/tmp16jlf_1x.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long count = 0;\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           count++;\n                grid[i][j] = 0;\n            }\n       \
    \ }\n    }\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < m; j++){\n            if(grid[i][j] == 0){\n                ans++;\n\
    \                for(int k = 0; k < capacity; k++){\n                    if(i-k\
    \ >= 0 && grid[i-k][j] == 0){\n                        grid[i-k][j] = 1;\n   \
    \                     count--;\n                    }\n                    if(i+k\
    \ < n && grid[i+k][j] == 0){\n                        grid[i+k][j] = 1;\n    \
    \                    count--;\n                    }\n                    if(j-k\
    \ >= 0 && grid[i][j-k] == 0){\n                        grid[i][j-k] = 1;\n   \
    \                     count--;\n                    }\n                    if(j+k\
    \ < m && grid[i][j+k] == 0){\n                        grid[i][j+k] = 1;\n    \
    \                    count--;\n                    }\n                }\n    \
    \        }\n            if(count == 0){\n                return ans;\n       \
    \     }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpk3py93v4: /tmp/tmpk3py93v4.cpp:71: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(int i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(int j = 0; j < m; j++){\n            sum +=\
    \ grid[i][j];\n        }\n        ans += sum/capacity;\n        if(sum%capacity\
    \ != 0)\n            ans++;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        if (cnt > 0) {\n  \
    \          ans += (cnt - 1) / capacity + 1;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    return 0;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpumynrfmu: /tmp/tmpumynrfmu.cpp:30: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            ans += capacity;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwh9zn_z6: /tmp/tmpwh9zn_z6.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i + 1 < grid.size()){\n                    grid[i+1][j] = 1;\n   \
    \             }\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpwcs2ufkj: /tmp/tmpwcs2ufkj.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += sum / capacity;\n        if (sum % capacity != 0) {\n \
    \           ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        ans += (sum / capacity);\n        if(sum\
    \ % capacity != 0){\n            ans++;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long row = grid.size();\n\
    \    long col = grid[0].size();\n    long count = 0;\n    for(int i = 0; i < row;\
    \ i++){\n        for(int j = 0; j < col; j++){\n            if(grid[i][j] == 1){\n\
    \                count++;\n                grid[i][j] = 0;\n                if(i+1\
    \ < row && grid[i+1][j] == 1){\n                    count++;\n               \
    \     grid[i+1][j] = 0;\n                }\n                if(j+1 < col && grid[i][j+1]\
    \ == 1){\n                    count++;\n                    grid[i][j+1] = 0;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\nint\
    \ main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpn46v_ie6: /tmp/tmpn46v_ie6.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    long n = grid.size();\n   \
    \ long m = grid[0].size();\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < m; j++) {\n            if(grid[i][j] == 1) {\n                grid[i][j]\
    \ = 0;\n                count++;\n                if(i + 1 < n) {\n          \
    \          grid[i + 1][j] = 0;\n                }\n                if(j + 1 <\
    \ m) {\n                    grid[i][j + 1] = 0;\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpt00j2m6e: /tmp/tmpt00j2m6e.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // Your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long cnt = 0;\n        for(long j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                cnt++;\n            }\n        }\n        ans += (cnt/capacity);\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long cnt = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                cnt++;\n            }\n        }\n        ans += (cnt / capacity);\n\
    \        if (cnt % capacity != 0) {\n            ans++;\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660055945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long result = 0;\n    for (int i = 0; i < grid.size();\
    \ i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j]\
    \ == 1) {\n                result += capacity;\n                for (int k = i\
    \ - 1; k >= 0; k--) {\n                    if (grid[k][j] == 1) {\n          \
    \              break;\n                    }\n                    grid[k][j] =\
    \ 1;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp4hrky38y: /tmp/tmp4hrky38y.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055951
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long count = 0;\n    for(int i = 0; i < grid.size();\
    \ i++){\n        for(int j = 0; j < grid[i].size(); j++){\n            if(grid[i][j]\
    \ == 1){\n                count++;\n                grid[i][j] = 0;\n        \
    \        if(i+1 < grid.size()){\n                    grid[i+1][j] = 1;\n     \
    \           }\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmprboxjltx: /tmp/tmprboxjltx.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long count = 0;\n    for(int\
    \ i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count += capacity;\n      \
    \      }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpji_yzxf2: /tmp/tmpji_yzxf2.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),
    (2)) == (5)'' failed.

    '
  stdout: ''
  timestamp: 1660055947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n\
    \        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n    \
    \    }\n        ans += std::max(0l, capacity - sum);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmpyhosygyf: /tmp/tmpyhosygyf.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
    \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
    \ a single unit of water.\n// Each well has a corresponding bucket that can be\
    \ used to extract water from it, \n// and all buckets have the same capacity.\n\
    // Your task is to use the buckets to empty the wells.\n// Output the number of\
    \ times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n\
    // * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j]\
    \ -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>>\
    \ grid, long capacity) {\n    // your code here\n    long n = grid.size();\n \
    \   long m = grid[0].size();\n    long ans = 0;\n    for(long i = 0; i < n; i++){\n\
    \        long sum = 0;\n        for(long j = 0; j < m; j++){\n            sum\
    \ += grid[i][j];\n        }\n        if(sum > capacity){\n            ans += sum\
    \ - capacity;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0,\
    \ (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
    \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
    \ (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1,\
    \ (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
  status: Exception
  stderr: 'tmp2wjtpymy: /tmp/tmp2wjtpymy.cpp:42: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,
    (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,
    (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,
    (long)1})})), (1)) == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660055951
