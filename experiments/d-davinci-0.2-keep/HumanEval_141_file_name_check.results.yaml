name: HumanEval_141_file_name_check
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (!file_name_parts[0].isAlpha)\n        return \"\
    No\";\n    if (file_name_parts[0].countDigits > 3)\n        return \"No\";\n \
    \   if (!valid_extensions.any!(e => e == file_name_parts[1]))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0z6z94fn.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp0z6z94fn.d(26): Error: no property `isAlpha` for type `string`\\n/tmp/tmp0z6z94fn.d(28):\
    \ Error: no property `countDigits` for type `string`\\n/tmp/tmp0z6z94fn.d(30):\
    \ Error: no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0z6z94fn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.indexOf('.');\n    string extension = file_name.substr(dot_index\
    \ + 1);\n    string name = file_name.substr(0, dot_index);\n    if (dot_index\
    \ == -1 || name.length == 0 || !valid_extensions.contains(extension) || name.count(\"\
    0123456789\") > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc7nmy9bf.d(21): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpc7nmy9bf.d(22): Error: no property `substr` for type `string`\\n/tmp/tmpc7nmy9bf.d(23):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpc7nmy9bf.d(24): Error:\
    \ no property `contains` for type `string[]`\\n/tmp/tmpc7nmy9bf.d(24): Error:\
    \ no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpc7nmy9bf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi1ul1v7p.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpi1ul1v7p.d(26): Error: no property `count` for type `string`\\n/tmp/tmpi1ul1v7p.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi1ul1v7p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(isdigit(c))\n\
    \            digits_count++;\n    }\n    if(digits_count > 3)\n        return\
    \ \"No\";\n    if(!isalpha(name[0]))\n        return \"No\";\n    if(extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph_ntbd8g.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmph_ntbd8g.d(21): Error: no property `substr` for type `string`\\n/tmp/tmph_ntbd8g.d(22):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmph_ntbd8g.d(26): Error:\
    \ undefined identifier `isdigit`\\n/tmp/tmph_ntbd8g.d(31): Error: undefined identifier\
    \ `isalpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_ntbd8g.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl4hxcfw3.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpl4hxcfw3.d(26): Error: no property `count` for type `string`\\n/tmp/tmpl4hxcfw3.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpl4hxcfw3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n \
    \       return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpapyu4h37.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpapyu4h37.d(26): Error: no property `count` for type `string`\\n/tmp/tmpapyu4h37.d(28):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpapyu4h37.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index\
    \ = 0;\n    string before_dot = \"\";\n    string after_dot = \"\";\n    foreach(i,\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n   \
    \     {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count\
    \ != 1)\n    {\n        return \"No\";\n    }\n    before_dot = file_name[0..dot_index];\n\
    \    after_dot = file_name[dot_index+1..$];\n    if(before_dot.length == 0 ||\
    \ (before_dot[0] < 'a' || before_dot[0] > 'z') && (before_dot[0] < 'A' || before_dot[0]\
    \ > 'Z'))\n    {\n        return \"No\";\n    }\n    if(after_dot != \"txt\" &&\
    \ after_dot != \"exe\" && after_dot != \"dll\")\n    {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7zyogxaw.d(30): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp7zyogxaw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' &&\
    \ c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n  \
    \      return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(extension != \"txt\"\
    \ && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgf89ro2k.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpgf89ro2k.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpgf89ro2k.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgf89ro2k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string prefix = file_name[0..dot_pos];\n    string\
    \ suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0 || prefix.length\
    \ > 8 || suffix.length == 0 || suffix.length > 3)\n        return \"No\";\n  \
    \  if (prefix.count('0'..'9') > 3)\n        return \"No\";\n    if (prefix[0]\
    \ < 'a' || prefix[0] > 'z' && prefix[0] < 'A' || prefix[0] > 'Z')\n        return\
    \ \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\"\
    )\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsi4vdyv1.d(27): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsi4vdyv1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].filter!(a => a >= '0' && a <=\
    \ '9').length > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a'\
    \ || file_name_parts[0][0] > 'z' && file_name_parts[0][0] < 'A' || file_name_parts[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpraonuzs2.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpraonuzs2.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpraonuzs2.d(30):\
    \ Error: no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpraonuzs2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n     \
    \   return \"No\";\n    string name = file_name[0..dot_index];\n    string extension\
    \ = file_name[dot_index+1..$];\n    if (name.length == 0 || !isAlpha(name[0]))\n\
    \        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n  \
    \      if (c >= '0' && c <= '9')\n            digits_count++;\n    if (digits_count\
    \ > 3)\n        return \"No\";\n    if (valid_extensions.indexOf(extension) ==\
    \ -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppd2zic_9.d(21): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmppd2zic_9.d(26): Error: undefined identifier `isAlpha`\\n/tmp/tmppd2zic_9.d(34):\
    \ Error: no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppd2zic_9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.slice(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    if (name.count!(c\
    \ => c >= '0' && c <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8kavw0x2.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp8kavw0x2.d(23): Error: no property `slice` for type `string`\\n/tmp/tmp8kavw0x2.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8kavw0x2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string ext = file_name.substr(dot_index\
    \ + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n\
    \    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        \
    \    digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(ext\
    \ != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n  \
    \  if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcml44n7m.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpcml44n7m.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpcml44n7m.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcml44n7m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    if (name.count!(c => c >= '0'\
    \ && c <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwdtj8oc8.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpwdtj8oc8.d(23): Error: no property `substr` for type `string`\\n/tmp/tmpwdtj8oc8.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwdtj8oc8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_pos+1);\n  \
    \  if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.slice(0, dot_pos);\n    if (name.empty)\n   \
    \     return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    auto digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgznvkiyd.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpgznvkiyd.d(23): Error: no property `slice` for type `string`\\n/tmp/tmpgznvkiyd.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgznvkiyd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (count(file_name_parts[0], \"0123456789\"\
    ) > 3)\n        return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbtbjtweu.d(21): Error: undefined identifier `split`\\n/tmp/tmpbtbjtweu.d(28):\
    \ Error: undefined identifier `count`\\n/tmp/tmpbtbjtweu.d(30): Error: no property\
    \ `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpbtbjtweu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn36qjut9.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpn36qjut9.d(26): Error: no property `count` for type `string`\\n/tmp/tmpn36qjut9.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpn36qjut9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpok6kq02f.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpok6kq02f.d(26): Error: no property `count` for type `string`\\n/tmp/tmpok6kq02f.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpok6kq02f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0][0] <\
    \ 'a' || parts[0][0] > 'z') return \"No\";\n    if (parts[1] !in valid_extensions)\
    \ return \"No\";\n    if (parts[0].count!(a => a >= '0' && a <= '9') > 3) return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwokpvtev.d(21): Error: undefined identifier `split`\\n/tmp/tmpwokpvtev.d(25):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\n/tmp/tmpwokpvtev.d(26): Error: no property `count` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwokpvtev.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n      \
    \  return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n \
    \       return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5rmlu3ab.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp5rmlu3ab.d(26): Error: no property `count` for type `string`\\n/tmp/tmp5rmlu3ab.d(28):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmp5rmlu3ab.d(30):\
    \ Error: no property `isLetter` for type `immutable(char)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmlu3ab.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (parts[0].length\
    \ != count(parts[0], ch => ch >= '0' && ch <= '9'))\n        return \"No\";\n\
    \    if (parts[1] !in valid_extensions)\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcno9yewk.d(21): Error: undefined identifier `split`\\n/tmp/tmpcno9yewk.d(28):\
    \ Error: undefined identifier `count`\\n/tmp/tmpcno9yewk.d(30): Error: incompatible\
    \ types for `(parts[1]) in (valid_extensions)`: `string` and `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcno9yewk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (!parts[0].isalpha)\n        return \"No\";\n    if (parts[0].count(\"\
    0-9\") > 3)\n        return \"No\";\n    if (!valid_extensions.contains(parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt139jq66.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpt139jq66.d(26): Error: no property `isalpha` for type `string`\\n/tmp/tmpt139jq66.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpt139jq66.d(30): Error:\
    \ no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpt139jq66.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\"\
    )\n        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n\
    \    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n \
    \       return \"No\";\n    int digits = 0;\n    foreach (c; name)\n    {\n  \
    \      if (c >= '0' && c <= '9')\n            digits++;\n    }\n    if (digits\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1djw1nse.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp1djw1nse.d(21): Error: no property `substr` for type `string`\\n/tmp/tmp1djw1nse.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1djw1nse.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] !in \"a-zA-Z\")\n        return\
    \ \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpekw_ihgf.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpekw_ihgf.d(26): Error: no property `count` for type `string`\\n/tmp/tmpekw_ihgf.d(28):\
    \ Error: incompatible types for `(file_name_parts[0][0]) in (\"a-zA-Z\")`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpekw_ihgf.d(30): Error: incompatible types for `(file_name_parts[1])\
    \ in (valid_extensions)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpekw_ihgf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count!(c => c >= '0' && c <= '9') > 3)\n        return \"No\"\
    ;\n    if (parts[0][0] < 'a' || parts[0][0] > 'z' && parts[0][0] < 'A' || parts[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (valid_extensions.count!(e => e == parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmkng8wed.d(21): Error: undefined identifier `split`\\n/tmp/tmpmkng8wed.d(26):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpmkng8wed.d(30): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpmkng8wed.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    int digit_count\
    \ = 0;\n    string extension = file_name.substr(dot_index + 1);\n    string name\
    \ = file_name.substr(0, dot_index);\n    foreach(c; name)\n    {\n        if(c\
    \ >= '0' && c <= '9')\n            digit_count++;\n    }\n    if(digit_count >\
    \ 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\"\
    \ && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n\
    \        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp05cs2gme.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp05cs2gme.d(22): Error: no property `substr` for type `string`\\n/tmp/tmp05cs2gme.d(23):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp05cs2gme.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.slice(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_index);\n\
    \    if (name.empty || !isAlpha(name[0]))\n        return \"No\";\n    if (count(name,\
    \ (c) => isDigit(c)) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwqj4eq3l.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpwqj4eq3l.d(23): Error: no property `slice` for type `string`\\n/tmp/tmpwqj4eq3l.d(26):\
    \ Error: no property `slice` for type `string`\\n/tmp/tmpwqj4eq3l.d(27): Error:\
    \ undefined identifier `isAlpha`\\n/tmp/tmpwqj4eq3l.d(29): Error: undefined identifier\
    \ `count`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwqj4eq3l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    string file_name_part\
    \ = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n   \
    \ int digits_count = 0;\n    foreach(char ch; file_name_part)\n    {\n       \
    \ if(ch >= '0' && ch <= '9')\n        {\n            digits_count++;\n       \
    \ }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n \
    \   if(file_name_part.length == 0)\n    {\n        return \"No\";\n    }\n   \
    \ if(!(file_name_part[0] >= 'a' && file_name_part[0] <= 'z') && !(file_name_part[0]\
    \ >= 'A' && file_name_part[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n\
    \    if(!valid_extensions.contains(file_extension))\n    {\n        return \"\
    No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkt4xlti.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpqkt4xlti.d(44): Error: no property `contains` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqkt4xlti.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(c => c.isDigit) > 3)\n\
    \        return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return\
    \ \"No\";\n    if (!valid_extensions.any!(e => e == file_name_parts[1]))\n   \
    \     return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppzlon113.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmppzlon113.d(26): Error: no property `count` for type `string`\\n/tmp/tmppzlon113.d(28):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmppzlon113.d(30):\
    \ Error: no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppzlon113.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\"\
    ;\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (file_name_parts[0][0]\
    \ < 'a' || file_name_parts[0][0] > 'z') return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprezks441.d(21): Error: undefined identifier `split`\\n/tmp/tmprezks441.d(24):\
    \ Error: no property `count` for type `string`\\n/tmp/tmprezks441.d(26): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmprezks441.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = split(file_name,\
    \ \".\");\n    foreach(char c; file_name_split[0])\n    {\n        if(isdigit(c))\n\
    \        {\n            count++;\n        }\n    }\n    foreach(char c; file_name)\n\
    \    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n\
    \    }\n    if(count > 3 || dot_count != 1 || file_name_split[0].length == 0 ||\
    \ !isalpha(file_name_split[0][0]) || !in(file_name_split[1], valid_extensions))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6vgu5bjr.d(38): Error: expression expected, not `in`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vgu5bjr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.slice(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digits\
    \ = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n    \
    \        digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf8gajodj.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpf8gajodj.d(23): Error: no property `slice` for type `string`\\n/tmp/tmpf8gajodj.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf8gajodj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(c => c >= '0' && c <= '9')\
    \ > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(s => s == file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa1nx5z__.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpa1nx5z__.d(26): Error: no property `count` for type `string`\\n/tmp/tmpa1nx5z__.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpa1nx5z__.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.indexOf('.');\n    if (dot_index\
    \ == -1) return \"No\";\n    string before_dot = file_name[0..dot_index];\n  \
    \  string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length ==\
    \ 0 || before_dot.length > 8) return \"No\";\n    if (after_dot.length == 0 ||\
    \ after_dot.length > 3) return \"No\";\n    if (after_dot != \"txt\" && after_dot\
    \ != \"exe\" && after_dot != \"dll\") return \"No\";\n    if (before_dot.count!(a\
    \ => a >= '0' && a <= '9') > 3) return \"No\";\n    if (before_dot.count!(a =>\
    \ (a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z')) == 0) return \"No\";\n   \
    \ return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnknebykw.d(20): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpnknebykw.d(27): Error: no property `count` for type `string`\\n/tmp/tmpnknebykw.d(28):\
    \ Error: no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnknebykw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot = file_name.find('.');\n    if (dot == -1)\n  \
    \      return \"No\";\n    auto ext = file_name.slice(dot + 1);\n    if (ext !=\
    \ \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto\
    \ name = file_name.slice(0, dot);\n    if (name.length == 0)\n        return \"\
    No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n\
    \        return \"No\";\n    int count = 0;\n    foreach (c; name)\n    {\n  \
    \      if (c >= '0' && c <= '9')\n            count++;\n    }\n    if (count >\
    \ 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbetfg11g.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpbetfg11g.d(23): Error: no property `slice` for type `string`\\n/tmp/tmpbetfg11g.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbetfg11g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4rja85ud.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp4rja85ud.d(26): Error: no property `count` for type `string`\\n/tmp/tmp4rja85ud.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4rja85ud.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length\
    \ == 0 || after_dot.length == 0)\n        return \"No\";\n    if (before_dot.length\
    \ - before_dot.count!(a => a.isDigit) > 3)\n        return \"No\";\n    if (!before_dot[0].isLetter)\n\
    \        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\"\
    \ && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx_ymjx6_.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpx_ymjx6_.d(27): Error: no property `count` for type `string`\\n/tmp/tmpx_ymjx6_.d(29):\
    \ Error: no property `isLetter` for type `immutable(char)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx_ymjx6_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_split[0][0] < 'a' || file_name_split[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_split[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1w5jivm2.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp1w5jivm2.d(26): Error: no property `count` for type `string`\\n/tmp/tmp1w5jivm2.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1w5jivm2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_pos];\n\
    \    auto after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0\
    \ || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\"\
    \ && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n \
    \   if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return \"No\"\
    ;\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd69aibke.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd69aibke.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp94kah4og.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp94kah4og.d(26): Error: no property `count` for type `string`\\n/tmp/tmp94kah4og.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp94kah4og.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqqglk756.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpqqglk756.d(26): Error: no property `count` for type `string`\\n/tmp/tmpqqglk756.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqqglk756.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    import std.algorithm : count;\n    import std.array : empty;\n\
    \    import std.string : startsWith, endsWith;\n    import std.conv : to;\n  \
    \  import std.range : take, drop;\n    import std.typecons : tuple;\n    import\
    \ std.math : isNaN;\n    import std.regex : regex;\n    import std.regex : match;\n\
    \    import std.regex : Regex;\n    import std.regex : RegexMatch;\n    import\
    \ std.regex : RegexSplitter;\n    import std.regex : RegexSplitterResult;\n  \
    \  import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex : RegexSplitterResultType;\n    import std.regex : RegexSplitterResultType;\n\
    \    import std.regex\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8mm322fn.d(58): Error: `;` expected\\n/tmp/tmp8mm322fn.d(89):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8mm322fn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto ext = file_name.split('.')[1];\n  \
    \  if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.split('.')[0];\n    if (name.length == 0)\n \
    \       return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach (c;\
    \ name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n\
    \    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgauuxad_.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpgauuxad_.d(23): Error: no property `split` for type `string`\\n/tmp/tmpgauuxad_.d(26):\
    \ Error: no property `split` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgauuxad_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int i\
    \ = 0;\n    foreach(ch; file_name)\n    {\n        if(ch == '.')\n        {\n\
    \            dot_count++;\n        }\n        if(ch >= '0' && ch <= '9')\n   \
    \     {\n            digit_count++;\n        }\n        if(dot_count > 1)\n  \
    \      {\n            return \"No\";\n        }\n        if(digit_count > 3)\n\
    \        {\n            return \"No\";\n        }\n        if(i == 0 && !(ch >=\
    \ 'a' && ch <= 'z') && !(ch >= 'A' && ch <= 'Z'))\n        {\n            return\
    \ \"No\";\n        }\n        i++;\n    }\n    if(dot_count == 0)\n    {\n   \
    \     return \"No\";\n    }\n    string[] valid_extensions = [\"txt\", \"exe\"\
    , \"dll\"];\n    string extension = file_name[file_name.length - 3..$];\n    foreach(ext;\
    \ valid_extensions)\n    {\n        if(ext == extension)\n        {\n        \
    \    return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv597_4js.d(77): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429365]\\n??:? void tmpv597_4js.__unittest_L62_C1()\
    \ [0x4280e6]\\n??:? void tmpv597_4js.__modtest() [0x4285cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dcb3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4290be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ab61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42abf0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42aaed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x429095]\\n??:? runModuleUnitTests [0x42da89]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429828]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4297af]\\n??:? _d_run_main [0x42971a]\\n??:? main [0x4285df]\\\
    n??:? __libc_start_main [0x6443e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1) return \"No\";\n    string before_dot = file_name[0..dot_index];\n  \
    \  string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length ==\
    \ 0) return \"No\";\n    if (after_dot.length == 0) return \"No\";\n    if (after_dot\
    \ != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n\
    \    if (before_dot.count(\"0123456789\") > 3) return \"No\";\n    if (before_dot[0]\
    \ < 'A' || before_dot[0] > 'z') return \"No\";\n    if (before_dot[0] > 'Z' &&\
    \ before_dot[0] < 'a') return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4z7jymtp.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp4z7jymtp.d(27): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4z7jymtp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.slice(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n\
    \        return \"No\";\n    int count = 0;\n    foreach (c; name)\n    {\n  \
    \      if (isDigit(c))\n            count++;\n    }\n    if (count > 3)\n    \
    \    return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9oq0ujng.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp9oq0ujng.d(23): Error: no property `slice` for type `string`\\n/tmp/tmp9oq0ujng.d(26):\
    \ Error: no property `slice` for type `string`\\n/tmp/tmp9oq0ujng.d(29): Error:\
    \ undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9oq0ujng.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    if (dot_index == 0)\n        return \"No\"\
    ;\n    if (file_name.count('.') != 1)\n        return \"No\";\n    if (file_name[dot_index\
    \ + 1 .. $].count('0' .. '9') > 3)\n        return \"No\";\n    if (file_name[0\
    \ .. dot_index].count('0' .. '9') > 0)\n        return \"No\";\n    if (file_name[dot_index\
    \ + 1 .. $] != \"txt\" && file_name[dot_index + 1 .. $] != \"exe\" && file_name[dot_index\
    \ + 1 .. $] != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_b47npt6.d(27): Error: found `..` when expecting `,`\\n/tmp/tmp_b47npt6.d(29):\
    \ Error: found `..` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_b47npt6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string before_dot\
    \ = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n\
    \    if(before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if(after_dot\
    \ != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return\
    \ \"No\";\n    if(before_dot.length == 0)\n        return \"No\";\n    if(before_dot[0]\
    \ < 'a' || before_dot[0] > 'z')\n        if(before_dot[0] < 'A' || before_dot[0]\
    \ > 'Z')\n            return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n  \
    \  alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6y5tq2bk.d(23): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y5tq2bk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto file_name_without_extension = file_name[0..dot_index];\n\
    \    auto extension = file_name[dot_index+1..$];\n    if (file_name_without_extension.length\
    \ == 0 || \n        !(file_name_without_extension[0] >= 'a' && file_name_without_extension[0]\
    \ <= 'z' ||\n          file_name_without_extension[0] >= 'A' && file_name_without_extension[0]\
    \ <= 'Z'))\n        return \"No\";\n    if (extension != \"txt\" && extension\
    \ != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if (file_name_without_extension.count!(a\
    \ => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg6kh9azg.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg6kh9azg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2) \n    {\n        return \"No\";\n    }\n    if (file_name_parts[0].length\
    \ == 0) \n    {\n        return \"No\";\n    }\n    if (file_name_parts[0].count(\"\
    0-9\") > 3) \n    {\n        return \"No\";\n    }\n    if (file_name_parts[0].count(\"\
    a-zA-Z\") == 0) \n    {\n        return \"No\";\n    }\n    if (file_name_parts[1]\
    \ !in valid_extensions) \n    {\n        return \"No\";\n    }\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_268w4u5.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp_268w4u5.d(30): Error: no property `count` for type `string`\\n/tmp/tmp_268w4u5.d(34):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp_268w4u5.d(38): Error:\
    \ incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string`\
    \ and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_268w4u5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index\
    \ = 0;\n    int i = 0;\n    string extension = \"\";\n    string name = \"\";\n\
    \    foreach(c; file_name)\n    {\n        if(c == '.')\n        {\n         \
    \   dot_count++;\n            dot_index = i;\n        }\n        i++;\n    }\n\
    \    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    else\n    {\n\
    \        name = file_name[0..dot_index];\n        extension = file_name[dot_index+1..$];\n\
    \        if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\"\
    )\n        {\n            return \"No\";\n        }\n        foreach(c; name)\n\
    \        {\n            if(c >= '0' && c <= '9')\n            {\n            \
    \    count++;\n            }\n        }\n        if(count > 3)\n        {\n  \
    \          return \"No\";\n        }\n        else\n        {\n            return\
    \ \"Yes\";\n        }\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsofz_jae.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4287fd]\\n??:? void tmpsofz_jae.__unittest_L64_C1()\
    \ [0x427d68]\\n??:? void tmpsofz_jae.__modtest() [0x428580]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c51b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b42a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430541]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4309f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4304cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b401]\\n??:? runModuleUnitTests [0x42c2f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428cc0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428c47]\\n??:? _d_run_main [0x428bb2]\\n??:? main [0x428593]\\\
    n??:? __libc_start_main [0x8137554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0o6e09kv.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp0o6e09kv.d(26): Error: no property `count` for type `string`\\n/tmp/tmp0o6e09kv.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0o6e09kv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_index];\n\
    \    if (prefix.length == 0 || !isAlpha(prefix[0]))\n        return \"No\";\n\
    \    auto suffix = file_name[dot_index + 1..$];\n    if (suffix != \"txt\" &&\
    \ suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n    if (prefix.count!(a\
    \ => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4d0si6to.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp4d0si6to.d(24): Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4d0si6to.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length() == 0)\n \
    \       return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n     \
    \   return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu4j1ttb0.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpu4j1ttb0.d(24): Error: no property `length` for type `string`\\n/tmp/tmpu4j1ttb0.d(26):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpu4j1ttb0.d(30): Error:\
    \ no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpu4j1ttb0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (valid_extensions.indexOf(parts[1])\
    \ == -1)\n        return \"No\";\n    if (parts[0].length == 3)\n    {\n     \
    \   if (parts[0].indexOfAny(\"0123456789\") == -1)\n            return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp982vqdxl.d(21): Error: undefined identifier `split`\\n/tmp/tmp982vqdxl.d(28):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmp982vqdxl.d(32): Error:\
    \ no property `indexOfAny` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp982vqdxl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count!(c => c >= '0' && c <= '9') > 3)\n        return \"No\"\
    ;\n    if (parts[0][0] < 'a' || parts[0][0] > 'z' && parts[0][0] < 'A' || parts[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (valid_extensions.count!(ext => ext ==\
    \ parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkpxczlzp.d(21): Error: undefined identifier `split`\\n/tmp/tmpkpxczlzp.d(26):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpkpxczlzp.d(30): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpkpxczlzp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n      \
    \  return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n \
    \       return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprix9wk8v.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmprix9wk8v.d(26): Error: no property `count` for type `string`\\n/tmp/tmprix9wk8v.d(28):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmprix9wk8v.d(30):\
    \ Error: no property `isLetter` for type `immutable(char)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprix9wk8v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    int digits_count\
    \ = 0;\n    foreach(char c; file_name)\n    {\n        if(c.isDigit)\n       \
    \     digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\"\
    ;\n    if(file_name_parts.length != 2)\n        return \"No\";\n    if(file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if(!file_name_parts[0][0].isLetter)\n   \
    \     return \"No\";\n    if(!valid_extensions.canFind(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi_icip6j.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpi_icip6j.d(25): Error: no property `isDigit` for type `char`\\n/tmp/tmpi_icip6j.d(34):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmpi_icip6j.d(36):\
    \ Error: no property `canFind` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi_icip6j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    if (file_name_parts[0].count!(x => x >= '0' && x\
    \ <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp319cxj_k.d(21): Error: undefined identifier `split`\\n/tmp/tmp319cxj_k.d(28):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\n/tmp/tmp319cxj_k.d(30): Error: no property `count`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp319cxj_k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return\
    \ \"No\";\n    string name = file_name[0..dot_index];\n    string extension =\
    \ file_name[dot_index+1..$];\n    if (name.length == 0 || !isAlpha(name[0]))\n\
    \        return \"No\";\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n  \
    \      if (isDigit(c))\n            digits_count++;\n    if (digits_count > 3)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2m2lbhps.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmp2m2lbhps.d(26): Error: undefined identifier `isAlpha`\\n/tmp/tmp2m2lbhps.d(28):\
    \ Error: no property `canFind` for type `string[]`\\n/tmp/tmp2m2lbhps.d(32): Error:\
    \ undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2m2lbhps.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppd97n26c.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmppd97n26c.d(26): Error: no property `count` for type `string`\\n/tmp/tmppd97n26c.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppd97n26c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    auto dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n     \
    \   return \"No\";\n    auto extension = file_name[dot_index+1..$];\n    if (extension.length\
    \ == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    auto\
    \ name = file_name[0..dot_index];\n    if (name.length == 0 || !name[0].isLetter)\n\
    \        return \"No\";\n    if (name.count!(c => c.isDigit) > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppeg9107s.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmppeg9107s.d(25): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppeg9107s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.substr(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n\
    \        return \"No\";\n    int digit_count = 0;\n    for (auto c : name)\n \
    \   {\n        if (isDigit(c))\n            digit_count++;\n    }\n    if (digit_count\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp345lp7jl.d(32): Error: no identifier for declarator `c`\\n/tmp/tmp345lp7jl.d(32):\
    \ Error: expression expected, not `:`\\n/tmp/tmp345lp7jl.d(32): Error: found `name`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp345lp7jl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy9lv2ijz.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpy9lv2ijz.d(26): Error: no property `count` for type `string`\\n/tmp/tmpy9lv2ijz.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpy9lv2ijz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].length > 3)\n        return \"\
    No\";\n    if (file_name_parts[0].length < 3)\n    {\n        foreach(i; 0 ..\
    \ file_name_parts[0].length)\n        {\n            if (file_name_parts[0][i]\
    \ < '0' || file_name_parts[0][i] > '9')\n                return \"No\";\n    \
    \    }\n    }\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] >\
    \ 'z')\n        return \"No\";\n    if (file_name_parts[0][0] < 'A' || file_name_parts[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cg2nozv.d(21): Error: undefined identifier `split`\\n/tmp/tmp5cg2nozv.d(40):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5cg2nozv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot_pos = 0;\n    string[] valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string extension = \"\";\n    foreach(char\
    \ c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_pos =\
    \ count;\n        }\n        count++;\n    }\n    extension = file_name[dot_pos+1..$];\n\
    \    if(count - dot_pos - 1 > 3)\n    {\n        return \"No\";\n    }\n    if(dot_pos\
    \ == 0)\n    {\n        return \"No\";\n    }\n    if(!(file_name[0] >= 'a' &&\
    \ file_name[0] <= 'z') && !(file_name[0] >= 'A' && file_name[0] <= 'Z'))\n   \
    \ {\n        return \"No\";\n    }\n    if(!(extension in valid_extensions))\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9sjiu9es.d(45): Error: incompatible types for `(extension) in\
    \ (valid_extensions)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9sjiu9es.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_index];\n\
    \    auto suffix = file_name[dot_index + 1..$];\n    if (prefix.length == 0 ||\
    \ prefix.length > 8 || suffix.length == 0 || suffix.length > 3)\n        return\
    \ \"No\";\n    if (prefix.count!(a => a >= '0' && a <= '9') > 3)\n        return\
    \ \"No\";\n    if (!(prefix[0] >= 'a' && prefix[0] <= 'z' || prefix[0] >= 'A'\
    \ && prefix[0] <= 'Z'))\n        return \"No\";\n    if (suffix != \"txt\" &&\
    \ suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp235ovarh.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp235ovarh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == file_name.length)\n        return \"No\";\n    auto extension = file_name[dot_index\
    \ + 1 .. $];\n    if (extension != \"txt\" && extension != \"exe\" && extension\
    \ != \"dll\")\n        return \"No\";\n    auto name = file_name[0 .. dot_index];\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n\
    \        return \"No\";\n    if (count(name, ch => isDigit(ch)) > 3)\n       \
    \ return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp04mbby1f.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp04mbby1f.d(29): Error: undefined identifier `isAlpha`\\n/tmp/tmp04mbby1f.d(31):\
    \ Error: undefined identifier `count`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp04mbby1f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg5y4fsam.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpg5y4fsam.d(26): Error: no property `count` for type `string`\\n/tmp/tmpg5y4fsam.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg5y4fsam.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find(\".\");\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_pos];\n    auto\
    \ suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0 || prefix.length\
    \ > 8)\n        return \"No\";\n    if (suffix.length == 0 || suffix.length >\
    \ 3)\n        return \"No\";\n    if (prefix.count!(a => a >= '0' && a <= '9')\
    \ > 3)\n        return \"No\";\n    if (!(prefix[0] >= 'a' && prefix[0] <= 'z'\
    \ || prefix[0] >= 'A' && prefix[0] <= 'Z'))\n        return \"No\";\n    if (suffix\
    \ != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbc_950xj.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbc_950xj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_pos];\n\
    \    auto after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0\
    \ || !isAlpha(before_dot[0]))\n        return \"No\";\n    if (after_dot != \"\
    txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\"\
    ;\n    if (before_dot.count!(a => a.isDigit) > 3)\n        return \"No\";\n  \
    \  return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0z99vfag.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp0z99vfag.d(25): Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0z99vfag.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string file_name_without_extension\
    \ = file_name.substr(0, dot_index);\n    string file_name_extension = file_name.substr(dot_index\
    \ + 1);\n    if (file_name_without_extension.length == 0 || \n        file_name_without_extension.length\
    \ > 8 || \n        file_name_without_extension.count('0', '9') > 3 || \n     \
    \   file_name_without_extension[0] < 'a' || \n        file_name_without_extension[0]\
    \ > 'z' || \n        file_name_extension != \"txt\" && file_name_extension !=\
    \ \"exe\" && file_name_extension != \"dll\")\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbeon39zq.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpbeon39zq.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpbeon39zq.d(22):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpbeon39zq.d(25): Error:\
    \ no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpbeon39zq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find(\".\");\n    string name = file_name[0..dot_index];\n\
    \    string extension = file_name[dot_index + 1..$];\n    if (name.length == 0\
    \ || name[0] < 'a' || name[0] > 'z')\n        return \"No\";\n    if (extension.length\
    \ == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    int\
    \ digits_count = 0;\n    foreach (c; name)\n        if (c >= '0' && c <= '9')\n\
    \            digits_count++;\n    if (digits_count > 3)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0s7keb_t.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmp0s7keb_t.d(26): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0s7keb_t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0][0] <\
    \ 'a' || parts[0][0] > 'z') return \"No\";\n    if (count(parts[0], \"0123456789\"\
    ) > 3) return \"No\";\n    if (valid_extensions.count(parts[1]) == 0) return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsz2eozdc.d(21): Error: undefined identifier `split`\\n/tmp/tmpsz2eozdc.d(25):\
    \ Error: undefined identifier `count`\\n/tmp/tmpsz2eozdc.d(26): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpsz2eozdc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxfl5auts.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpxfl5auts.d(26): Error: no property `count` for type `string`\\n/tmp/tmpxfl5auts.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxfl5auts.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string file_extension\
    \ = file_name.substr(dot_index+1);\n    string file_name_without_extension = file_name.substr(0,\
    \ dot_index);\n    int digits_count = 0;\n    foreach(char c; file_name_without_extension)\n\
    \    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n\
    \    if(digits_count > 3)\n        return \"No\";\n    if(file_extension != \"\
    txt\" && file_extension != \"exe\" && file_extension != \"dll\")\n        return\
    \ \"No\";\n    if(file_name_without_extension.length == 0)\n        return \"\
    No\";\n    if(file_name_without_extension[0] < 'a' || file_name_without_extension[0]\
    \ > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpilo1lv2f.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpilo1lv2f.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpilo1lv2f.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpilo1lv2f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    if (file_name_parts[0].count!(c => c >= '0' && c\
    \ <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe5fzfjxa.d(21): Error: undefined identifier `split`\\n/tmp/tmpe5fzfjxa.d(28):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\n/tmp/tmpe5fzfjxa.d(30): Error: no property `count`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe5fzfjxa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    string file_name_extension\
    \ = file_name_split[1];\n    string file_name_no_extension = file_name_split[0];\n\
    \    int file_name_no_extension_length = file_name_no_extension.length;\n    int\
    \ file_name_no_extension_digit_count = 0;\n    foreach(char c; file_name_no_extension)\n\
    \    {\n        if(c >= '0' && c <= '9')\n        {\n            file_name_no_extension_digit_count++;\n\
    \        }\n    }\n    if(file_name_no_extension_digit_count > 3)\n    {\n   \
    \     return \"No\";\n    }\n    if(file_name_no_extension_length == 0)\n    {\n\
    \        return \"No\";\n    }\n    if(file_name_no_extension[0] < 'a' || file_name_no_extension[0]\
    \ > 'z')\n    {\n        if(file_name_no_extension[0] < 'A' || file_name_no_extension[0]\
    \ > 'Z')\n        {\n            return \"No\";\n        }\n    }\n    if(valid_extensions.canFind(file_name_extension)\
    \ == false)\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp24xet_ee.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp24xet_ee.d(24): Error: cannot implicitly convert expression `file_name_no_extension.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp24xet_ee.d(48): Error: no property `canFind`\
    \ for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp24xet_ee.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8t2s9xo_.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp8t2s9xo_.d(26): Error: no property `count` for type `string`\\n/tmp/tmp8t2s9xo_.d(32):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8t2s9xo_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_index];\n\
    \    auto suffix = file_name[dot_index+1..$];\n    if (prefix.length == 0 || prefix.length\
    \ > 8)\n        return \"No\";\n    if (suffix.length == 0 || suffix.length >\
    \ 3)\n        return \"No\";\n    if (prefix.count!(a => a >= '0' && a <= '9')\
    \ > 3)\n        return \"No\";\n    if (prefix.count!(a => a >= 'a' && a <= 'z'\
    \ || a >= 'A' && a <= 'Z') == 0)\n        return \"No\";\n    if (suffix != \"\
    txt\" && suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n   \
    \ return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_47gnjvh.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_47gnjvh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length\
    \ == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length\
    \ == 0 || after_dot.length > 3)\n        return \"No\";\n    if (before_dot.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] >\
    \ 'z')\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpekchc47w.d(29): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekchc47w.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0].count(\"\
    0-9\") > 3) return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z') return\
    \ \"No\";\n    if (parts[0][0] < 'A' || parts[0][0] > 'Z') return \"No\";\n  \
    \  if (!valid_extensions.contains(parts[1])) return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1cmxaiax.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp1cmxaiax.d(24): Error: no property `count` for type `string`\\n/tmp/tmp1cmxaiax.d(27):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1cmxaiax.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (parts[0].length\
    \ == 3)\n    {\n        if (parts[0].count(c => isDigit(c)) != 3)\n          \
    \  return \"No\";\n    }\n    if (parts[0].length == 2)\n    {\n        if (parts[0].count(c\
    \ => isDigit(c)) != 2)\n            return \"No\";\n    }\n    if (parts[0].length\
    \ == 1)\n    {\n        if (parts[0].count(c => isDigit(c)) != 1)\n          \
    \  return \"No\";\n    }\n    if (!isAlpha(parts[0][0]))\n        return \"No\"\
    ;\n    if (!valid_extensions.count(parts[1]))\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjxx1ndsl.d(21): Error: undefined identifier `split`\\n/tmp/tmpjxx1ndsl.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpjxx1ndsl.d(35): Error:\
    \ no property `count` for type `string`\\n/tmp/tmpjxx1ndsl.d(40): Error: no property\
    \ `count` for type `string`\\n/tmp/tmpjxx1ndsl.d(43): Error: undefined identifier\
    \ `isAlpha`\\n/tmp/tmpjxx1ndsl.d(45): Error: no property `count` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjxx1ndsl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1) return \"No\";\n    if (dot_index == 0) return \"No\";\n    if (dot_index\
    \ == file_name.length - 1) return \"No\";\n    if (file_name.count('.') != 1)\
    \ return \"No\";\n    auto before_dot = file_name[0..dot_index];\n    auto after_dot\
    \ = file_name[dot_index + 1..$];\n    if (before_dot.count!(c => c.isDigit) >\
    \ 3) return \"No\";\n    if (!before_dot.any!(c => c.isLetter)) return \"No\"\
    ;\n    if (!after_dot.any!(c => c.isLetter)) return \"No\";\n    if (after_dot\
    \ != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq50eu98c.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpq50eu98c.d(24): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq50eu98c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    if (dot_pos == 0)\n        return \"No\";\n\
    \    if (file_name.count('.') != 1)\n        return \"No\";\n    if (file_name[dot_pos\
    \ + 1 .. $].count('.') != 0)\n        return \"No\";\n    if (file_name[0 .. dot_pos].count('0'\
    \ .. '9') > 3)\n        return \"No\";\n    if (file_name[0 .. dot_pos].count('0'\
    \ .. '9') == 0)\n        return \"No\";\n    if (file_name[0 .. dot_pos].count('a'\
    \ .. 'z') == 0 && file_name[0 .. dot_pos].count('A' .. 'Z') == 0)\n        return\
    \ \"No\";\n    if (file_name[dot_pos + 1 .. $] != \"txt\" && file_name[dot_pos\
    \ + 1 .. $] != \"exe\" && file_name[dot_pos + 1 .. $] != \"dll\")\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgsvzhq12.d(29): Error: found `..` when expecting `,`\\n/tmp/tmpgsvzhq12.d(31):\
    \ Error: found `..` when expecting `,`\\n/tmp/tmpgsvzhq12.d(33): Error: found\
    \ `..` when expecting `,`\\n/tmp/tmpgsvzhq12.d(33): Error: found `..` when expecting\
    \ `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgsvzhq12.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (valid_extensions.indexOf(parts[1])\
    \ == -1)\n        return \"No\";\n    if (parts[0].indexOfAny(\"0123456789\")\
    \ != -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6v43mzrv.d(21): Error: undefined identifier `split`\\n/tmp/tmp6v43mzrv.d(28):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmp6v43mzrv.d(30): Error:\
    \ no property `indexOfAny` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6v43mzrv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm8yjk27m.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpm8yjk27m.d(26): Error: no property `count` for type `string`\\n/tmp/tmpm8yjk27m.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpm8yjk27m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return\
    \ \"No\";\n    string name = file_name[0..dot_index];\n    string extension =\
    \ file_name[dot_index+1..$];\n    if (name.length == 0 || !isAlpha(name[0]))\n\
    \        return \"No\";\n    if (extension.length == 0 || !valid_extensions.contains(extension))\n\
    \        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n  \
    \  {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8bmac7zg.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmp8bmac7zg.d(26): Error: undefined identifier `isAlpha`\\n/tmp/tmp8bmac7zg.d(28):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmp8bmac7zg.d(33):\
    \ Error: undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp8bmac7zg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_count = 0;\n    int num_count = 0;\n    bool first_char\
    \ = true;\n    bool first_dot = true;\n    bool first_num = true;\n    bool first_ext\
    \ = true;\n    bool first_letter = true;\n    string ext = \"\";\n    foreach(c;\
    \ file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n\
    \            first_dot = false;\n            first_letter = true;\n        }\n\
    \        else if(c >= '0' && c <= '9')\n        {\n            if(first_num)\n\
    \            {\n                num_count++;\n                first_num = false;\n\
    \            }\n            else if(first_dot)\n            {\n              \
    \  num_count++;\n            }\n        }\n        else if(c >= 'a' && c <= 'z'\
    \ || c >= 'A' && c <= 'Z')\n        {\n            if(first_letter)\n        \
    \    {\n                first_letter = false;\n            }\n            if(first_dot)\n\
    \            {\n                first_char = false;\n            }\n         \
    \   else\n            {\n                if(first_ext)\n                {\n  \
    \                  ext ~= c;\n                    first_ext = false;\n       \
    \         }\n                else\n                {\n                    ext\
    \ ~= c;\n                }\n            }\n        }\n        else\n        {\n\
    \            return \"No\";\n        }\n    }\n    if(dot_count != 1 || num_count\
    \ > 3 || first_char || ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n \
    \   {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n  \
    \  alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp55fpnbt2.d(87): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428815]\\n??:? void tmp55fpnbt2.__unittest_L82_C1()\
    \ [0x427d7c]\\n??:? void tmp55fpnbt2.__modtest() [0x428594]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ceab]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bdba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430791]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c40]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43071d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bd91]\\n??:? runModuleUnitTests [0x42cc81]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c64]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428beb]\\n??:? _d_run_main [0x428b56]\\n??:? main [0x4285a7]\\\
    n??:? __libc_start_main [0x4e3b3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index\
    \ = 0;\n    string sub_string_before_dot = \"\";\n    string sub_string_after_dot\
    \ = \"\";\n    foreach(i; 0 .. file_name.length)\n    {\n        if(file_name[i]\
    \ >= '0' && file_name[i] <= '9')\n        {\n            count++;\n        }\n\
    \        if(file_name[i] == '.')\n        {\n            dot_count++;\n      \
    \      dot_index = i;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n\
    \    {\n        return \"No\";\n    }\n    sub_string_before_dot = file_name[0\
    \ .. dot_index - 1];\n    sub_string_after_dot = file_name[dot_index + 1 .. file_name.length];\n\
    \    if(sub_string_before_dot == \"\" || (sub_string_before_dot[0] < 'a' || sub_string_before_dot[0]\
    \ > 'z') && (sub_string_before_dot[0] < 'A' || sub_string_before_dot[0] > 'Z'))\n\
    \    {\n        return \"No\";\n    }\n    if(sub_string_after_dot != \"txt\"\
    \ && sub_string_after_dot != \"exe\" && sub_string_after_dot != \"dll\")\n   \
    \ {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    'Yes' if the\
    \ the file's name is valid, and returns 'No' otherwise.\n    A file's name is\
    \ considered to be valid if and only if all the following conditions \n    are\
    \ met:\n    - There should not be more than three digits ('0'-'9') in the file's\
    \ name.\n    - The file's name contains exactly one dot '.'\n    - The substring\
    \ before the dot should not be empty, and it starts with a letter from \n    the\
    \ latin alphapet ('a'-'z' and 'A'-'Z').\n    - The\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn2dq2opw.d(53): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn2dq2opw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsr_oxpay.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpsr_oxpay.d(26): Error: no property `count` for type `string`\\n/tmp/tmpsr_oxpay.d(30):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsr_oxpay.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp00tgrymm.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp00tgrymm.d(26): Error: no property `count` for type `string`\\n/tmp/tmp00tgrymm.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp00tgrymm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps08huu_h.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmps08huu_h.d(26): Error: no property `count` for type `string`\\n/tmp/tmps08huu_h.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmps08huu_h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    int num_digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n\
    \    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7tu8ghcr.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp7tu8ghcr.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp7tu8ghcr.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7tu8ghcr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0123456789\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq2781j9c.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpq2781j9c.d(26): Error: no property `count` for type `string`\\n/tmp/tmpq2781j9c.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpq2781j9c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string ext = file_name.substr(dot_pos+1);\n    if\
    \ (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\"\
    ;\n    string name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    int digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptntnri9u.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmptntnri9u.d(23): Error: no property `substr` for type `string`\\n/tmp/tmptntnri9u.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptntnri9u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string ext = file_name.slice(dot_index +\
    \ 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return\
    \ \"No\";\n    string name = file_name.slice(0, dot_index);\n    if (name.length\
    \ == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0]\
    \ < 'A' || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n\
    \    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\n/*\n\
    Create a function which takes a string representing a file's name, and returns\n\
    \    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A\
    \ file's name is considered to be valid if and only if all the following conditions\
    \ \n    are met:\n    - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n    - The file's name contains exactly one dot '.'\n    -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"\
    example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string ext = file_name.slice(dot_index +\
    \ 1);\n   \nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwwe3q4c.d(63): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwwe3q4c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >=\
    \ '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count >\
    \ 3)\n        return \"No\";\n    if(!(extension == \"txt\" || extension == \"\
    exe\" || extension == \"dll\"))\n        return \"No\";\n    if(name.length ==\
    \ 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z' || name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1bmhyd10.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp1bmhyd10.d(21): Error: no property `substr` for type `string`\\n/tmp/tmp1bmhyd10.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1bmhyd10.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].length != file_name_parts[0].filter!(c\
    \ => c.isDigit).length)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ > 3)\n        return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n   \
    \     return \"No\";\n    if (valid_extensions.filter!(ext => ext == file_name_parts[1]).length\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyipf2a6k.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpyipf2a6k.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpyipf2a6k.d(30):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmpyipf2a6k.d(32):\
    \ Error: no property `filter` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpyipf2a6k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n     \
    \   return \"No\";\n    string name = file_name[0..dot_index];\n    string extension\
    \ = file_name[dot_index+1..$];\n    if (name.length == 0 || name.length > 8 ||\
    \ name.count!(c => c.isDigit) > 3)\n        return \"No\";\n    if (!name[0].isLetter)\n\
    \        return \"No\";\n    if (valid_extensions.count!(ext => ext == extension)\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplbkegx02.d(21): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmplbkegx02.d(26): Error: no property `count` for type `string`\\n/tmp/tmplbkegx02.d(28):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmplbkegx02.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplbkegx02.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].filter!(c => c.isDigit).length > 3)\n        return \"No\";\n\
    \    if (!parts[0].front.isLetter)\n        return \"No\";\n    if (!valid_extensions.any!(e\
    \ => e == parts[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpojwtt0fa.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpojwtt0fa.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpojwtt0fa.d(28):\
    \ Error: no property `front` for type `string`\\n/tmp/tmpojwtt0fa.d(30): Error:\
    \ no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpojwtt0fa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0].count(\"\
    0123456789\") > 3) return \"No\";\n    if (valid_extensions.count(parts[1]) ==\
    \ 0) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbjetftae.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpbjetftae.d(24): Error: no property `count` for type `string`\\n/tmp/tmpbjetftae.d(25):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbjetftae.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n      \
    \  return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n   \
    \ if (extension.length == 0 || !valid_extensions.canFind(extension))\n       \
    \ return \"No\";\n    string file_name_without_extension = file_name[0 .. dot_index\
    \ - 1];\n    if (file_name_without_extension.length == 0)\n        return \"No\"\
    ;\n    if (file_name_without_extension[0] < 'a' || file_name_without_extension[0]\
    \ > 'z' &&\n        file_name_without_extension[0] < 'A' || file_name_without_extension[0]\
    \ > 'Z')\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; file_name_without_extension)\n\
    \    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n    }\n\
    \    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk1r9136o.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmpk1r9136o.d(25): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk1r9136o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function\
    \ which takes a string representing a file's name, and returns\n    'Yes' if the\
    \ the file's name is valid, and returns 'No' otherwise.\n    A file's name is\
    \ considered to be valid if and only if all the following conditions \n    are\
    \ met:\n    - There should not be more than three digits ('0'-'9') in the file's\
    \ name.\n    - The file's name contains exactly one dot '.'\n    - The substring\
    \ before the dot should not be empty, and it starts with a letter from \n    the\
    \ latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should\
    \ be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"\
    example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeze04mj1.d(58): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpeze04mj1.d(89): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeze04mj1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.count(parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp63bibh1i.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp63bibh1i.d(26): Error: no property `count` for type `string`\\n/tmp/tmp63bibh1i.d(32):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp63bibh1i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (!file_name_parts[0].isLetter)\n        return \"\
    No\";\n    if (file_name_parts[0].count(char(c => c.isDigit)) > 3)\n        return\
    \ \"No\";\n    if (!valid_extensions.any!(ext => file_name_parts[1] == ext))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph_3905mn.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmph_3905mn.d(26): Error: no property `isLetter` for type `string`\\n/tmp/tmph_3905mn.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmph_3905mn.d(30): Error:\
    \ no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmph_3905mn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n  \
    \      return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57temaws.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp57temaws.d(26): Error: no property `count` for type `string`\\n/tmp/tmp57temaws.d(28):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp57temaws.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8db6ck9t.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp8db6ck9t.d(26): Error: no property `count` for type `string`\\n/tmp/tmp8db6ck9t.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8db6ck9t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.empty())\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    if (name.count('0') + name.count('1')\
    \ + name.count('2') + name.count('3') + name.count('4') + name.count('5') + name.count('6')\
    \ + name.count('7') + name.count('8') + name.count('9') > 3)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp99khk_eq.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp99khk_eq.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp99khk_eq.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp99khk_eq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string sub_str_before_dot\
    \ = file_name[0..dot_index];\n    string sub_str_after_dot = file_name[dot_index+1..$];\n\
    \    if(sub_str_before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if(sub_str_before_dot.length\
    \ == 0)\n        return \"No\";\n    if(!(sub_str_before_dot[0] >= 'a' && sub_str_before_dot[0]\
    \ <= 'z') && !(sub_str_before_dot[0] >= 'A' && sub_str_before_dot[0] <= 'Z'))\n\
    \        return \"No\";\n    if(sub_str_after_dot != \"txt\" && sub_str_after_dot\
    \ != \"exe\" && sub_str_after_dot != \"dll\")\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp74_xmhi0.d(23): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp74_xmhi0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n\
    \    string ext = file_name[dot_index+1..$];\n    if (name.length == 0 || ext.length\
    \ == 0)\n        return \"No\";\n    if (name.count('0','9') > 3)\n        return\
    \ \"No\";\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n     \
    \   return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' ||\
    \ name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpthmlki98.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpthmlki98.d(27): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpthmlki98.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (valid_extensions.count(parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoptztg2z.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpoptztg2z.d(26): Error: no property `count` for type `string`\\n/tmp/tmpoptztg2z.d(28):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpoptztg2z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.slice(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_index);\n\
    \    if (name.empty || !isAlpha(name[0]))\n        return \"No\";\n    auto digits\
    \ = name.filter!(c => isDigit(c)).length;\n    if (digits > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp07s5ixgp.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp07s5ixgp.d(23): Error: no property `slice` for type `string`\\n/tmp/tmp07s5ixgp.d(26):\
    \ Error: no property `slice` for type `string`\\n/tmp/tmp07s5ixgp.d(27): Error:\
    \ undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp07s5ixgp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0].count(\"\
    0-9\") > 3) return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z') return\
    \ \"No\";\n    if (parts[0][0] < 'A' || parts[0][0] > 'Z') return \"No\";\n  \
    \  if (!valid_extensions.contains(parts[1])) return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8_rcf0od.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp8_rcf0od.d(24): Error: no property `count` for type `string`\\n/tmp/tmp8_rcf0od.d(27):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8_rcf0od.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    string ext = file_name.substr(dot_pos+1);\n\
    \    string name = file_name.substr(0, dot_pos);\n    int count = 0;\n    foreach(c;\
    \ name)\n    {\n        if(c >= '0' && c <= '9')\n            count++;\n    }\n\
    \    if(count > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"\
    exe\" && ext != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n \
    \       return \"No\";\n    if(name[0] < 'a' || name[0] > 'z')\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp9e49__o.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpp9e49__o.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpp9e49__o.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpp9e49__o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_pos];\n    auto\
    \ suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0 || !prefix[0].isLetter)\n\
    \        return \"No\";\n    if (prefix.count!(a => a.isDigit) > 3)\n        return\
    \ \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\"\
    )\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp56ycfpmw.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp56ycfpmw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto sub_str_before_dot = file_name[0..dot_pos];\n\
    \    auto sub_str_after_dot = file_name[dot_pos+1..$];\n    if (sub_str_before_dot.length\
    \ == 0 || sub_str_after_dot.length == 0)\n        return \"No\";\n    if (sub_str_before_dot.count!(a\
    \ => a.isDigit) > 3)\n        return \"No\";\n    if (!sub_str_before_dot[0].isLetter)\n\
    \        return \"No\";\n    if (sub_str_after_dot != \"txt\" && sub_str_after_dot\
    \ != \"exe\" && sub_str_after_dot != \"dll\")\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6fogz1oc.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6fogz1oc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return\
    \ \"No\";\n    string name = file_name[0..dot_index];\n    string extension =\
    \ file_name[dot_index + 1..$];\n    if (name.count('0'..'9') > 3)\n        return\
    \ \"No\";\n    if (name.empty || !name.isalpha)\n        return \"No\";\n    if\
    \ (valid_extensions.find(extension) == -1)\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt05plqxg.d(26): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt05plqxg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string pre_dot = file_name[0..dot_pos];\n    string\
    \ post_dot = file_name[dot_pos+1..$];\n    if (pre_dot.length == 0 || !isalpha(pre_dot[0]))\n\
    \        return \"No\";\n    if (post_dot != \"txt\" && post_dot != \"exe\" &&\
    \ post_dot != \"dll\")\n        return \"No\";\n    if (pre_dot.count('0','1','2','3','4','5','6','7','8','9')\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxe_qd2zi.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpxe_qd2zi.d(25): Error: undefined identifier `isalpha`\\n/tmp/tmpxe_qd2zi.d(29):\
    \ Error: no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxe_qd2zi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] !in \"a-zA-Z\")\n        return\
    \ \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg09esmvf.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpg09esmvf.d(26): Error: no property `count` for type `string`\\n/tmp/tmpg09esmvf.d(28):\
    \ Error: incompatible types for `(file_name_parts[0][0]) in (\"a-zA-Z\")`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpg09esmvf.d(30): Error: incompatible types for `(file_name_parts[1])\
    \ in (valid_extensions)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg09esmvf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find('.');\n    string name = file_name[0..dot_index];\n\
    \    string extension = file_name[dot_index+1..$];\n    if (name.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (name.length == 0 || !('a'..'z').canFind(name[0])\
    \ && !('A'..'Z').canFind(name[0]))\n        return \"No\";\n    if (!valid_extensions.canFind(extension))\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8z9dd5jq.d(24): Error: found `..` when expecting `,`\\n/tmp/tmp8z9dd5jq.d(26):\
    \ Error: found `..` when expecting `)`\\n/tmp/tmp8z9dd5jq.d(26): Error: found\
    \ `122U` when expecting `)`\\n/tmp/tmp8z9dd5jq.d(26): Error: found `)` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8z9dd5jq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmponwdsmz3.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmponwdsmz3.d(26): Error: no property `count` for type `string`\\n/tmp/tmponwdsmz3.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmponwdsmz3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0][0] <\
    \ 'a' || parts[0][0] > 'z') return \"No\";\n    if (parts[1] !in valid_extensions)\
    \ return \"No\";\n    int count = 0;\n    foreach (c; parts[0])\n    {\n     \
    \   if (c >= '0' && c <= '9') count++;\n    }\n    if (count > 3) return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk8wdewsr.d(21): Error: undefined identifier `split`\\n/tmp/tmpk8wdewsr.d(25):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk8wdewsr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n  \
    \      return \"No\";\n    if (!file_name_parts[0].startsWith(\"a-z\") && !file_name_parts[0].startsWith(\"\
    A-Z\"))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsc_hriji.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpsc_hriji.d(26): Error: no property `count` for type `string`\\n/tmp/tmpsc_hriji.d(28):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmpsc_hriji.d(30):\
    \ Error: no property `startsWith` for type `string`\\n/tmp/tmpsc_hriji.d(30):\
    \ Error: no property `startsWith` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpsc_hriji.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_split[0][0] < 'a' || file_name_split[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_split[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ruk0n8x.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp9ruk0n8x.d(26): Error: no property `count` for type `string`\\n/tmp/tmp9ruk0n8x.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9ruk0n8x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpooqzc5_d.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpooqzc5_d.d(26): Error: no property `count` for type `string`\\n/tmp/tmpooqzc5_d.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpooqzc5_d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    static string[] valid_extensions = [\"txt\", \"exe\", \"\
    dll\"];\n    auto dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n\
    \        return \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n\
    \    if (extension.length == 0 || !valid_extensions.canFind(extension))\n    \
    \    return \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.length\
    \ == 0 || name[0] < 'a' || name[0] > 'z')\n        return \"No\";\n    int digits_count\
    \ = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n    \
    \        digits_count++;\n    }\n    if (digits_count > 3)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgjdj7ejl.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmpgjdj7ejl.d(25): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgjdj7ejl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] !in \"a-zA-Z\")\n        return\
    \ \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvo9ginzh.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpvo9ginzh.d(26): Error: no property `count` for type `string`\\n/tmp/tmpvo9ginzh.d(28):\
    \ Error: incompatible types for `(file_name_parts[0][0]) in (\"a-zA-Z\")`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpvo9ginzh.d(30): Error: incompatible types for `(file_name_parts[1])\
    \ in (valid_extensions)`: `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvo9ginzh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0].filter!(a\
    \ => a.isDigit).length > 3) return \"No\";\n    if (parts[0].filter!(a => a.isLetter).length\
    \ == 0) return \"No\";\n    if (valid_extensions.filter!(a => a == parts[1]).length\
    \ == 0) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpncnsqjxx.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpncnsqjxx.d(24): Error: no property `filter` for type `string`\\n/tmp/tmpncnsqjxx.d(25):\
    \ Error: no property `filter` for type `string`\\n/tmp/tmpncnsqjxx.d(26): Error:\
    \ no property `filter` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpncnsqjxx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length\
    \ == 0 || after_dot.length == 0)\n        return \"No\";\n    if (before_dot.length\
    \ > 0 && before_dot[0] < 'a' || before_dot[0] > 'z' && before_dot[0] < 'A' ||\
    \ before_dot[0] > 'Z')\n        return \"No\";\n    if (after_dot != \"txt\" &&\
    \ after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int\
    \ count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <=\
    \ '9')\n            count++;\n    }\n    if (count > 3)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyffe23y.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyffe23y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string file_name_without_ext\
    \ = file_name.substr(0, dot_index);\n    string file_ext = file_name.substr(dot_index\
    \ + 1);\n    if (file_name_without_ext.length == 0)\n        return \"No\";\n\
    \    if (file_name_without_ext.length == 1)\n    {\n        if (file_name_without_ext[0]\
    \ < 'a' || file_name_without_ext[0] > 'z')\n            return \"No\";\n    }\n\
    \    else\n    {\n        if (file_name_without_ext[0] < 'a' || file_name_without_ext[0]\
    \ > 'z')\n            return \"No\";\n        if (file_name_without_ext[1] < 'a'\
    \ || file_name_without_ext[1] > 'z')\n            return \"No\";\n    }\n    if\
    \ (file_ext != \"txt\" && file_ext != \"exe\" && file_ext != \"dll\")\n      \
    \  return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate =\
    \ file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n   \
    \ assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpusfqdzj4.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpusfqdzj4.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpusfqdzj4.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpusfqdzj4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto file_name_parts = split(file_name, \".\");\n    if\
    \ (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 0)\n        return \"No\";\n    if (file_name_parts[1] != \"txt\" && file_name_parts[1]\
    \ != \"exe\" && file_name_parts[1] != \"dll\")\n        return \"No\";\n    if\
    \ (file_name_parts[0].length > 3)\n        return \"No\";\n    if (file_name_parts[0].length\
    \ == 3)\n    {\n        if (file_name_parts[0][0] < '0' || file_name_parts[0][0]\
    \ > '9')\n            return \"No\";\n        if (file_name_parts[0][1] < '0'\
    \ || file_name_parts[0][1] > '9')\n            return \"No\";\n        if (file_name_parts[0][2]\
    \ < '0' || file_name_parts[0][2] > '9')\n            return \"No\";\n    }\n \
    \   if (file_name_parts[0].length == 2)\n    {\n        if (file_name_parts[0][0]\
    \ < '0' || file_name_parts[0][0] > '9')\n            return \"No\";\n        if\
    \ (file_name_parts[0][1] < '0' || file_name_parts[0][1] > '9')\n            return\
    \ \"No\";\n    }\n    if (file_name_parts[0].length == 1)\n    {\n        if (file_name_parts[0][0]\
    \ < '0' || file_name_parts[0][0] > '9')\n            return \"No\";\n    }\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmsjmwaw6.d(20): Error: undefined identifier `split`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmsjmwaw6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_index + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.slice(0, dot_index);\n    if (name.length ==\
    \ 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0]\
    \ < 'A' || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n\
    \    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpup8oz447.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpup8oz447.d(23): Error: no property `slice` for type `string`\\n/tmp/tmpup8oz447.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpup8oz447.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <=\
    \ '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\"\
    ;\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\"\
    )\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n\
    \    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <=\
    \ 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6cyguw3g.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp6cyguw3g.d(21): Error: no property `substr` for type `string`\\n/tmp/tmp6cyguw3g.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6cyguw3g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (parts[0].count!(a\
    \ => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    if (parts[0].count!(a\
    \ => a >= 'a' && a <= 'z' || a >= 'A' && a <= 'Z') == 0)\n        return \"No\"\
    ;\n    if (valid_extensions.count!(a => a == parts[1]) == 0)\n        return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9xoe8qjj.d(21): Error: undefined identifier `split`\\n/tmp/tmp9xoe8qjj.d(28):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp9xoe8qjj.d(30): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp9xoe8qjj.d(32): Error: no property\
    \ `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp9xoe8qjj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].filter!(a => a >= '0' && a <= '9').length > 3)\n        return\
    \ \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z' && parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.filter!(a\
    \ => a == parts[1]).length == 0)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfyu00qll.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpfyu00qll.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpfyu00qll.d(30):\
    \ Error: no property `filter` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfyu00qll.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string prefix = file_name[0..dot_pos];\n    string\
    \ suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0 || prefix.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\"\
    \ && suffix != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7gef9rxs.d(25): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7gef9rxs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    import std.algorithm : count;\n    import std.conv : to;\n\
    \    import std.range : take, drop;\n    import std.string : startsWith;\n   \
    \ import std.array : array;\n    import std.ascii : isAlpha;\n    import std.typecons\
    \ : tuple;\n    import std.math : isNaN;\n    import std.stdio : writeln;\n  \
    \  auto dot_index = file_name.indexOf('.');\n    auto file_name_without_extension\
    \ = file_name.take(dot_index);\n    auto extension = file_name.drop(dot_index\
    \ + 1);\n    auto valid_extensions = tuple(\"txt\", \"exe\", \"dll\");\n    auto\
    \ valid_extensions_array = valid_extensions.array;\n    auto digits_count = file_name.count!(c\
    \ => c.isDigit);\n    auto is_valid_extension = valid_extensions_array.any!(ext\
    \ => ext == extension);\n    auto is_valid_name = file_name_without_extension.startsWith!(c\
    \ => c.isAlpha);\n    auto is_valid_file_name = is_valid_name && is_valid_extension\
    \ && digits_count <= 3;\n    return is_valid_file_name ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa_t7sri4.d(29): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmpa_t7sri4.d(34): Error: template `std.algorithm.searching.count` cannot\
    \ deduce function from argument types `!((c) => c.isDigit)(string)`, candidates\
    \ are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(633):\
    \        `std.algorithm.searching.count(alias pred = \"a == b\", Range, E)(Range\
    \ haystack, E needle) if (isInputRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(haystack.front,\
    \ needle)) : bool))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(687):\
    \        `std.algorithm.searching.count(alias pred = \"a == b\", R1, R2)(R1 haystack,\
    \ R2 needle) if (isForwardRange!R1 && !isInfinite!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front,\
    \ needle.front)) : bool))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(711):\
    \        `std.algorithm.searching.count(alias pred, R)(R haystack) if (isInputRange!R\
    \ && !isInfinite!R && is(typeof(unaryFun!pred(haystack.front)) : bool))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/searching.d(723):\
    \        `std.algorithm.searching.count(R)(R haystack) if (isInputRange!R && !isInfinite!R)`\\\
    n/tmp/tmpa_t7sri4.d(35): Error: no property `any` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa_t7sri4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_pos];\n\
    \    auto after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0)\n\
    \        return \"No\";\n    if (before_dot.length != before_dot.count!(c => '0'\
    \ <= c && c <= '9'))\n        return \"No\";\n    if (before_dot.length > 3)\n\
    \        return \"No\";\n    if (!('a' <= before_dot[0] && before_dot[0] <= 'z')\
    \ && !('A' <= before_dot[0] && before_dot[0] <= 'Z'))\n        return \"No\";\n\
    \    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\"\
    )\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprprui8qw.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprprui8qw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.indexOf('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length\
    \ == 0 || after_dot.length == 0)\n        return \"No\";\n    if (before_dot.length\
    \ == 1 && before_dot[0] >= '0' && before_dot[0] <= '9')\n        return \"No\"\
    ;\n    if (before_dot.length > 1 && before_dot[0] >= '0' && before_dot[0] <= '9')\n\
    \    {\n        int count = 0;\n        foreach (i; before_dot)\n        {\n \
    \           if (i >= '0' && i <= '9')\n                count++;\n        }\n \
    \       if (count > 3)\n            return \"No\";\n    }\n    if (before_dot[0]\
    \ < 'a' || before_dot[0] > 'z')\n        if (before_dot[0] < 'A' || before_dot[0]\
    \ > 'Z')\n            return \"No\";\n    if (after_dot != \"txt\" && after_dot\
    \ != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfzpejk0q.d(20): Error: no property `indexOf` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfzpejk0q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjpqth_59.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpjpqth_59.d(26): Error: no property `count` for type `string`\\n/tmp/tmpjpqth_59.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjpqth_59.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.indexOf('.');\n    string file_name_without_extension\
    \ = file_name.substr(0, dot_index);\n    string file_extension = file_name.substr(dot_index\
    \ + 1);\n    if (file_name_without_extension.length == 0 || file_name_without_extension.length\
    \ > 8)\n        return \"No\";\n    if (file_name_without_extension.count('0',\
    \ '9') > 3)\n        return \"No\";\n    if (file_name_without_extension[0] <\
    \ 'a' || file_name_without_extension[0] > 'z')\n        return \"No\";\n    if\
    \ (valid_extensions.indexOf(file_extension) == -1)\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9nt5m_xk.d(21): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmp9nt5m_xk.d(22): Error: no property `substr` for type `string`\\n/tmp/tmp9nt5m_xk.d(23):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmp9nt5m_xk.d(26): Error:\
    \ no property `count` for type `string`\\n/tmp/tmp9nt5m_xk.d(30): Error: no property\
    \ `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9nt5m_xk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].countUntil(\"0\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.countUntil(parts[1])\
    \ == valid_extensions.length)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wg9id9j.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp9wg9id9j.d(26): Error: no property `countUntil` for type `string`\\n/tmp/tmp9wg9id9j.d(30):\
    \ Error: no property `countUntil` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9wg9id9j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    auto dot_index = file_name.find('.');\n    if (dot_index == -1)\n       \
    \ return \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n    if\
    \ (extension.length == 0 || !valid_extensions.canFind(extension))\n        return\
    \ \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.length ==\
    \ 0 || !isAlpha(name[0]))\n        return \"No\";\n    if (name.count!(c => isDigit(c))\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_buvr8qz.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmp_buvr8qz.d(25): Error: no property `canFind` for type `string[]`\\n/tmp/tmp_buvr8qz.d(28):\
    \ Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_buvr8qz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj3_eeu3t.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpj3_eeu3t.d(26): Error: no property `count` for type `string`\\n/tmp/tmpj3_eeu3t.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpj3_eeu3t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    string\
    \ ext = \"\";\n    string name = \"\";\n    foreach(c; file_name)\n    {\n   \
    \     if(c == '.')\n        {\n            dot_count++;\n            continue;\n\
    \        }\n        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n\
    \            continue;\n        }\n        if(dot_count == 0)\n        {\n   \
    \         name ~= c;\n        }\n        else\n        {\n            ext ~= c;\n\
    \        }\n    }\n    if(dot_count != 1 || digit_count > 3 || name == \"\" ||\
    \ !(name[0] >= 'a' && name[0] <= 'z') || !(name[0] >= 'A' && name[0] <= 'Z') ||\
    \ !(ext == \"txt\" || ext == \"exe\" || ext == \"dll\"))\n    {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps140j30w.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428885]\\n??:? void tmps140j30w.__unittest_L51_C1()\
    \ [0x427d91]\\n??:? void tmps140j30w.__modtest() [0x428608]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cf8f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42be9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430875]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d24]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430801]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42be75]\\n??:? runModuleUnitTests [0x42cd65]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d48]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428ccf]\\n??:? _d_run_main [0x428c3a]\\n??:? main [0x42861b]\\\
    n??:? __libc_start_main [0xc5c67554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_3d2zfy5.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp_3d2zfy5.d(26): Error: no property `count` for type `string`\\n/tmp/tmp_3d2zfy5.d(30):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_3d2zfy5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1) \n        return \"No\";\n    auto before_dot = file_name[0..dot_index];\n\
    \    auto after_dot = file_name[dot_index+1..$];\n    if (before_dot.length ==\
    \ 0 || before_dot.length > 8) \n        return \"No\";\n    if (after_dot.length\
    \ == 0 || after_dot.length > 3) \n        return \"No\";\n    if (before_dot.count!(a\
    \ => a.isDigit) > 3) \n        return \"No\";\n    if (!before_dot[0].isLetter)\
    \ \n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\"\
    \ && after_dot != \"dll\") \n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph6kxdx3a.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph6kxdx3a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_index];\n\
    \    auto after_dot = file_name[dot_index+1..$];\n    if (before_dot.empty ||\
    \ !isAlpha(before_dot[0]))\n        return \"No\";\n    if (after_dot != \"txt\"\
    \ && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n \
    \   if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptaif5mrv.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmptaif5mrv.d(25): Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptaif5mrv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count!(c => c >= '0' && c <= '9') > 3)\n        return \"No\"\
    ;\n    if (parts[0][0] < 'a' || parts[0][0] > 'z' && parts[0][0] < 'A' || parts[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (valid_extensions.count!(e => e == parts[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw5_gtw0f.d(21): Error: undefined identifier `split`\\n/tmp/tmpw5_gtw0f.d(26):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpw5_gtw0f.d(30): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpw5_gtw0f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.slice(0, dot_pos);\n    if (name.empty)\n   \
    \     return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n   \
    \ if (name.count!(c => isDigit(c)) > 3)\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2y3gb_v_.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp2y3gb_v_.d(23): Error: no property `slice` for type `string`\\n/tmp/tmp2y3gb_v_.d(26):\
    \ Error: no property `slice` for type `string`\\n/tmp/tmp2y3gb_v_.d(29): Error:\
    \ undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2y3gb_v_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\"\
    ;\n    if (file_name_parts[0].count(\"0123456789\") > 3) return \"No\";\n    if\
    \ (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z') return \"No\";\n\
    \    if (valid_extensions.count(file_name_parts[1]) == 0) return \"No\";\n   \
    \ return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqmxcfrtb.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpqmxcfrtb.d(24): Error: no property `count` for type `string`\\n/tmp/tmpqmxcfrtb.d(26):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqmxcfrtb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3858tz6h.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp3858tz6h.d(26): Error: no property `count` for type `string`\\n/tmp/tmp3858tz6h.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3858tz6h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.empty())\n\
    \        return \"No\";\n    if (!isalpha(name[0]))\n        return \"No\";\n\
    \    if (count(name.begin(), name.end(), '0') + count(name.begin(), name.end(),\
    \ '1') + count(name.begin(), name.end(), '2') + count(name.begin(), name.end(),\
    \ '3') + count(name.begin(), name.end(), '4') + count(name.begin(), name.end(),\
    \ '5') + count(name.begin(), name.end(), '6') + count(name.begin(), name.end(),\
    \ '7') + count(name.begin(), name.end(), '8') + count(name.begin(), name.end(),\
    \ '9') > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n   \
    \ alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\")\
    \ == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphrw1ps8d.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmphrw1ps8d.d(23): Error: no property `substr` for type `string`\\n/tmp/tmphrw1ps8d.d(26):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmphrw1ps8d.d(29): Error:\
    \ undefined identifier `isalpha`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier\
    \ `count`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier `count`\\n/tmp/tmphrw1ps8d.d(31):\
    \ Error: undefined identifier `count`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined\
    \ identifier `count`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier `count`\\\
    n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier `count`\\n/tmp/tmphrw1ps8d.d(31):\
    \ Error: undefined identifier `count`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined\
    \ identifier `count`\\n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier `count`\\\
    n/tmp/tmphrw1ps8d.d(31): Error: undefined identifier `count`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphrw1ps8d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    import std.algorithm : count;\n    import std.array : array;\n\
    \    import std.conv : to;\n    import std.range : take;\n    import std.string\
    \ : split;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \   \nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdxuyi6mr.d(70): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdxuyi6mr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\
    \ return \"No\";\n    string ext = file_name.substr(dot_pos + 1);\n    if (ext\
    \ != \"txt\" && ext != \"exe\" && ext != \"dll\") return \"No\";\n    string name\
    \ = file_name.substr(0, dot_pos);\n    if (name.empty()) return \"No\";\n    if\
    \ (!isalpha(name[0])) return \"No\";\n    int count = 0;\n    foreach (c; name)\n\
    \    {\n        if (isdigit(c)) count++;\n    }\n    if (count > 3) return \"\
    No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc268wjmx.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpc268wjmx.d(22): Error: no property `substr` for type `string`\\n/tmp/tmpc268wjmx.d(24):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpc268wjmx.d(25): Error:\
    \ no property `empty` for type `string`\\n/tmp/tmpc268wjmx.d(26): Error: undefined\
    \ identifier `isalpha`\\n/tmp/tmpc268wjmx.d(30): Error: undefined identifier `isdigit`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc268wjmx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    // your code here\n    int dot_index = file_name.find('.');\n\
    \    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length\
    \ == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length\
    \ == 0 || after_dot.length > 3)\n        return \"No\";\n    if (before_dot.count('0'..'9')\
    \ > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] >\
    \ 'z')\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"\
    exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5veiyasu.d(30): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5veiyasu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int letter_count\
    \ = 0;\n    int length = file_name.length;\n    string file_type = \"\";\n   \
    \ string file_name_no_type = \"\";\n    string[] file_types = [\"txt\", \"exe\"\
    , \"dll\"];\n    bool is_valid = true;\n    for (int i = 0; i < length; i++)\n\
    \    {\n        if (file_name[i] == '.')\n        {\n            dot_count++;\n\
    \            file_type = file_name[i+1..$];\n            file_name_no_type = file_name[0..i-1];\n\
    \        }\n        if (file_name[i] >= '0' && file_name[i] <= '9')\n        {\n\
    \            digit_count++;\n        }\n        if ((file_name[i] >= 'a' && file_name[i]\
    \ <= 'z') || (file_name[i] >= 'A' && file_name[i] <= 'Z'))\n        {\n      \
    \      letter_count++;\n        }\n    }\n    if (dot_count != 1)\n    {\n   \
    \     is_valid = false;\n    }\n    if (digit_count > 3)\n    {\n        is_valid\
    \ = false;\n    }\n    if (letter_count == 0)\n    {\n        is_valid = false;\n\
    \    }\n    if (file_name_no_type.length == 0)\n    {\n        is_valid = false;\n\
    \    }\n    if (file_type.length == 0)\n    {\n        is_valid = false;\n   \
    \ }\n    if (file_type != \"txt\" && file_type != \"exe\" && file_type != \"dll\"\
    )\n    {\n        is_valid = false;\n    }\n    if (is_valid)\n    {\n       \
    \ return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_02og1nc.d(23): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_02og1nc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmptbxu1_.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpmptbxu1_.d(26): Error: no property `count` for type `string`\\n/tmp/tmpmptbxu1_.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpmptbxu1_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (!valid_extensions.contains(file_name_split[1]))\n  \
    \      return \"No\";\n    if (!file_name_split[0][0].isAlpha)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpexq73tm4.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpexq73tm4.d(26): Error: no property `count` for type `string`\\n/tmp/tmpexq73tm4.d(28):\
    \ Error: no property `contains` for type `string[]`\\n/tmp/tmpexq73tm4.d(30):\
    \ Error: no property `isAlpha` for type `immutable(char)`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpexq73tm4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n  \
    \      return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppddy_md4.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmppddy_md4.d(26): Error: no property `count` for type `string`\\n/tmp/tmppddy_md4.d(28):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppddy_md4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\"\
    ;\n    if (file_name_parts[0].length > 3) return \"No\";\n    if (file_name_parts[0].count!(c\
    \ => c >= '0' && c <= '9') > 3) return \"No\";\n    if (file_name_parts[0][0]\
    \ < 'a' || file_name_parts[0][0] > 'z') return \"No\";\n    if (file_name_parts[1]\
    \ !in valid_extensions) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2p9bixk.d(21): Error: undefined identifier `split`\\n/tmp/tmps2p9bixk.d(25):\
    \ Error: no property `count` for type `string`\\n/tmp/tmps2p9bixk.d(27): Error:\
    \ incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string`\
    \ and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2p9bixk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (!isAlpha(parts[0][0]))\n\
    \        return \"No\";\n    if (!valid_extensions.contains(parts[1]))\n     \
    \   return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate =\
    \ file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n   \
    \ assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprtd86knh.d(21): Error: undefined identifier `split`\\n/tmp/tmprtd86knh.d(28):\
    \ Error: undefined identifier `isAlpha`\\n/tmp/tmprtd86knh.d(30): Error: no property\
    \ `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprtd86knh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2) return\
    \ \"No\";\n    if (parts[0].length == 0) return \"No\";\n    if (parts[0].count(\"\
    0-9\") > 3) return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z') return\
    \ \"No\";\n    if (valid_extensions.find(parts[1]) == -1) return \"No\";\n   \
    \ return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n\
    \    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx8htt05e.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpx8htt05e.d(24): Error: no property `count` for type `string`\\n/tmp/tmpx8htt05e.d(26):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpx8htt05e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    // your code here\n    string[] valid_extensions = [\"txt\"\
    , \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string extension = file_name[dot_index +\
    \ 1 .. $];\n    if (extension.length == 0 || !valid_extensions.contains(extension))\n\
    \        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if\
    \ (name.length == 0 || !name[0].isLetter)\n        return \"No\";\n    int digits_count\
    \ = 0;\n    foreach (c; name)\n        if (c.isDigit)\n            digits_count++;\n\
    \    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_osa6sj7.d(22): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmp_osa6sj7.d(26): Error: no property `contains` for type `string[]`\\n/tmp/tmp_osa6sj7.d(29):\
    \ Error: no property `isLetter` for type `immutable(char)`\\n/tmp/tmp_osa6sj7.d(33):\
    \ Error: no property `isDigit` for type `immutable(char)`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_osa6sj7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    string before_dot\
    \ = file_name[0..dot_pos-1];\n    string after_dot = file_name[dot_pos+1..$];\n\
    \    string before_dot_without_digits = before_dot.replace(\"0\", \"\").replace(\"\
    1\", \"\").replace(\"2\", \"\").replace(\"3\", \"\").replace(\"4\", \"\").replace(\"\
    5\", \"\").replace(\"6\", \"\").replace(\"7\", \"\").replace(\"8\", \"\").replace(\"\
    9\", \"\");\n    if(before_dot.length == before_dot_without_digits.length && before_dot.length\
    \ != 0 && (after_dot == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\"\
    ))\n    {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppc8h6cuz.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmppc8h6cuz.d(23): Error: no property `replace` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppc8h6cuz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0123456789\") > 3)\n\
    \        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwjxgqlqf.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpwjxgqlqf.d(26): Error: no property `count` for type `string`\\n/tmp/tmpwjxgqlqf.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwjxgqlqf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[0][0] < 'A'\
    \ || parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.find(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplc91cyv9.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmplc91cyv9.d(26): Error: no property `count` for type `string`\\n/tmp/tmplc91cyv9.d(32):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplc91cyv9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    string ext = file_name.substr(dot_pos+1);\n\
    \    string name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c;\
    \ name)\n    {\n        if(isdigit(c))\n            digits++;\n    }\n    if(digits\
    \ > 3)\n        return \"No\";\n    if(name.length == 0)\n        return \"No\"\
    ;\n    if(!isalpha(name[0]))\n        return \"No\";\n    if(ext != \"txt\" &&\
    \ ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps4h0u708.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmps4h0u708.d(21): Error: no property `substr` for type `string`\\n/tmp/tmps4h0u708.d(22):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmps4h0u708.d(26): Error:\
    \ undefined identifier `isdigit`\\n/tmp/tmps4h0u708.d(33): Error: undefined identifier\
    \ `isalpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4h0u708.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1v33fbrs.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp1v33fbrs.d(26): Error: no property `count` for type `string`\\n/tmp/tmp1v33fbrs.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1v33fbrs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0][0] < 'a' || parts[0][0] > 'z')\n        return \"No\";\n   \
    \ if (parts[1] !in valid_extensions)\n        return \"No\";\n    if (parts[0].count!(c\
    \ => c >= '0' && c <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpilu8qgom.d(21): Error: undefined identifier `split`\\n/tmp/tmpilu8qgom.d(28):\
    \ Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and\
    \ `string[]`\\n/tmp/tmpilu8qgom.d(30): Error: no property `count` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpilu8qgom.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].length > 3)\n        return \"\
    No\";\n    if (file_name_parts[0].length == 3)\n    {\n        if (file_name_parts[0].count(\"\
    0-9\") != 3)\n            return \"No\";\n    }\n    if (file_name_parts[0].length\
    \ == 2)\n    {\n        if (file_name_parts[0].count(\"0-9\") != 2)\n        \
    \    return \"No\";\n    }\n    if (file_name_parts[0].length == 1)\n    {\n \
    \       if (file_name_parts[0].count(\"0-9\") != 1)\n            return \"No\"\
    ;\n    }\n    if (file_name_parts[0].count(\"a-zA-Z\") != 1)\n        return \"\
    No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn0p9t6x1.d(21): Error: undefined identifier `split`\\n/tmp/tmpn0p9t6x1.d(30):\
    \ Error: no property `count` for type `string`\\n/tmp/tmpn0p9t6x1.d(35): Error:\
    \ no property `count` for type `string`\\n/tmp/tmpn0p9t6x1.d(40): Error: no property\
    \ `count` for type `string`\\n/tmp/tmpn0p9t6x1.d(43): Error: no property `count`\
    \ for type `string`\\n/tmp/tmpn0p9t6x1.d(45): Error: no property `count` for type\
    \ `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn0p9t6x1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    if (name.length == 0 || !isalpha(name[0]))\n        return \"No\";\n    if\
    \ (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n   \
    \     return \"No\";\n    if (name.count('0', '9') > 3)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoemsckhl.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpoemsckhl.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpoemsckhl.d(22):\
    \ Error: no property `substr` for type `string`\\n/tmp/tmpoemsckhl.d(23): Error:\
    \ undefined identifier `isalpha`\\n/tmp/tmpoemsckhl.d(27): Error: no property\
    \ `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpoemsckhl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_index];\n\
    \    auto after_dot = file_name[dot_index+1..$];\n    if (before_dot.length ==\
    \ 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length\
    \ == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return\
    \ \"No\";\n    if (before_dot.count!(a => a >= 'a' && a <= 'z') == 0 && before_dot.count!(a\
    \ => a >= 'A' && a <= 'Z') == 0)\n        return \"No\";\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphv04xfiq.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphv04xfiq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto dot_index_2 = file_name.find('.', dot_index\
    \ + 1);\n    if (dot_index_2 != -1)\n        return \"No\";\n    auto digits_count\
    \ = 0;\n    foreach (i, c; file_name)\n    {\n        if (c >= '0' && c <= '9')\n\
    \            digits_count++;\n    }\n    if (digits_count > 3)\n        return\
    \ \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n    if (extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return\
    \ \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.empty)\n \
    \       return \"No\";\n    if (!(name[0] >= 'a' && name[0] <= 'z') && !(name[0]\
    \ >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkft81nwj.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpkft81nwj.d(23): Error: no property `find` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkft81nwj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_pos + 1);\n\
    \    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"\
    No\";\n    auto name = file_name.slice(0, dot_pos);\n    if (name.length == 0)\n\
    \        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    auto digits = 0;\n    foreach\
    \ (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n\
    \    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6qiiuef1.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp6qiiuef1.d(23): Error: no property `slice` for type `string`\\n/tmp/tmp6qiiuef1.d(26):\
    \ Error: no property `slice` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6qiiuef1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].count(\"0123456789\") > 3)\n\
    \        return \"No\";\n    if (file_name_split[0][0] < 'a' || file_name_split[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_split[1])\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_7gb457p.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp_7gb457p.d(26): Error: no property `count` for type `string`\\n/tmp/tmp_7gb457p.d(30):\
    \ Error: no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_7gb457p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count!(c => c >= '0' && c <=\
    \ '9') > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.count!(ext => ext ==\
    \ file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3i1kovsg.d(21): Error: undefined identifier `split`\\n/tmp/tmp3i1kovsg.d(26):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp3i1kovsg.d(30): Error:\
    \ no property `count` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp3i1kovsg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmt4xznc9.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpmt4xznc9.d(26): Error: no property `count` for type `string`\\n/tmp/tmpmt4xznc9.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpmt4xznc9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string\
    \ after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length\
    \ > 8)\n        return \"No\";\n    if (after_dot.length == 0 || after_dot.length\
    \ > 3)\n        return \"No\";\n    if (before_dot.count('0'..'9') > 3)\n    \
    \    return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n   \
    \     return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" &&\
    \ after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\n/*\n\
    Create a function which takes a string representing a file's name, and returns\n\
    \    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A\
    \ file's name is considered to be valid if and only if all the following conditions\
    \ \n    are met:\n    - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n    - The file's name contains exactly one dot '.'\n    -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"\
    example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n\
    \        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n   \n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjytcqk8l.d(29): Error: found `..` when expecting `,`\\n/tmp/tmpjytcqk8l.d(59):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjytcqk8l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    auto dot_pos_end = dot_pos + 1;\n    if (dot_pos\
    \ == 0)\n        return \"No\";\n    if (file_name[dot_pos_end] == '\\0')\n  \
    \      return \"No\";\n    auto digits_count = 0;\n    for (int i = 0; i < dot_pos;\
    \ i++)\n    {\n        if (file_name[i] >= '0' && file_name[i] <= '9')\n     \
    \       digits_count++;\n        if (digits_count > 3)\n            return \"\
    No\";\n    }\n    auto file_type = file_name.slice(dot_pos_end);\n    if (file_type\
    \ == \"txt\" || file_type == \"exe\" || file_type == \"dll\")\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgss8bhgq.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpgss8bhgq.d(36): Error: no property `slice` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgss8bhgq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return\
    \ \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length\
    \ == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string\
    \ name = file_name[0 .. dot_index];\n    if (name.length == 0 || !(name[0] >=\
    \ 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return\
    \ \"No\";\n    int count = 0;\n    foreach (c; name)\n        if (c >= '0' &&\
    \ c <= '9')\n            count++;\n    if (count > 3)\n        return \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpytzc_hth.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmpytzc_hth.d(25): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytzc_hth.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (parts[0][0]\
    \ < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.indexOf(parts[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppcbl_uyz.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmppcbl_uyz.d(26): Error: no property `count` for type `string`\\n/tmp/tmppcbl_uyz.d(30):\
    \ Error: no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppcbl_uyz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n\
    \    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n   \
    \ foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n           \
    \ digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n \
    \   if(!(extension in valid_extensions))\n        return \"No\";\n    if(name.length\
    \ == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') &&\
    \ !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwpzjwonm.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmpwpzjwonm.d(32): Error: incompatible types for `(extension) in (valid_extensions)`:\
    \ `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpwpzjwonm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    auto extension = file_name.substr(dot_index\
    \ + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension !=\
    \ \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0, dot_index);\n\
    \    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0]\
    \ > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    if (name.count('0')\
    \ + name.count('1') + name.count('2') + name.count('3') + name.count('4') + name.count('5')\
    \ + name.count('6') + name.count('7') + name.count('8') + name.count('9') > 3)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp08f3f5rf.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmp08f3f5rf.d(23): Error: no property `substr` for type `string`\\n/tmp/tmp08f3f5rf.d(26):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp08f3f5rf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n  \
    \      return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp748fquyi.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp748fquyi.d(26): Error: no property `count` for type `string`\\n/tmp/tmp748fquyi.d(28):\
    \ Error: no property `contains` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp748fquyi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find(\".\");\n    if (dot_index\
    \ == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n\
    \    string after_dot = file_name[dot_index + 1..$];\n    if (before_dot.length\
    \ == 0 || !isLetter(before_dot[0]))\n        return \"No\";\n    if (after_dot.length\
    \ == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot !=\
    \ \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"\
    No\";\n    int digits_count = 0;\n    foreach (c; before_dot)\n    {\n       \
    \ if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count >\
    \ 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnjvpvtzd.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpnjvpvtzd.d(25): Error: undefined identifier `isLetter`\\n/tmp/tmpnjvpvtzd.d(34):\
    \ Error: undefined identifier `isDigit`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnjvpvtzd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_index = file_name.find(\".\");\n    string name = file_name[0..dot_index];\n\
    \    string extension = file_name[dot_index+1..$];\n    if(name.length == 0 ||\
    \ name[0] < 'a' || name[0] > 'z')\n        return \"No\";\n    if(extension.length\
    \ == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    int\
    \ digits_count = 0;\n    foreach(c; name)\n        if(c >= '0' && c <= '9')\n\
    \            digits_count++;\n    if(digits_count > 3)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl5ztw4ew.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmpl5ztw4ew.d(26): Error: no property `canFind` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl5ztw4ew.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].filter!(a => a >= '0' && a <=\
    \ '9').length > 3)\n        return \"No\";\n    if (file_name_split[0][0] < 'a'\
    \ || file_name_split[0][0] > 'z' && file_name_split[0][0] < 'A' || file_name_split[0][0]\
    \ > 'Z')\n        return \"No\";\n    if (valid_extensions.filter!(a => a == file_name_split[1]).length\
    \ == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_hsxgh39.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmp_hsxgh39.d(26): Error: no property `filter` for type `string`\\n/tmp/tmp_hsxgh39.d(30):\
    \ Error: no property `filter` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_hsxgh39.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1) return \"No\";\n    auto sub_str_before_dot = file_name[0..dot_pos];\n \
    \   auto sub_str_after_dot = file_name[dot_pos+1..$];\n    if (sub_str_before_dot.count!(a\
    \ => a.isDigit) > 3) return \"No\";\n    if (sub_str_before_dot.empty || !sub_str_before_dot[0].isLetter)\
    \ return \"No\";\n    if (sub_str_after_dot != \"txt\" && sub_str_after_dot !=\
    \ \"exe\" && sub_str_after_dot != \"dll\") return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7tw_p5u.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7tw_p5u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].filter!(c => c.isDigit).length\
    \ > 3)\n        return \"No\";\n    if (file_name_parts[0][0].isDigit)\n     \
    \   return \"No\";\n    if (valid_extensions.indexOf(file_name_parts[1]) == -1)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpub0bsecu.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpub0bsecu.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpub0bsecu.d(28):\
    \ Error: no property `isDigit` for type `immutable(char)`\\n/tmp/tmpub0bsecu.d(30):\
    \ Error: no property `indexOf` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpub0bsecu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    auto dot_index = file_name.find('.');\n    if (dot_index == -1)\n       \
    \ return \"No\";\n    auto extension = file_name[dot_index+1..$];\n    if (extension.length\
    \ == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    auto\
    \ name = file_name[0..dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n\
    \        return \"No\";\n    if (name.count!(c => isDigit(c)) > 3)\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptx6ef4bk.d(21): Error: no property `find` for type `string`\\\
    n/tmp/tmptx6ef4bk.d(25): Error: no property `canFind` for type `string[]`\\n/tmp/tmptx6ef4bk.d(28):\
    \ Error: undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptx6ef4bk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension\
    \ = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n\
    \    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >=\
    \ '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count >\
    \ 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\"\
    \ && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n\
    \        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A'\
    \ || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbvl1z97a.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpbvl1z97a.d(21): Error: no property `substr` for type `string`\\n/tmp/tmpbvl1z97a.d(22):\
    \ Error: no property `substr` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbvl1z97a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length\
    \ != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n      \
    \  return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0]\
    \ > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n\
    \        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmperr17ciz.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmperr17ciz.d(26): Error: no property `count` for type `string`\\n/tmp/tmperr17ciz.d(30):\
    \ Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`:\
    \ `string` and `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmperr17ciz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    bool valid\
    \ = true;\n    foreach(c; file_name)\n    {\n        if(c == '.')\n        {\n\
    \            dot_count++;\n        }\n        else if('0' <= c && c <= '9')\n\
    \        {\n            digit_count++;\n        }\n    }\n    if(dot_count !=\
    \ 1 || digit_count > 3)\n    {\n        valid = false;\n    }\n    else\n    {\n\
    \        string[] parts = file_name.split(\".\");\n        if(parts[0].length\
    \ == 0 || !('a' <= parts[0][0] && parts[0][0] <= 'z') && !('A' <= parts[0][0]\
    \ && parts[0][0] <= 'Z'))\n        {\n            valid = false;\n        }\n\
    \        else if(parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"\
    dll\")\n        {\n            valid = false;\n        }\n    }\n    return valid\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpukssh9js.d(40): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpukssh9js.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n \
    \       return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].length > 3)\n        return \"No\";\n    if (valid_extensions.indexOf(parts[1])\
    \ == -1)\n        return \"No\";\n    if (!isAlpha(parts[0][0]))\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn9d6hrcw.d(21): Error: undefined identifier `split`\\n/tmp/tmpn9d6hrcw.d(28):\
    \ Error: no property `indexOf` for type `string[]`\\n/tmp/tmpn9d6hrcw.d(30): Error:\
    \ undefined identifier `isAlpha`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpn9d6hrcw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length\
    \ != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n   \
    \     return \"No\";\n    if (file_name_split[0].count(\"0-9\") > 3)\n       \
    \ return \"No\";\n    if (file_name_split[0][0] < 'a' || file_name_split[0][0]\
    \ > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_split[1])\
    \ == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwy94yrao.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpwy94yrao.d(26): Error: no property `count` for type `string`\\n/tmp/tmpwy94yrao.d(30):\
    \ Error: no property `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwy94yrao.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int count = 0;\n    int dot = 0;\n    string[] valid_ext\
    \ = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\"\
    .\");\n    foreach(char c; file_name_split[0])\n    {\n        if(c >= '0' &&\
    \ c <= '9')\n            count++;\n    }\n    if(count > 3)\n        return \"\
    No\";\n    if(file_name_split.length != 2)\n        return \"No\";\n    if(file_name_split[0].length\
    \ == 0)\n        return \"No\";\n    if(!(file_name_split[0][0] >= 'a' && file_name_split[0][0]\
    \ <= 'z') && !(file_name_split[0][0] >= 'A' && file_name_split[0][0] <= 'Z'))\n\
    \        return \"No\";\n    foreach(string s; valid_ext)\n    {\n        if(s\
    \ == file_name_split[1])\n            dot = 1;\n    }\n    if(dot == 0)\n    \
    \    return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7v7dllcr.d(23): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7v7dllcr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos ==\
    \ -1)\n        return \"No\";\n    if (dot_pos == 0)\n        return \"No\";\n\
    \    if (file_name.count('.') != 1)\n        return \"No\";\n    if (file_name[dot_pos\
    \ + 1..$].count('0','1','2','3','4','5','6','7','8','9') > 3)\n        return\
    \ \"No\";\n    if (file_name[0..dot_pos].count('0','1','2','3','4','5','6','7','8','9')\
    \ > 0)\n        return \"No\";\n    if (file_name[dot_pos + 1..$] != \"txt\" &&\
    \ file_name[dot_pos + 1..$] != \"exe\" && file_name[dot_pos + 1..$] != \"dll\"\
    )\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqaaktcs1.d(20): Error: no property `find` for type `string`\\\
    n/tmp/tmpqaaktcs1.d(25): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqaaktcs1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    string[] parts = file_name.split(\".\");\n    if (parts.length != 2)\n  \
    \      return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n\
    \    if (parts[0].filter!(c => c.isDigit).length > 3)\n        return \"No\";\n\
    \    if (!parts[0].front.isLetter)\n        return \"No\";\n    if (!valid_extensions.any!(ext\
    \ => ext == parts[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgpkr0i27.d(21): Error: no property `split` for type `string`\\\
    n/tmp/tmpgpkr0i27.d(26): Error: no property `filter` for type `string`\\n/tmp/tmpgpkr0i27.d(28):\
    \ Error: no property `front` for type `string`\\n/tmp/tmpgpkr0i27.d(30): Error:\
    \ no property `any` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpgpkr0i27.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
