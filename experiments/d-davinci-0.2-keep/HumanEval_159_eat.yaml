name: HumanEval_159_eat
language: humaneval_to_dlang.py
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
  \ and you already have eaten a certain number of carrots,\n    but now you need\
  \ to eat more carrots to complete the day's meals.\n    you should return an array\
  \ of [ total number of eaten carrots after your meals,\n                       \
  \             the number of carrots left after your meals ]\n    if there are not\
  \ enough remaining carrots, you will eat all remaining carrots, but will still be\
  \ hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9)\
  \ -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n \
  \   \n    Variables:\n    @number : integer\n        the number of carrots that\
  \ you have eaten.\n    @need : integer\n        the number of carrots that you need\
  \ to eat.\n    @remaining : integer\n        the number of remaining carrots thet\
  \ exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need\
  \ <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long\
  \ number, long need, long remaining) \n"
tests: "unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
  \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
  \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n  \
  \  assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L)\
  \ == [5L, 0L]);\n}\nvoid main(){}"
completions: ["{\n    return [min(number + remaining, need), max(0, number + remaining\
    \ - need)];\n}", "{\n    long[] result = new long[2];\n    if(number + need <=\
    \ remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, need), max(remaining - (need - number), 0L)];\n}", "{\n    return\
    \ [number + min(need, remaining), max(0, remaining - need)];\n}", "{\n    long[]\
    \ result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n  \
    \  if (remaining >= need)\n    {\n        result[0] = number + need;\n       \
    \ result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[2];\n    result[0] = number + need;\n    result[1]\
    \ = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [min(need, remaining) + number, max(0,\
    \ remaining - need)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - need + number, 0L)];\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(0, number +\
    \ remaining - need)];\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    // your code here\n    long[] result = new long[2];\n \
    \   if(remaining < need)\n    {\n        result[0] = number + remaining;\n   \
    \     result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  return [min(number + remaining, need), max(remaining - need + number, 0L)];\n\
    }", "{\n    long[] result = new long[2];\n    if (need > remaining)\n    {\n \
    \       result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}", "{\n    return [number + min(need, remaining),\
    \ max(0, remaining - need)];\n}", "{\n    if(number < 0 || number > 1000 || need\
    \ < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return null;\n\
    \    if(remaining < need)\n        return [number + remaining, 0];\n    else\n\
    \        return [number + need, remaining - need];\n}", "{\n    long[] result\
    \ = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }", "{\n    return [min(number + remaining, need), max(0, remaining - (need -\
    \ number))];\n}", "{\n    long total = number + need;\n    long left = total -\
    \ remaining;\n    if (left > 0)\n    {\n        return [remaining, 0];\n    }\n\
    \    else\n    {\n        return [total, abs(left)];\n    }\n}", "{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    if(need > remaining)\n        return [number\
    \ + remaining, 0];\n    else\n        return [number + need, remaining - need];\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n \
    \       result[0] = number + need;\n        result[1] = remaining - need;\n  \
    \  }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    return [min(number + remaining,\
    \ need), max(remaining - (need - number), 0L)];\n}", "{\n    return [min(number\
    \ + remaining, need), max(remaining - need + number, 0L)];\n}", "{\n    return\
    \ [min(number + remaining, need), max(remaining - (need - number), 0L)];\n}",
  "{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n\
    \    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n     \
    \   result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, need), max(0, number + remaining - need)];\n}", "{\n    long[]\
    \ result = new long[2];\n    if (remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [min(number + remaining, need), max(0,\
    \ number + remaining - need)];\n}", "{\n    long[] result = new long[2];\n   \
    \ if (remaining < need)\n    {\n        result[0] = number + remaining;\n    \
    \    result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  return [min(number + remaining, need), max(remaining - need + number, 0L)];\n\
    }", "{\n    return [min(number + remaining, need), max(remaining - (need - number),\
    \ 0L)];\n}", "{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - (number\
    \ + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number\
    \ + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n   \
    \     result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(remaining -\
    \ need + number, 0L)];\n}", "{\n    long[] result = new long[2];\n    if (number\
    \ + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - (number + need);\n    }\n    else\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1]\
    \ = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, need), max(0, need - number - remaining)];\n}", "{\n    return\
    \ [min(number + remaining, need), max(0, number + remaining - need)];\n}", "{\n\
    \    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    result[0] = number +\
    \ min(need, remaining);\n    result[1] = max(0, remaining - need);\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - (number\
    \ + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number\
    \ + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n   \
    \     result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(remaining -\
    \ (need - number), 0L)];\n}", "{\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)];\n}", "{\n    long[] result = new long[2];\n    if (remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, number + need), max(remaining - need, 0L)];\n}", "{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number\
    \ + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n   \
    \     result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(remaining -\
    \ (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long total = number + need;\n    long left = remaining\
    \ - need;\n    if(left < 0)\n    {\n        left = 0;\n    }\n    return [total,\
    \ left];\n}", "{\n    if (remaining < need)\n        return [number + remaining,\
    \ 0];\n    else\n        return [number + need, remaining - need];\n}", "{\n \
    \   return [min(number + remaining, need), max(0, number + remaining - need)];\n\
    }", "{\n    // your code here\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, number + need), max(remaining - need, 0)];\n}", "{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + min(need, remaining);\n    result[1] = max(0, remaining - need);\n\
    \    return result;\n}", "{\n    if(remaining >= need)\n        return [number\
    \ + need, remaining - need];\n    else\n        return [number + remaining, 0];\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n  \
    \      result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}", "{\n    return [min(number + remaining, number\
    \ + need), max(remaining - need, 0L)];\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1]\
    \ < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000\
    \ || remaining < 0 || remaining > 1000)\n    {\n        return result;\n    }\n\
    \    if(remaining >= need)\n    {\n        result[0] = number + need;\n      \
    \  result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1]\
    \ = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number\
    \ + remaining;\n        result[1] = 0;\n    }\n    return result;\n}", "{\n  \
    \  return [min(number + remaining, need), max(remaining - need + number, 0L)];\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n  \
    \      result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}", "{\n    return [min(number + remaining, need),\
    \ max(remaining - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n\
    \    if (remaining >= need)\n    {\n        result[0] = number + need;\n     \
    \   result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    result[0] = number;\n    result[1] = remaining;\n\
    \    if (need > remaining)\n    {\n        result[0] += remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[0] += need;\n        result[1]\
    \ -= need;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    if(remaining < need)\n    {\n        result[0] = number + remaining;\n  \
    \      result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  if(remaining < need)\n        return [number + remaining, 0];\n    else\n \
    \       return [number + need, remaining - need];\n}", "{\n    return [min(number\
    \ + remaining, need), max(remaining - need + number, 0L)];\n}", "{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - (number + need);\n    }\n\
    \    else\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n  \
    \  if(remaining < need)\n    {\n        result[0] = number + remaining;\n    \
    \    result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  return [min(number + remaining, need), max(0, need - number - remaining)];\n\
    }", "{\n    return [min(number + remaining, need), max(remaining - (need - number),\
    \ 0L)];\n}", "{\n    long[] result = new long[2];\n    if(remaining < need)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    else\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    return result;\n}", "{\n    return [min(number + remaining,\
    \ need), max(remaining - (need - number), 0L)];\n}", "{\n    return [number +\
    \ min(need, remaining), max(0, remaining - need)];\n}", "{\n    long[] result\
    \ = new long[2];\n    result[0] = number + need;\n    result[1] = remaining -\
    \ need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    result[0] = number + need;\n   \
    \ result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    return [min(number + remaining, need), max(0, number + remaining - need)];\n\
    }", "{\n    long[] result = new long[2];\n    result[0] = number + need;\n   \
    \ result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if (remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }", "{\n    return [number + min(need, remaining), max(0, remaining - need)];\n\
    }", "{\n    return [need + number, max(0, remaining - need)];\n}", "{\n    if(remaining\
    \ < need)\n        return [number + remaining, 0];\n    else\n        return [number\
    \ + need, remaining - need];\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining < need)\n    {\n        result[0] = number +\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n \
    \       result[0] = number + need;\n        result[1] = remaining - need;\n  \
    \  }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    return [min(number + remaining,\
    \ need), max(remaining - (need - number), 0L)];\n}", "{\n    long[] result = new\
    \ long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n  \
    \  {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if (remaining < need)\n    {\n \
    \       result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(need > remaining)\n    {\n        result[0] = number +\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    result[0] = number + need;\n   \
    \ if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1]\
    \ = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[2];\n    if(number\
    \ + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - (number + need);\n    }\n    else\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1]\
    \ = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, need), max(remaining - need + number, 0L)];\n}", "{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n\
    \    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n     \
    \   result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n\
    \    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    if(remaining >= need)\n    {\n        result[0] = number + need;\n      \
    \  result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] =\
    \ number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(need > remaining)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    else\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1]\
    \ < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] =\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1]\
    \ = remaining - result[0];\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    result[0] = number + need;\n    result[1] = remaining -\
    \ need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)];\n}", "{\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)];\n}", "{\n    return [min(number\
    \ + remaining, need), max(number + remaining - need, 0L)];\n}", "{\n    long[]\
    \ result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] =\
    \ number + need;\n        result[1] = remaining - need;\n    }\n    else\n   \
    \ {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if (remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(remaining -\
    \ need + number, 0L)];\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - need + number, 0L)];\n}", "{\n    return [min(number + remaining, need), max(0,\
    \ number + remaining - need)];\n}", "{\n    return [min(number + remaining, need),\
    \ max(remaining - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n\
    \    if(need > remaining)\n    {\n        result[0] = number + remaining;\n  \
    \      result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  return [number + min(need, remaining), max(0, remaining - need)];\n}", "{\n\
    \    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    else\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(remaining -\
    \ need + number, 0L)];\n}", "{\n    return [min(number + remaining, need), max(remaining\
    \ - (need - number), 0L)];\n}", "{\n    return [min(number + remaining, need),\
    \ max(remaining - (need - number), 0L)];\n}", "{\n    long[] result = new long[2];\n\
    \    if(need > remaining)\n    {\n        result[0] = number + remaining;\n  \
    \      result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n\
    \    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n     \
    \   result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[2];\n    if (remaining < need)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + min(need, remaining);\n    result[1]\
    \ = max(0, remaining - need);\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    return [min(number + remaining, need), max(0, number +\
    \ remaining - need)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + min(need, remaining);\n    result[1] = max(0, remaining - need);\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + min(need, remaining);\n    result[1] = max(0, remaining - need);\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ < need)\n    {\n        result[0] = number + remaining;\n        result[1] =\
    \ 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1]\
    \ = remaining - need;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining < need)\n    {\n        result[0] = number +\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n \
    \       result[0] = number + need;\n        result[1] = remaining - need;\n  \
    \  }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + min(need, remaining);\n    result[1] = max(0, remaining\
    \ - need);\n    return result;\n}", "{\n    long[] result = new long[2];\n   \
    \ if(need > remaining)\n    {\n        result[0] = number + remaining;\n     \
    \   result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n\
    \        result[1] = remaining - need;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n    \
    \    result[0] = number + need;\n        result[1] = remaining - need;\n    }\n\
    \    return result;\n}", "{\n    if (number + need <= remaining)\n        return\
    \ [number + need, remaining - number - need];\n    else\n        return [remaining\
    \ + number, 0];\n}", "{\n    long[] result = new long[2];\n    if(remaining >=\
    \ need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    return [min(number + remaining,\
    \ need), max(0, number + remaining - need)];\n}", "{\n    return [number + min(need,\
    \ remaining), max(0, remaining - need)];\n}", "{\n    return [min(number + remaining,\
    \ need), max(remaining - (need - number), 0L)];\n}", "{\n    return [min(number\
    \ + remaining, need), max(0, number + remaining - need)];\n}", "{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n   \
    \     result[1] = 0;\n    }\n    return result;\n}", "{\n    long eaten = number\
    \ + min(need, remaining);\n    long left = max(0, remaining - need);\n    return\
    \ [eaten, left];\n}", "{\n    long[] result = new long[2];\n    result[0] = number\
    \ + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n \
    \       result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    result[0] = number +\
    \ need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n   \
    \     result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1]\
    \ < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    return [number + min(need, remaining), max(0,\
    \ remaining - need)];\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] =\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1]\
    \ = remaining - result[0];\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + remaining, need), max(remaining - (need - number), 0L)];\n}", "{\n    return\
    \ [min(number + remaining, need), max(remaining - (need - number), 0L)];\n}",
  "{\n    return [min(number + remaining, number + need), max(remaining - need, 0)];\n\
    }", "{\n    long[] result = new long[2];\n    result[0] = number + need;\n   \
    \ result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0]\
    \ = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[2];\n    result[0] = number + min(need, remaining);\n\
    \    result[1] = max(0, remaining - need);\n    return result;\n}", "{\n    return\
    \ [min(number + remaining, need), max(remaining - need + number, 0L)];\n}", "{\n\
    \    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0]\
    \ > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n\
    \    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + min(need, remaining);\n    result[1] = max(0, remaining - need);\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if (number\
    \ >= need)\n    {\n        result[0] = number;\n        result[1] = remaining;\n\
    \    }\n    else\n    {\n        if (remaining >= need - number)\n        {\n\
    \            result[0] = need;\n            result[1] = remaining - (need - number);\n\
    \        }\n        else\n        {\n            result[0] = number + remaining;\n\
    \            result[1] = 0;\n        }\n    }\n    return result;\n}", "{\n  \
    \  long eaten = number + min(need, remaining);\n    long left = max(0, remaining\
    \ - need);\n    return [eaten, left];\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1]\
    \ < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number +\
    \ need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n     \
    \   result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    return [min(number + remaining,\
    \ need), max(0, need - number - remaining)];\n}", "{\n    long[] result = new\
    \ long[2];\n    if(number >= need)\n    {\n        result[0] = number;\n     \
    \   result[1] = remaining;\n    }\n    else\n    {\n        if(remaining >= need\
    \ - number)\n        {\n            result[0] = need;\n            result[1] =\
    \ remaining - (need - number);\n        }\n        else\n        {\n         \
    \   result[0] = number + remaining;\n            result[1] = 0;\n        }\n \
    \   }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
