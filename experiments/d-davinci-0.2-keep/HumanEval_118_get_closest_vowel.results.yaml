name: HumanEval_118_get_closest_vowel
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min = int.max;\n   \
    \ foreach(v; vowels)\n    {\n        index = word.find(v);\n        if(index !=\
    \ -1)\n        {\n            if(index != 0 && index != word.length - 1)\n   \
    \         {\n                if(consonants.find(word[index - 1]) != -1 && consonants.find(word[index\
    \ + 1]) != -1)\n                {\n                    if(abs(index - word.length)\
    \ < min)\n                    {\n                        min = abs(index - word.length);\n\
    \                        result = v;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ay16g5h.d(28): Error: no property `find` for type `string`\\\
    n/tmp/tmp7ay16g5h.d(33): Error: no property `find` for type `string`\\n/tmp/tmp7ay16g5h.d(33):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp7ay16g5h.d(37): Error:\
    \ cannot implicitly convert expression `abs(cast(ulong)index - word.length)` of\
    \ type `ulong` to `int`\\n/tmp/tmp7ay16g5h.d(38): Error: cannot implicitly convert\
    \ expression `v` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ay16g5h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i..$];\n                \
    \    }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3thyeec2.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3thyeec2.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp3thyeec2.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp3thyeec2.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp3thyeec2.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp3thyeec2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = -1;\n    int distance = int.max;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i == word.length - 1)\n                return \"\";\n       \
    \     if (vowels.find(word[i + 1]) != -1)\n                continue;\n       \
    \     if (i == 0)\n                return \"\";\n            if (vowels.find(word[i\
    \ - 1]) != -1)\n                continue;\n            if (word.length - i < distance)\n\
    \            {\n                distance = word.length - i;\n                index\
    \ = i;\n            }\n        }\n    }\n    if (index != -1)\n        result\
    \ = word[index..$];\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjra3v_vd.d(25): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpjra3v_vd.d(27): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpjra3v_vd.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjra3v_vd.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpjra3v_vd.d(39): Error: cannot implicitly convert expression\
    \ `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpjra3v_vd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\
    \";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            int distance = word.length - i;\n           \
    \ if (closest_vowel_distance == -1 || distance < closest_vowel_distance)\n   \
    \         {\n                closest_vowel_distance = distance;\n            \
    \    closest_vowel_index = i;\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ != -1)\n    {\n        if (closest_vowel_index > 0 && closest_vowel_index <\
    \ word.length - 1)\n        {\n            string vowels = \"aeiouAEIOU\";\n \
    \           if (vowels.find(word[closest_vowel_index - 1]) == -1 && vowels.find(word[closest_vowel_index\
    \ + 1]) == -1)\n            {\n                closest_vowel = word[closest_vowel_index];\n\
    \            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxpuj1txm.d(27): Error: no property `find` for type `string`\\\
    n/tmp/tmpxpuj1txm.d(29): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpxpuj1txm.d(41): Error: variable\
    \ `vowels` is shadowing variable `tmpxpuj1txm.get_closest_vowel.vowels`\\n/tmp/tmpxpuj1txm.d(42):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpxpuj1txm.d(42): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpxpuj1txm.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)closest_vowel_index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpxpuj1txm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string res = \"\";\n    int min_dist\
    \ = word.length;\n    for (int i = 0; i < word.length; i++)\n    {\n        if\
    \ (vowels.find(word[i]) != -1)\n        {\n            int j = i;\n          \
    \  while (j < word.length && vowels.find(word[j]) != -1)\n                j++;\n\
    \            if (j < word.length)\n            {\n                int k = j;\n\
    \                while (k < word.length && vowels.find(word[k]) == -1)\n     \
    \               k++;\n                if (k < word.length)\n                {\n\
    \                    int dist = k - j;\n                    if (dist < min_dist)\n\
    \                    {\n                        min_dist = dist;\n           \
    \             res = word[i..i];\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1h1cw_pr.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp1h1cw_pr.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp1h1cw_pr.d(29): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp1h1cw_pr.d(34): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1h1cw_pr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphm86ncf3.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphm86ncf3.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmphm86ncf3.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphm86ncf3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe9fmger8.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe9fmger8.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpe9fmger8.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9fmger8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance = 0;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd4nf47_i.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpd4nf47_i.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpd4nf47_i.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd4nf47_i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj2f7ld3_.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpj2f7ld3_.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpj2f7ld3_.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpj2f7ld3_.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj2f7ld3_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    for (int i = word.length - 1; i\
    \ >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n    \
    \        if (i < min)\n            {\n                min = i;\n             \
    \   index = i;\n            }\n        }\n    }\n    if (index == 0)\n    {\n\
    \        return result;\n    }\n    else\n    {\n        return word[index..index];\n\
    \    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvncoyhns.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvncoyhns.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpvncoyhns.d(27):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvncoyhns.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\
    \";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance = 0;\n \
    \   int word_length = word.length;\n    int vowel_length = vowels.length;\n  \
    \  int word_index = word_length - 1;\n    int vowel_index = 0;\n    int vowel_distance\
    \ = 0;\n    bool found_vowel = false;\n    bool found_consonant = false;\n   \
    \ while (word_index >= 0)\n    {\n        if (found_vowel)\n        {\n      \
    \      if (isalpha(word[word_index]))\n            {\n                if (vowels.find(word[word_index])\
    \ == -1)\n                {\n                    break;\n                }\n \
    \           }\n        }\n        else\n        {\n            if (isalpha(word[word_index]))\n\
    \            {\n                if (vowels.find(word[word_index]) != -1)\n   \
    \             {\n                    found_vowel = true;\n                   \
    \ closest_vowel = word[word_index..word_index];\n                    closest_vowel_index\
    \ = word_index;\n                    closest_vowel_distance = word_length - word_index;\n\
    \                }\n            }\n        }\n        word_index--;\n    }\n \
    \   if (found_vowel)\n    {\n        vowel_index = 0;\n        while (vowel_index\
    \ < vowel_length)\n        {\n            vowel_distance = abs(word_index - vowels.find(vowels[vowel_index]));\n\
    \            if (vowel_distance < closest_vowel_distance)\n            {\n   \
    \             closest_vowel = vowels[vowel_index..vowel_index];\n            \
    \    closest_vowel_index = vowels.find(vowels[vowel_index]);\n               \
    \ closest_vowel_distance = vowel_distance;\n            }\n            vowel_index++;\n\
    \        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfto8rg6j.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfto8rg6j.d(26): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\n/tmp/tmpfto8rg6j.d(36):\
    \ Error: undefined identifier `isalpha`\\n/tmp/tmpfto8rg6j.d(38): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpfto8rg6j.d(46): Error: undefined identifier\
    \ `isalpha`\\n/tmp/tmpfto8rg6j.d(48): Error: no property `find` for type `string`\\\
    n/tmp/tmpfto8rg6j.d(64): Error: no property `find` for type `string`\\n/tmp/tmpfto8rg6j.d(68):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfto8rg6j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    enum vowel = \"aeiou\";\n    string result = \"\";\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowel.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjs_xw3k8.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjs_xw3k8.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpjs_xw3k8.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpjs_xw3k8.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjs_xw3k8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (min > abs(word.length - i))\n                    {\n                \
    \        min = abs(word.length - i);\n                        index = i;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    if\
    \ (index != 0)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp82k2l9ch.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp82k2l9ch.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp82k2l9ch.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp82k2l9ch.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmp82k2l9ch.d(35): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmp82k2l9ch.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp82k2l9ch.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n       \
    \ if (vowels.find(word[i]) != -1)\n        {\n            index = i;\n       \
    \     break;\n        }\n    }\n    if (index == -1)\n        return result;\n\
    \    if (index == word.length - 1)\n        return result;\n    if (vowels.find(word[index\
    \ + 1]) != -1)\n        return result;\n    return word[index..index];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4jo286nk.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp4jo286nk.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp4jo286nk.d(36): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4jo286nk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyjv5j77a.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyjv5j77a.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpyjv5j77a.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyjv5j77a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = 0;\n    int min_distance = word.length;\n    for (int i =\
    \ 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n \
    \       {\n            if (i == 0)\n            {\n                distance =\
    \ word.length;\n            }\n            else if (i == word.length - 1)\n  \
    \          {\n                distance = word.length;\n            }\n       \
    \     else\n            {\n                distance = word.length - i - 1;\n \
    \           }\n            if (distance < min_distance)\n            {\n     \
    \           min_distance = distance;\n                result = word[i];\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe_paqfxd.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe_paqfxd.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpe_paqfxd.d(31): Error: cannot implicitly convert\
    \ expression `word.length` of type `ulong` to `int`\\n/tmp/tmpe_paqfxd.d(35):\
    \ Error: cannot implicitly convert expression `word.length` of type `ulong` to\
    \ `int`\\n/tmp/tmpe_paqfxd.d(39): Error: cannot implicitly convert expression\
    \ `word.length - cast(ulong)i - 1LU` of type `ulong` to `int`\\n/tmp/tmpe_paqfxd.d(44):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_paqfxd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && vowels.find(word[i-1]) == -1 && i < word.length - 1 && vowels.find(word[i+1])\
    \ == -1)\n            {\n                if (min_distance > abs(i - word.length))\n\
    \                {\n                    min_distance = abs(i - word.length);\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppnv5y97e.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmppnv5y97e.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmppnv5y97e.d(28): Error: no property `find` for type\
    \ `string`\\n/tmp/tmppnv5y97e.d(28): Error: no property `find` for type `string`\\\
    n/tmp/tmppnv5y97e.d(32): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmppnv5y97e.d(33): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnv5y97e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min = int.max;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n    \
    \    if (vowels.find(word[i]) != -1)\n        {\n            int j = i;\n    \
    \        while (j >= 0 && vowels.find(word[j]) != -1)\n                j--;\n\
    \            if (j >= 0 && i - j < min)\n            {\n                min =\
    \ i - j;\n                result = word[i..$];\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjc8noqf0.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpjc8noqf0.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpjc8noqf0.d(29): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjc8noqf0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    enum vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = word.length;\n    foreach(i, char c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            if(i > 0 && i < word.length - 1)\n            {\n    \
    \            if(vowels.canFind(word[i - 1]) || vowels.canFind(word[i + 1]))\n\
    \                    continue;\n            }\n            if(abs(word.length\
    \ - i) < distance)\n            {\n                distance = abs(word.length\
    \ - i);\n                result = c.toString();\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptaouwizd.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptaouwizd.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmptaouwizd.d(30): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmptaouwizd.d(30): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmptaouwizd.d(35): Error: cannot implicitly convert expression\
    \ `abs(word.length - i)` of type `ulong` to `int`\\n/tmp/tmptaouwizd.d(36): Error:\
    \ no property `toString` for type `char`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptaouwizd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int min = int.max;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int index = word.length\
    \ - i - 1;\n            if(index > 0 && consonants.canFind(word[index - 1]) &&\
    \ consonants.canFind(word[index + 1]))\n            {\n                if(index\
    \ < min)\n                {\n                    min = index;\n              \
    \      result = c;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk5frld87.d(27): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpk5frld87.d(29): Error: cannot implicitly convert expression `word.length\
    \ - i - 1LU` of type `ulong` to `int`\\n/tmp/tmpk5frld87.d(30): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpk5frld87.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpk5frld87.d(35): Error: cannot implicitly convert\
    \ expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpk5frld87.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_fl5baq5.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_fl5baq5.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp_fl5baq5.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp_fl5baq5.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_fl5baq5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(vowel; word)\n    {\n        if(vowels.find(vowel)\
    \ != -1)\n        {\n            int distance = word.length - word.find(vowel);\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = vowel;\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr3g1v96b.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpr3g1v96b.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpr3g1v96b.d(28): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpr3g1v96b.d(32): Error: cannot implicitly convert expression\
    \ `vowel` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpr3g1v96b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    int distance = 0;\n    int index = 0;\n    int\
    \ word_length = word.length;\n    for (int i = 0; i < word_length; i++)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            if (i == 0 ||\
    \ i == word_length - 1)\n            {\n                continue;\n          \
    \  }\n            else\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            distance = abs(word_length - i - 1);\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        index = i;\n                    }\n   \
    \             }\n            }\n        }\n    }\n    if (index != 0)\n    {\n\
    \        result = word[index];\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_4l1v91v.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_4l1v91v.d(29): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp_4l1v91v.d(37): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp_4l1v91v.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmp_4l1v91v.d(51): Error: cannot implicitly convert expression `word[cast(ulong)index]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_4l1v91v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp04ycy3mn.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp04ycy3mn.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp04ycy3mn.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp04ycy3mn.d(32):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04ycy3mn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp40n9a4f1.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp40n9a4f1.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp40n9a4f1.d(29): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp40n9a4f1.d(33):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp40n9a4f1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (i < min_distance)\n                    {\n                        min_distance\
    \ = i;\n                        result = word[i..$];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9qfoh2c1.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9qfoh2c1.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9qfoh2c1.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp9qfoh2c1.d(30): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qfoh2c1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int distance = 0;\n    int min_distance = 0;\n\
    \    foreach(i, char c; word)\n    {\n        if(vowels.find(c) != -1)\n     \
    \   {\n            foreach(j, char d; word[i..$])\n            {\n           \
    \     if(consonants.find(d) != -1)\n                {\n                    distance\
    \ = j;\n                    break;\n                }\n            }\n       \
    \     if(distance != 0)\n            {\n                if(min_distance == 0)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n                else if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw9q7vecl.d(28): Error: no property `find` for type `string`\\\
    n/tmp/tmpw9q7vecl.d(32): Error: no property `find` for type `string`\\n/tmp/tmpw9q7vecl.d(34):\
    \ Error: cannot implicitly convert expression `j` of type `ulong` to `int`\\n/tmp/tmpw9q7vecl.d(43):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    n/tmp/tmpw9q7vecl.d(48): Error: cannot implicitly convert expression `c` of type\
    \ `char` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw9q7vecl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, char c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0v__1wf9.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0v__1wf9.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp0v__1wf9.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp0v__1wf9.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0v__1wf9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp97lfha7h.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp97lfha7h.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp97lfha7h.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp97lfha7h.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp97lfha7h.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(vowel; vowels)\n    {\n    \
    \    int vowel_pos = word.find(vowel);\n        if(vowel_pos != -1)\n        {\n\
    \            int distance = word.length - vowel_pos;\n            if(distance\
    \ > 1 && distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = vowel;\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptc9hses6.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptc9hses6.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmptc9hses6.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)vowel_pos` of type `ulong` to `int`\\n/tmp/tmptc9hses6.d(33):\
    \ Error: cannot implicitly convert expression `vowel` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptc9hses6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != string.npos)\n        {\n \
    \           if (i > 0 && i < word.length - 1)\n            {\n               \
    \ if (vowels.find(word[i - 1]) == string.npos && vowels.find(word[i + 1]) == string.npos)\n\
    \                {\n                    if (min_distance > abs(word.length - i))\n\
    \                    {\n                        min_distance = abs(word.length\
    \ - i);\n                        index = i;\n                    }\n         \
    \       }\n            }\n        }\n    }\n    if (index != 0)\n    {\n     \
    \   result = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyv7qsf2k.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyv7qsf2k.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpyv7qsf2k.d(27): Error: no property `npos` for type\
    \ `string`\\n/tmp/tmpyv7qsf2k.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpyv7qsf2k.d(31): Error: no property `npos` for type `string`\\n/tmp/tmpyv7qsf2k.d(31):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpyv7qsf2k.d(31): Error:\
    \ no property `npos` for type `string`\\n/tmp/tmpyv7qsf2k.d(35): Error: cannot\
    \ implicitly convert expression `abs(word.length - cast(ulong)i)` of type `ulong`\
    \ to `int`\\n/tmp/tmpyv7qsf2k.d(44): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyv7qsf2k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyssxszo8.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyssxszo8.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpyssxszo8.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpyssxszo8.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyssxszo8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int index = word.length\
    \ - 1;\n    while(index >= 0)\n    {\n        if(vowels.find(word[index]) != -1)\n\
    \        {\n            if(index == 0)\n                return \"\";\n       \
    \     if(vowels.find(word[index-1]) == -1)\n                return word[index..index];\n\
    \        }\n        index--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwx5q9c0r.d(22): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpwx5q9c0r.d(25): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpwx5q9c0r.d(29): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwx5q9c0r.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = word.length - 1; i >= 0;\
    \ i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps7zb4rp8.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmps7zb4rp8.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmps7zb4rp8.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmps7zb4rp8.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps7zb4rp8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1ecwhd9l.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp1ecwhd9l.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmp1ecwhd9l.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ecwhd9l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    int distance = 0;\n    int word_length = word.length;\n\
    \    for (int i = 0; i < word_length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i == 0)\n            {\n                distance\
    \ = word_length - 1;\n            }\n            else if (i == word_length - 1)\n\
    \            {\n                distance = word_length - 1;\n            }\n \
    \           else\n            {\n                distance = word_length - i -\
    \ 1;\n            }\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgaqp8x5p.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgaqp8x5p.d(28): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgaqp8x5p.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min > abs(word.length - i))\n                    {\n        \
    \                min = abs(word.length - i);\n                        index =\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    if (index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprx4taalm.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprx4taalm.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprx4taalm.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmprx4taalm.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmprx4taalm.d(35): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmprx4taalm.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprx4taalm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    int distance = 0;\n    int word_length = word.length;\n\
    \    int vowel_length = vowels.length;\n    int word_index = 0;\n    int vowel_index\
    \ = 0;\n    int vowel_pos = 0;\n    bool found_vowel = false;\n    bool found_consonant\
    \ = false;\n    foreach(char c; word)\n    {\n        if(found_vowel)\n      \
    \  {\n            if(vowels.find(c) == -1)\n            {\n                found_vowel\
    \ = false;\n                found_consonant = true;\n            }\n        }\n\
    \        else if(found_consonant)\n        {\n            if(vowels.find(c) !=\
    \ -1)\n            {\n                found_vowel = true;\n                found_consonant\
    \ = false;\n                distance = word_length - word_index;\n           \
    \     if(distance < min_distance)\n                {\n                    min_distance\
    \ = distance;\n                    result = c;\n                }\n          \
    \  }\n        }\n        else\n        {\n            if(vowels.find(c) != -1)\n\
    \            {\n                found_vowel = true;\n                vowel_pos\
    \ = word_index;\n            }\n        }\n        word_index++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuu051h4k.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpuu051h4k.d(26): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\n/tmp/tmpuu051h4k.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpuu051h4k.d(44): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpuu051h4k.d(52): Error: cannot\
    \ implicitly convert expression `c` of type `char` to `string`\\n/tmp/tmpuu051h4k.d(58):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpuu051h4k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min_distance > abs(i - word.length))\n                    {\n\
    \                        min_distance = abs(i - word.length);\n              \
    \          index = i;\n                    }\n                }\n            }\n\
    \        }\n    }\n    if (index != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkef3x59e.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkef3x59e.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkef3x59e.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpkef3x59e.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpkef3x59e.d(35): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpkef3x59e.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkef3x59e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min = word.length;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && vowels.find(word[i - 1]) == -1)\n            {\n   \
    \             index = i;\n                break;\n            }\n        }\n \
    \   }\n    if (index != 0)\n    {\n        for (int i = index; i < word.length;\
    \ i++)\n        {\n            if (vowels.find(word[i]) == -1)\n            {\n\
    \                if (i - index < min)\n                {\n                   \
    \ min = i - index;\n                    result = word[index];\n              \
    \  }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpca6eyodb.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpca6eyodb.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpca6eyodb.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpca6eyodb.d(29): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpca6eyodb.d(40): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpca6eyodb.d(45): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpca6eyodb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int d = word.length - i;\n            if(d < distance)\n\
    \            {\n                distance = d;\n                result = c;\n \
    \           }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpti_npnqi.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpti_npnqi.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpti_npnqi.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpti_npnqi.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpti_npnqi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7rs511ig.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp7rs511ig.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp7rs511ig.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7rs511ig.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min = int.max;\n   \
    \ for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            for (int j = i; j >= 0; j--)\n            {\n\
    \                if (consonants.find(word[j]) != -1)\n                {\n    \
    \                index = j;\n                    break;\n                }\n \
    \           }\n            if (i - index < min)\n            {\n             \
    \   min = i - index;\n                result = word[i .. i];\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpytlahvka.d(26): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpytlahvka.d(28): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpytlahvka.d(32): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytlahvka.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwcwyqko_.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwcwyqko_.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwcwyqko_.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpwcwyqko_.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpwcwyqko_.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpwcwyqko_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ != word.length - 1 && vowels.find(word[i + 1]) == -1)\n            {\n     \
    \           int distance = word.length - i - 1;\n                if (distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i..$];\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpca96ld6k.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpca96ld6k.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpca96ld6k.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpca96ld6k.d(28): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpca96ld6k.d(30): Error: cannot\
    \ implicitly convert expression `word.length - cast(ulong)i - 1LU` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpca96ld6k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i - 1;\n            if(distance < min_distance)\n            {\n         \
    \       min_distance = distance;\n                index = i;\n            }\n\
    \        }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n     \
    \   if(!vowels.canFind(word[index - 1]) && !vowels.canFind(word[index + 1]))\n\
    \        {\n            result = word[index..$];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph1qywxmi.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmph1qywxmi.d(27): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmph1qywxmi.d(29): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmph1qywxmi.d(33):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmph1qywxmi.d(39):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmph1qywxmi.d(39): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmph1qywxmi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0xuwqdl5.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0xuwqdl5.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp0xuwqdl5.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp0xuwqdl5.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0xuwqdl5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int closest = 0;\n    int distance = 0;\n    int index = 0;\n    int i =\
    \ 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int\
    \ n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n   \
    \ int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n\
    \    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n\
    \    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n\
    \    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n\
    \    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n\
    \    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n \
    \   int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt\
    \ = 0;\n    int uu = 0;\n    int vv\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ylsrwst.d(92): Error: semicolon expected, not `unittest`\\n/tmp/tmp8ylsrwst.d(92):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8ylsrwst.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmz1w6q5e.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpmz1w6q5e.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpmz1w6q5e.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmz1w6q5e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                result\
    \ = c;\n                min_distance = distance;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphatk40uv.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphatk40uv.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmphatk40uv.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmphatk40uv.d(31):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphatk40uv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c.to!string;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_4m5vc51.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp_4m5vc51.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmp_4m5vc51.d(32): Error: no property `to`\
    \ for type `immutable(char)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_4m5vc51.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c.to!string;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbr80njdd.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpbr80njdd.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpbr80njdd.d(32): Error: no property `to`\
    \ for type `immutable(char)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpbr80njdd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp76j34oo_.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp76j34oo_.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp76j34oo_.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp76j34oo_.d(32):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76j34oo_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ minDistance = word.length;\n    for (int i = 0; i < word.length; i++)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < minDistance)\n            {\n\
    \                minDistance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ep92o5p.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp8ep92o5p.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp8ep92o5p.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ep92o5p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.find(c) != -1)\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvmpk2qr.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqvmpk2qr.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpqvmpk2qr.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpqvmpk2qr.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqvmpk2qr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string closestVowel = \"\";\n\
    \    int closestVowelIndex = 0;\n    int closestVowelDistance = 0;\n    int wordLength\
    \ = word.length;\n    for (int i = wordLength - 1; i >= 0; i--)\n    {\n     \
    \   if (vowels.find(word[i]) != -1)\n        {\n            if (i == wordLength\
    \ - 1)\n            {\n                continue;\n            }\n            if\
    \ (vowels.find(word[i + 1]) != -1)\n            {\n                continue;\n\
    \            }\n            if (closestVowelDistance == 0)\n            {\n  \
    \              closestVowel = word[i];\n                closestVowelIndex = i;\n\
    \                closestVowelDistance = wordLength - i;\n            }\n     \
    \       else\n            {\n                if (wordLength - i < closestVowelDistance)\n\
    \                {\n                    closestVowel = word[i];\n            \
    \        closestVowelIndex = i;\n                    closestVowelDistance = wordLength\
    \ - i;\n                }\n            }\n        }\n    }\n    return closestVowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplnem6qtk.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplnem6qtk.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmplnem6qtk.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmplnem6qtk.d(40): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\n/tmp/tmplnem6qtk.d(48):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplnem6qtk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length;\n    int distance = word.length;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (index - i < distance)\n            {\n     \
    \           distance = index - i;\n                result = word[i..$];\n    \
    \        }\n            index = i;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjjppz_yq.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjjppz_yq.d(24): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmpjjppz_yq.d(25):\
    \ Error: cannot implicitly convert expression `word.length - 1LU` of type `ulong`\
    \ to `int`\\n/tmp/tmpjjppz_yq.d(27): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjjppz_yq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg41bqzcu.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpg41bqzcu.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg41bqzcu.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg41bqzcu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                result = word[index];\n                break;\n \
    \           }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7k7rvmzd.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp7k7rvmzd.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp7k7rvmzd.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp7k7rvmzd.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7k7rvmzd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                result = word[index];\n                break;\n \
    \           }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp40z55_5.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpp40z55_5.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpp40z55_5.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpp40z55_5.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp40z55_5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = word.length - 1; i >= 0;\
    \ i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiazz4pk9.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpiazz4pk9.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpiazz4pk9.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpiazz4pk9.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiazz4pk9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    for (int i = word.length - 1; i >= 0; i--)\n  \
    \  {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp108jvrem.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp108jvrem.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp108jvrem.d(28): Error: cannot implicitly\
    \ convert expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp108jvrem.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkri770_8.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkri770_8.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkri770_8.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpkri770_8.d(32):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkri770_8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuyp2bhoq.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpuyp2bhoq.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpuyp2bhoq.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuyp2bhoq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int left\
    \ = i - 1;\n            int right = i + 1;\n            while (left >= 0 && vowels.find(word[left])\
    \ != -1)\n                left--;\n            while (right < word.length && vowels.find(word[right])\
    \ != -1)\n                right++;\n            if (left >= 0 && right < word.length)\n\
    \            {\n                int distance = right - left - 1;\n           \
    \     if (distance < min_distance)\n                {\n                    min_distance\
    \ = distance;\n                    result = word[i..i];\n                }\n \
    \           }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5oj5rfi7.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5oj5rfi7.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5oj5rfi7.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp5oj5rfi7.d(32): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5oj5rfi7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int index = word.rfind(c);\n            if(index != -1)\n\
    \            {\n                if(index < min)\n                {\n         \
    \           min = index;\n                    result = c;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppkw1jk8r.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmppkw1jk8r.d(28): Error: no property `rfind` for type `string`\\n/tmp/tmppkw1jk8r.d(34):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppkw1jk8r.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    foreach(i, c; word)\n    {\n   \
    \     if(vowels.find(c) != -1)\n        {\n            if(i > 0 && vowels.find(word[i\
    \ - 1]) == -1 && i < word.length - 1 && vowels.find(word[i + 1]) == -1)\n    \
    \        {\n                if(abs(i - word.length) < min)\n                {\n\
    \                    min = abs(i - word.length);\n                    index =\
    \ i;\n                }\n            }\n        }\n    }\n    if(index != 0)\n\
    \    {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgehjbopv.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgehjbopv.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpgehjbopv.d(29): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpgehjbopv.d(29): Error: no property `find` for type `string`\\\
    n/tmp/tmpgehjbopv.d(33): Error: cannot implicitly convert expression `abs(i -\
    \ word.length)` of type `ulong` to `int`\\n/tmp/tmpgehjbopv.d(34): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpgehjbopv.d(41):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpgehjbopv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnzh1_ya.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjnzh1_ya.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjnzh1_ya.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnzh1_ya.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = word.length - 1; i >= 0;\
    \ i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && vowels.find(word[i - 1]) == -1)\n            {\n             \
    \   if (i < min_distance)\n                {\n                    min_distance\
    \ = i;\n                    result = word[i];\n                }\n           \
    \ }\n            else if (i < word.length - 1 && vowels.find(word[i + 1]) == -1)\n\
    \            {\n                if (word.length - i - 1 < min_distance)\n    \
    \            {\n                    min_distance = word.length - i - 1;\n    \
    \                result = word[i];\n                }\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnfaxaj_z.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpnfaxaj_z.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpnfaxaj_z.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpnfaxaj_z.d(28): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpnfaxaj_z.d(33): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\n/tmp/tmpnfaxaj_z.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmpnfaxaj_z.d(40): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i - 1LU` of type `ulong` to `int`\\n/tmp/tmpnfaxaj_z.d(41): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnfaxaj_z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int minDistance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            index\
    \ = word.length - i - 1;\n            distance = index - word.rfind(\"[^aeiou]\"\
    , index);\n            if(distance > 1 && distance < minDistance)\n          \
    \  {\n                minDistance = distance;\n                result = c;\n \
    \           }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpys_p6ixu.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpys_p6ixu.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpys_p6ixu.d(30): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmpys_p6ixu.d(31):\
    \ Error: no property `rfind` for type `string`\\n/tmp/tmpys_p6ixu.d(35): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpys_p6ixu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6xlvkk6c.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6xlvkk6c.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp6xlvkk6c.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xlvkk6c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1y3qi573.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp1y3qi573.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp1y3qi573.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp1y3qi573.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp1y3qi573.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1y3qi573.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwkchd2br.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwkchd2br.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwkchd2br.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpwkchd2br.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpwkchd2br.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpwkchd2br.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (i < min_distance)\n                    {\n                        min_distance\
    \ = i;\n                        result = word[i];\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsof7da1j.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpsof7da1j.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpsof7da1j.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpsof7da1j.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpsof7da1j.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpsof7da1j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(min_distance\
    \ == 0 || distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw69o_526.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpw69o_526.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpw69o_526.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw69o_526.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3xkfifwa.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3xkfifwa.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp3xkfifwa.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp3xkfifwa.d(32):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3xkfifwa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = 0;\n            for (int j = i; j\
    \ < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    distance++;\n               \
    \ }\n                else if (vowels.find(word[j]) != -1)\n                {\n\
    \                    break;\n                }\n            }\n            if\
    \ (distance < minDistance)\n            {\n                minDistance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp7zkfa7b.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpp7zkfa7b.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpp7zkfa7b.d(33): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpp7zkfa7b.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmpp7zkfa7b.d(45): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpp7zkfa7b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj0ifpkpa.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpj0ifpkpa.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpj0ifpkpa.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj0ifpkpa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n         \
    \   foreach(j, v; vowels)\n            {\n                if(word.find(v, i) !=\
    \ -1)\n                {\n                    int distance = word.find(v, i) -\
    \ i;\n                    if(distance < min_distance)\n                    {\n\
    \                        min_distance = distance;\n                        result\
    \ = v;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkqog56sb.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkqog56sb.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkqog56sb.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpkqog56sb.d(33): Error: no property `find` for type `string`\\\
    n/tmp/tmpkqog56sb.d(37): Error: cannot implicitly convert expression `v` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpkqog56sb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4exi5178.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4exi5178.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp4exi5178.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp4exi5178.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4exi5178.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(v; vowels)\n    {\n        int pos\
    \ = word.rfind(v);\n        if(pos != -1)\n        {\n            int distance\
    \ = word.length - pos;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = v;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppeey3shu.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmppeey3shu.d(26): Error: no property `rfind`\
    \ for type `string`\\n/tmp/tmppeey3shu.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)pos` of type `ulong` to `int`\\n/tmp/tmppeey3shu.d(33):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppeey3shu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string closest_vowel = \"\";\n\
    \    int closest_vowel_index = 0;\n    int closest_vowel_distance = 0;\n    int\
    \ word_length = word.length;\n    int vowel_index = 0;\n    int vowel_distance\
    \ = 0;\n    for (int i = word_length - 1; i >= 0; i--)\n    {\n        vowel_index\
    \ = vowels.find(word[i]);\n        if (vowel_index != -1)\n        {\n       \
    \     vowel_distance = word_length - i;\n            if (vowel_distance > closest_vowel_distance)\n\
    \            {\n                closest_vowel_distance = vowel_distance;\n   \
    \             closest_vowel_index = vowel_index;\n            }\n        }\n \
    \   }\n    if (closest_vowel_distance > 0)\n    {\n        closest_vowel = vowels[closest_vowel_index..closest_vowel_index];\n\
    \    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdropmwdm.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdropmwdm.d(30): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdropmwdm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        index = i;\n               \
    \     }\n                }\n            }\n        }\n    }\n    if (index !=\
    \ 0)\n    {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpihfplved.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpihfplved.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpihfplved.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpihfplved.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpihfplved.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpihfplved.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = 0;\n    int min_distance = word.length;\n    for (int i =\
    \ word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            distance = word.length - i;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[i..$];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeyk2536s.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpeyk2536s.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpeyk2536s.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpeyk2536s.d(29): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeyk2536s.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpumyffj4f.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpumyffj4f.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpumyffj4f.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpumyffj4f.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpumyffj4f.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpumyffj4f.d(36): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpumyffj4f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_dist = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int dist\
    \ = word.length - i;\n            if (dist < min_dist)\n            {\n      \
    \          min_dist = dist;\n                result = word[i..$];\n          \
    \  }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp68fb9mek.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp68fb9mek.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp68fb9mek.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp68fb9mek.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp68fb9mek.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int temp = 0;\n    for (int i = word.length - 1; i > 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i\
    \ - 1]) == -1)\n            {\n                temp = i;\n                break;\n\
    \            }\n        }\n    }\n    for (int i = temp; i > 0; i--)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i\
    \ - 1]) == -1)\n            {\n                distance = temp - i;\n        \
    \        if (distance < temp)\n                {\n                    result =\
    \ word[i];\n                    temp = distance;\n                }\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzorkvvhp.d(25): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpzorkvvhp.d(27): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpzorkvvhp.d(29): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpzorkvvhp.d(38): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpzorkvvhp.d(40): Error: no property `find` for type `string`\\\
    n/tmp/tmpzorkvvhp.d(45): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpzorkvvhp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps6g82sb4.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmps6g82sb4.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmps6g82sb4.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmps6g82sb4.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6g82sb4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pasq8no.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp6pasq8no.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp6pasq8no.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp6pasq8no.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pasq8no.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = -1;\n    int min_distance = int.max;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n        if(!vowels.canFind(word[index\
    \ - 1]) && !vowels.canFind(word[index + 1]))\n        {\n            result =\
    \ word[index..index];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplxkp0vpt.d(27): Error: no property `canFind` for type `string`\\\
    n/tmp/tmplxkp0vpt.d(29): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmplxkp0vpt.d(33): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmplxkp0vpt.d(39): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmplxkp0vpt.d(39): Error: no\
    \ property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplxkp0vpt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min = word.length;\n    while(index--)\n    {\n\
    \        if(vowels.find(word[index]) != -1)\n        {\n            if(index <\
    \ min)\n            {\n                min = index;\n                result =\
    \ word[index..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3epre7qf.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3epre7qf.d(24): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmp3epre7qf.d(27):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3epre7qf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    int distance = 0;\n    int vowel_index =\
    \ 0;\n    int consonant_index = 0;\n    int word_length = word.length;\n    for\
    \ (int i = 0; i < word_length; i++)\n    {\n        if (vowels.indexOf(word[i])\
    \ != -1)\n        {\n            vowel_index = i;\n            for (int j = i\
    \ + 1; j < word_length; j++)\n            {\n                if (vowels.indexOf(word[j])\
    \ == -1)\n                {\n                    consonant_index = j;\n      \
    \              distance = consonant_index - vowel_index;\n                   \
    \ if (distance < min_distance)\n                    {\n                      \
    \  min_distance = distance;\n                        result = word[i];\n     \
    \               }\n                    break;\n                }\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnn916pm.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjnn916pm.d(30): Error: no property `indexOf`\
    \ for type `string`\\n/tmp/tmpjnn916pm.d(35): Error: no property `indexOf` for\
    \ type `string`\\n/tmp/tmpjnn916pm.d(42): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnn916pm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto result = \"\";\n    auto word_len\
    \ = word.length;\n    auto word_rev = word.dup.reverse;\n    auto word_rev_len\
    \ = word_rev.length;\n    auto vowel_len = vowels.length;\n    auto vowel_idx\
    \ = 0;\n    auto word_idx = 0;\n    auto word_rev_idx = 0;\n    auto vowel_found\
    \ = false;\n    auto vowel_found_idx = 0;\n    auto vowel_found_idx_rev = 0;\n\
    \    auto vowel_found_idx_rev_len = 0;\n    auto vowel_found_idx_rev_len_min =\
    \ 0;\n    auto vowel_found_idx_rev_len_min_idx = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev\
    \ = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min\
    \ = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx = 0;\n    auto\
    \ vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len\
    \ = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len_min =\
    \ 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len_min_idx\
    \ = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len_min_idx_rev\
    \ = 0;\n    auto vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0o2rf9v9.d(46): Error: no identifier for declarator `vowel_found_idx_rev_len_min_idx_rev_len_min_idx_rev_len`\\\
    n/tmp/tmp0o2rf9v9.d(46): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0o2rf9v9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    int distance = 0;\n    int word_len = word.length;\n\
    \    int vowel_len = vowels.length;\n    foreach(i, vowel; vowels)\n    {\n  \
    \      int index = word.find(vowel);\n        if(index != -1)\n        {\n   \
    \         if(index == 0 || index == word_len - 1)\n                continue;\n\
    \            if(index > 0 && index < word_len - 1)\n            {\n          \
    \      if(vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) ==\
    \ -1)\n                {\n                    distance = abs(word_len - index\
    \ - 1);\n                    if(distance < min_distance)\n                   \
    \ {\n                        min_distance = distance;\n                      \
    \  result = vowel;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphnmvhcl4.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphnmvhcl4.d(26): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\n/tmp/tmphnmvhcl4.d(29):\
    \ Error: no property `find` for type `string`\\n/tmp/tmphnmvhcl4.d(36): Error:\
    \ no property `find` for type `string`\\n/tmp/tmphnmvhcl4.d(36): Error: no property\
    \ `find` for type `string`\\n/tmp/tmphnmvhcl4.d(42): Error: cannot implicitly\
    \ convert expression `vowel` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphnmvhcl4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (word.length - i < min)\n            {\n                min = word.length\
    \ - i;\n                index = i;\n            }\n        }\n    }\n    if (index\
    \ != 0)\n    {\n        result = word[index];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfn_aqgty.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfn_aqgty.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpfn_aqgty.d(31): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpfn_aqgty.d(38):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfn_aqgty.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min_distance > i)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp553hk2a4.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp553hk2a4.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp553hk2a4.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp553hk2a4.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp553hk2a4.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp553hk2a4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int j = i;\n            while(j > 0 && !vowels.canFind(word[j\
    \ - 1]))\n                j--;\n            if(j > 0 && word[j - 1] != c)\n  \
    \          {\n                int k = i;\n                while(k < word.length\
    \ - 1 && !vowels.canFind(word[k + 1]))\n                    k++;\n           \
    \     if(k < word.length - 1 && word[k + 1] != c)\n                {\n       \
    \             if(distance > k - j)\n                    {\n                  \
    \      distance = k - j;\n                        result = c;\n              \
    \      }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaw_fr47a.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpaw_fr47a.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpaw_fr47a.d(28): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpaw_fr47a.d(29): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpaw_fr47a.d(33): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpaw_fr47a.d(34):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpaw_fr47a.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaw_fr47a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int vowel_index = -1;\n    int consonant_index\
    \ = -1;\n    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            vowel_index = i;\n    \
    \        if(consonant_index != -1)\n            {\n                int distance\
    \ = vowel_index - consonant_index;\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n        else\
    \ if(consonants.canFind(c))\n        {\n            consonant_index = i;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpabt1ktya.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpabt1ktya.d(29): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpabt1ktya.d(31): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpabt1ktya.d(38): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\n/tmp/tmpabt1ktya.d(42):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpabt1ktya.d(44): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpabt1ktya.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = 0;\n            for (int j = i; j\
    \ < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    distance++;\n               \
    \ }\n                else\n                {\n                    break;\n   \
    \             }\n            }\n            if (distance < minDistance)\n    \
    \        {\n                minDistance = distance;\n                result =\
    \ word[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcgc21kws.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpcgc21kws.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpcgc21kws.d(33): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpcgc21kws.d(45): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgc21kws.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                result\
    \ = c;\n                min_distance = distance;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfkjoyvc.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptfkjoyvc.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmptfkjoyvc.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmptfkjoyvc.d(31):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptfkjoyvc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_ghj_ol.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpp_ghj_ol.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpp_ghj_ol.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpp_ghj_ol.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_ghj_ol.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int pos = word.length;\n    int min_dist = word.length;\n    for (int i =\
    \ word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            int dist = pos - i;\n            if (dist < min_dist)\n\
    \            {\n                min_dist = dist;\n                result = word[i..$];\n\
    \            }\n        }\n        else\n        {\n            pos = i;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp74yt0iqw.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp74yt0iqw.d(24): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmp74yt0iqw.d(25):\
    \ Error: cannot implicitly convert expression `word.length - 1LU` of type `ulong`\
    \ to `int`\\n/tmp/tmp74yt0iqw.d(27): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp74yt0iqw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min)\n                    {\n                        min\
    \ = i;\n                        index = i;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    if (index != 0)\n    {\n      \
    \  result = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqy3yojgs.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqy3yojgs.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpqy3yojgs.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpqy3yojgs.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpqy3yojgs.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpqy3yojgs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int minDistance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            distance = word.length - i;\n                    if (distance < minDistance)\n\
    \                    {\n                        minDistance = distance;\n    \
    \                    result = word[i];\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpns2b6cex.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpns2b6cex.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpns2b6cex.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpns2b6cex.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpns2b6cex.d(33): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpns2b6cex.d(37): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns2b6cex.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4u1m52k6.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4u1m52k6.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp4u1m52k6.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp4u1m52k6.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u1m52k6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min = 100;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n \
    \       if (vowels.find(word[i]) != -1)\n        {\n            for (int j = i\
    \ - 1; j >= 0; j--)\n            {\n                if (vowels.find(word[j]) ==\
    \ -1)\n                {\n                    if (i - j < min)\n             \
    \       {\n                        min = i - j;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2cg_5k39.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp2cg_5k39.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp2cg_5k39.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp2cg_5k39.d(35): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2cg_5k39.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                result\
    \ = c;\n                min_distance = distance;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp36egt9sp.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp36egt9sp.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp36egt9sp.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp36egt9sp.d(31):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp36egt9sp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = index - i;\n            if(distance > 1 && distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n        index--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpesni_ud0.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpesni_ud0.d(25): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmpesni_ud0.d(28):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpesni_ud0.d(30): Error:\
    \ cannot implicitly convert expression `cast(ulong)index - i` of type `ulong`\
    \ to `int`\\n/tmp/tmpesni_ud0.d(34): Error: cannot implicitly convert expression\
    \ `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpesni_ud0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpig98tmxc.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpig98tmxc.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpig98tmxc.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpig98tmxc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i..$];\n                \
    \    }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ursli0h.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5ursli0h.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5ursli0h.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp5ursli0h.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp5ursli0h.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp5ursli0h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5m3emyuj.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5m3emyuj.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5m3emyuj.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp5m3emyuj.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp5m3emyuj.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp5m3emyuj.d(36): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5m3emyuj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkdh9k2z.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplkdh9k2z.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmplkdh9k2z.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmplkdh9k2z.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkdh9k2z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min > abs(word.length - i))\n                    {\n        \
    \                min = abs(word.length - i);\n                        index =\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    if (index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptmqhsk7v.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptmqhsk7v.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmptmqhsk7v.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmptmqhsk7v.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmptmqhsk7v.d(35): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmptmqhsk7v.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmqhsk7v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != string.npos)\n        {\n        \
    \    if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == string.npos && vowels.find(word[i+1]) == string.npos)\n                {\n\
    \                    if (min_distance > abs(word.length - i - 1))\n          \
    \          {\n                        min_distance = abs(word.length - i - 1);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_4wo3u7x.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_4wo3u7x.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp_4wo3u7x.d(26): Error: no property `npos` for type\
    \ `string`\\n/tmp/tmp_4wo3u7x.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp_4wo3u7x.d(30): Error: no property `npos` for type `string`\\n/tmp/tmp_4wo3u7x.d(30):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp_4wo3u7x.d(30): Error:\
    \ no property `npos` for type `string`\\n/tmp/tmp_4wo3u7x.d(34): Error: cannot\
    \ implicitly convert expression `abs(word.length - cast(ulong)i - 1LU)` of type\
    \ `ulong` to `int`\\n/tmp/tmp_4wo3u7x.d(35): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_4wo3u7x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int left_distance = 0;\n            int right_distance\
    \ = 0;\n            for(int j = i - 1; j >= 0; j--)\n            {\n         \
    \       if(vowels.canFind(word[j]))\n                    break;\n            \
    \    left_distance++;\n            }\n            for(int j = i + 1; j < word.length;\
    \ j++)\n            {\n                if(vowels.canFind(word[j]))\n         \
    \           break;\n                right_distance++;\n            }\n       \
    \     if(left_distance > 0 && right_distance > 0 && left_distance + right_distance\
    \ < min_distance)\n            {\n                min_distance = left_distance\
    \ + right_distance;\n                result = c;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqgpjs6mi.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqgpjs6mi.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpqgpjs6mi.d(30): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmpqgpjs6mi.d(32): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpqgpjs6mi.d(36): Error: cannot\
    \ implicitly convert expression `i + 1LU` of type `ulong` to `int`\\n/tmp/tmpqgpjs6mi.d(38):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpqgpjs6mi.d(45): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgpjs6mi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpby2sxfo4.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpby2sxfo4.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpby2sxfo4.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpby2sxfo4.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpby2sxfo4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    int distance = 0;\n    for (int i = 0; i\
    \ < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n      \
    \  {\n            if (i == 0 || i == word.length - 1)\n                continue;\n\
    \            if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1]) == -1)\n\
    \            {\n                distance = i;\n                if (distance <\
    \ min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgr7qsof3.d(27): Error: no property `find` for type `string`\\\
    n/tmp/tmpgr7qsof3.d(31): Error: no property `find` for type `string`\\n/tmp/tmpgr7qsof3.d(31):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpgr7qsof3.d(37): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgr7qsof3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = 0;\n    int temp = 0;\n    int index = 0;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            for (int j = i - 1; j >= 0; j--)\n            {\n\
    \                if (vowels.find(word[j]) == -1)\n                {\n        \
    \            temp = i - j;\n                    if (distance == 0)\n         \
    \           {\n                        distance = temp;\n                    \
    \    index = i;\n                    }\n                    else if (temp < distance)\n\
    \                    {\n                        distance = temp;\n           \
    \             index = i;\n                    }\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if (index != 0)\n   \
    \ {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsrerodf8.d(26): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpsrerodf8.d(28): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpsrerodf8.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpsrerodf8.d(52): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsrerodf8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = 0;\n    int distance = 0;\n    int index = 0;\n    int\
    \ vowel_index = 0;\n    int vowel_count = 0;\n    int word_length = word.length;\n\
    \    int vowel_length = vowels.length;\n    int[] vowel_indexes = new int[vowel_length];\n\
    \    int[] vowel_distances = new int[vowel_length];\n    foreach(c; word)\n  \
    \  {\n        if(vowels.find(c) != -1)\n        {\n            vowel_indexes[vowel_count]\
    \ = index;\n            vowel_count++;\n        }\n        index++;\n    }\n \
    \   if(vowel_count == 0)\n    {\n        return result;\n    }\n    else if(vowel_count\
    \ == 1)\n    {\n        return word[vowel_indexes[0]..vowel_indexes[0]];\n   \
    \ }\n    else\n    {\n        for(int i = 0; i < vowel_count; i++)\n        {\n\
    \            vowel_distances[i] = word_length - vowel_indexes[i];\n        }\n\
    \        min_distance = min(vowel_distances);\n        for(int i = 0; i < vowel_count;\
    \ i++)\n        {\n            if(vowel_distances[i] == min_distance)\n      \
    \      {\n                vowel_index = vowel_indexes[i];\n                break;\n\
    \            }\n        }\n        return word[vowel_index..vowel_index];\n  \
    \  }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsf8zl5xi.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpsf8zl5xi.d(29): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\n/tmp/tmpsf8zl5xi.d(34):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpsf8zl5xi.d(55): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsf8zl5xi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int min = int.max;\n    for (int i = word.length - 1; i >=\
    \ 0; i--)\n    {\n        if (vowels.indexOf(word[i]) != -1)\n        {\n    \
    \        if (i < min)\n            {\n                min = i;\n             \
    \   index = i;\n            }\n        }\n    }\n    if (index != -1)\n    {\n\
    \        result = word[index..index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgsmh868w.d(25): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpgsmh868w.d(27): Error: no property\
    \ `indexOf` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpgsmh868w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int j = i;\n            while(j >= 0 && consonants.canFind(word[j]))\n\
    \            {\n                j--;\n            }\n            if(j < 0)\n \
    \           {\n                j = 0;\n            }\n            distance = i\
    \ - j;\n            if(distance < minDistance)\n            {\n              \
    \  minDistance = distance;\n                result = c;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpif068rht.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpif068rht.d(28): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpif068rht.d(30): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpif068rht.d(31): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpif068rht.d(39): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmpif068rht.d(43): Error: cannot implicitly convert expression `c` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpif068rht.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && i < word.length - 1)\n            {\n              \
    \  if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n   \
    \             {\n                    distance = word.length - i;\n           \
    \         if (distance < min_distance)\n                    {\n              \
    \          min_distance = distance;\n                        result = word[i];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvui001kn.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvui001kn.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpvui001kn.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpvui001kn.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpvui001kn.d(33): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpvui001kn.d(37): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvui001kn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string closest_vowel = \"\";\n\
    \    int closest_vowel_index = 0;\n    int closest_vowel_distance = 0;\n    int\
    \ word_length = word.length;\n    int vowel_length = vowels.length;\n    int vowel_index\
    \ = 0;\n    int vowel_distance = 0;\n    for (int i = 0; i < word_length; i++)\n\
    \    {\n        for (int j = 0; j < vowel_length; j++)\n        {\n          \
    \  if (word[i] == vowels[j])\n            {\n                vowel_index = i;\n\
    \                vowel_distance = word_length - vowel_index;\n               \
    \ if (vowel_distance > closest_vowel_distance)\n                {\n          \
    \          closest_vowel_distance = vowel_distance;\n                    closest_vowel_index\
    \ = vowel_index;\n                    closest_vowel = word[closest_vowel_index..closest_vowel_index];\n\
    \                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvkwaek3d.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvkwaek3d.d(26): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvkwaek3d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int j = i\
    \ - 1;\n            while (j >= 0 && vowels.find(word[j]) != -1)\n           \
    \     j--;\n            if (j >= 0)\n            {\n                int k = i\
    \ + 1;\n                while (k < word.length && vowels.find(word[k]) != -1)\n\
    \                    k++;\n                if (k < word.length)\n            \
    \    {\n                    int distance = k - j - 1;\n                    if\
    \ (distance < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpynyr5nm0.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpynyr5nm0.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpynyr5nm0.d(29): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpynyr5nm0.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpynyr5nm0.d(42): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpynyr5nm0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\
    \";\n    int closest_distance = word.length;\n    int distance = 0;\n    for (int\
    \ i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            distance = word.length - i;\n            if (distance\
    \ < closest_distance)\n            {\n                closest_distance = distance;\n\
    \                closest_vowel = word[i..$];\n            }\n        }\n    }\n\
    \    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp004tc6uo.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp004tc6uo.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp004tc6uo.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp004tc6uo.d(29): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp004tc6uo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\
    \";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance = 0;\n \
    \   int word_length = word.length;\n    int vowel_index = 0;\n    int vowel_distance\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    for (i = word_length - 1; i > 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            vowel_index\
    \ = i;\n            vowel_distance = word_length - i;\n            for (j = i\
    \ - 1; j > 0; j--)\n            {\n                if (vowels.find(word[j]) ==\
    \ -1)\n                {\n                    if (closest_vowel_distance == 0\
    \ || \n                        vowel_distance < closest_vowel_distance)\n    \
    \                {\n                        closest_vowel_distance = vowel_distance;\n\
    \                        closest_vowel_index = vowel_index;\n                \
    \    }\n                    break;\n                }\n            }\n       \
    \ }\n    }\n    if (closest_vowel_index != 0)\n    {\n        closest_vowel =\
    \ word[closest_vowel_index..closest_vowel_index];\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwaw1cy7i.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwaw1cy7i.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwaw1cy7i.d(38): Error: no property `find` for type\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwaw1cy7i.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz2xetrob.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpz2xetrob.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpz2xetrob.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpz2xetrob.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz2xetrob.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min = word.length;\n    foreach(i, c; word)\n   \
    \ {\n        if(vowels.canFind(c))\n        {\n            int j = i;\n      \
    \      while(j > 0 && vowels.canFind(word[j]))\n                j--;\n       \
    \     if(!vowels.canFind(word[j]))\n            {\n                j = i;\n  \
    \              while(j < word.length && vowels.canFind(word[j]))\n           \
    \         j++;\n                if(!vowels.canFind(word[j]))\n               \
    \ {\n                    if(abs(i - j) < min)\n                    {\n       \
    \                 min = abs(i - j);\n                        index = i;\n    \
    \                }\n                }\n            }\n        }\n    }\n    if(index\
    \ != 0)\n        result = word[index..$];\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk9_17az2.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpk9_17az2.d(27): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpk9_17az2.d(29): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpk9_17az2.d(30): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpk9_17az2.d(32): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpk9_17az2.d(34): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmpk9_17az2.d(35): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpk9_17az2.d(37): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpk9_17az2.d(41): Error: cannot\
    \ implicitly convert expression `abs(i - cast(ulong)j)` of type `ulong` to `int`\\\
    n/tmp/tmpk9_17az2.d(42): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk9_17az2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgff5qior.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgff5qior.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpgff5qior.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgff5qior.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqgxf5che.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqgxf5che.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpqgxf5che.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgxf5che.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if\
    \ (vowels.find(word[i]) != -1)\n        {\n            index = i;\n          \
    \  break;\n        }\n    }\n    for (int i = index - 1; i >= 0; i--)\n    {\n\
    \        if (vowels.find(word[i]) == -1)\n        {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp__6qntzv.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp__6qntzv.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp__6qntzv.d(34): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp__6qntzv.d(36): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp__6qntzv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpku2wsgdr.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpku2wsgdr.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpku2wsgdr.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpku2wsgdr.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpku2wsgdr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (i < min_distance)\n                    {\n                        min_distance\
    \ = i;\n                        result = word[i];\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdqvhl3sa.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdqvhl3sa.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpdqvhl3sa.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpdqvhl3sa.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpdqvhl3sa.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdqvhl3sa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    static string vowels = \"aeiouAEIOU\";\n    static string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string result = \"\"\
    ;\n    int index = word.length - 1;\n    while (index > 0)\n    {\n        if\
    \ (consonants.find(word[index]) != -1)\n        {\n            if (vowels.find(word[index\
    \ - 1]) != -1)\n            {\n                result = word[index - 1];\n   \
    \             break;\n            }\n            else\n            {\n       \
    \         index--;\n            }\n        }\n        else\n        {\n      \
    \      index--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmx05azat.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpmx05azat.d(27): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpmx05azat.d(29): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpmx05azat.d(31): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)(index - 1)]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmx05azat.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min_distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1]) == -1)\n\
    \                {\n                    if (min_distance > abs(word.length - i))\n\
    \                    {\n                        min_distance = abs(word.length\
    \ - i);\n                        index = i;\n                    }\n         \
    \       }\n            }\n        }\n    }\n    if (index != 0)\n    {\n     \
    \   result = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprbqf27px.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprbqf27px.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprbqf27px.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmprbqf27px.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmprbqf27px.d(35): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmprbqf27px.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprbqf27px.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int\
    \ min_distance = word.length;\n    foreach(i, char c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            foreach(j, char d; word[i..$])\n            {\n\
    \                if(consonants.find(d) != -1)\n                {\n           \
    \         distance = j;\n                    break;\n                }\n     \
    \       }\n            if(distance < min_distance)\n            {\n          \
    \      min_distance = distance;\n                index = i;\n            }\n \
    \       }\n    }\n    if(min_distance != word.length)\n    {\n        result =\
    \ word[index..index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf9atsanx.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpf9atsanx.d(29): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpf9atsanx.d(33): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpf9atsanx.d(35): Error: cannot implicitly convert expression\
    \ `j` of type `ulong` to `int`\\n/tmp/tmpf9atsanx.d(42): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf9atsanx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            index = i;\n            distance = word.length\
    \ - i;\n            if (distance < min_distance)\n            {\n            \
    \    min_distance = distance;\n                result = word[i];\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4s24jyh8.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4s24jyh8.d(26): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp4s24jyh8.d(28):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp4s24jyh8.d(31): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\n/tmp/tmp4s24jyh8.d(35): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4s24jyh8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int pos = 0;\n    int min = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min > abs(word.length - i))\n                    {\n        \
    \                min = abs(word.length - i);\n                        pos = i;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if (pos != 0)\n    {\n        result = word[pos];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4xw4j7aq.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4xw4j7aq.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp4xw4j7aq.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp4xw4j7aq.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmp4xw4j7aq.d(35): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmp4xw4j7aq.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)pos]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4xw4j7aq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int index = word.length - 1;\n    while (index\
    \ >= 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n     \
    \       if (index != 0 && index != word.length - 1)\n            {\n         \
    \       if (consonants.find(word[index - 1]) != -1 && consonants.find(word[index\
    \ + 1]) != -1)\n                {\n                    result = word[index];\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp404pn3_p.d(24): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp404pn3_p.d(27): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp404pn3_p.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp404pn3_p.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp404pn3_p.d(33): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp404pn3_p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsn2ajyym.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpsn2ajyym.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpsn2ajyym.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpsn2ajyym.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsn2ajyym.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87yysrbv.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp87yysrbv.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp87yysrbv.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp87yysrbv.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp87yysrbv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = 0;\n    int min_distance = word.length;\n    for (int i =\
    \ word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            distance = word.length - i;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[i..$];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmzd9hqgb.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpmzd9hqgb.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpmzd9hqgb.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpmzd9hqgb.d(29): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmzd9hqgb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = 100;\n    int distance = 0;\n    int vowel_index = 0;\n\
    \    int consonant_index = 0;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            vowel_index\
    \ = i;\n            for (int j = i + 1; j < word.length; j++)\n            {\n\
    \                if (vowels.find(word[j]) == -1)\n                {\n        \
    \            consonant_index = j;\n                    distance = consonant_index\
    \ - vowel_index;\n                    if (distance < min_distance)\n         \
    \           {\n                        min_distance = distance;\n            \
    \            result = word[i];\n                    }\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxfdxsy37.d(29): Error: no property `find` for type `string`\\\
    n/tmp/tmpxfdxsy37.d(34): Error: no property `find` for type `string`\\n/tmp/tmpxfdxsy37.d(41):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxfdxsy37.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = 0;\n    int index = 0;\n    int min_index\
    \ = 0;\n    int word_length = word.length;\n    int vowel_length = vowels.length;\n\
    \    for (int i = 0; i < word_length; i++)\n    {\n        for (int j = 0; j <\
    \ vowel_length; j++)\n        {\n            if (word[i] == vowels[j])\n     \
    \       {\n                index = i;\n                distance = abs(word_length\
    \ - index);\n                if (distance < min_distance || min_distance == 0)\n\
    \                {\n                    min_distance = distance;\n           \
    \         min_index = index;\n                }\n            }\n        }\n  \
    \  }\n    if (min_index == 0)\n    {\n        return result;\n    }\n    else\n\
    \    {\n        result = word[min_index];\n        return result;\n    }\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy2aozd9h.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpy2aozd9h.d(28): Error: cannot implicitly\
    \ convert expression `vowels.length` of type `ulong` to `int`\\n/tmp/tmpy2aozd9h.d(51):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)min_index]` of\
    \ type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpy2aozd9h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (min_distance > abs(word.length - 1 - i))\n                  \
    \  {\n                        min_distance = abs(word.length - 1 - i);\n     \
    \                   result = word[i];\n                    }\n               \
    \ }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg5j7lb4x.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpg5j7lb4x.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg5j7lb4x.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpg5j7lb4x.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpg5j7lb4x.d(34): Error: cannot implicitly convert expression `abs(word.length\
    \ - 1LU - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmpg5j7lb4x.d(35): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg5j7lb4x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min = word.length;\n\
    \    foreach(i,v;word)\n    {\n        if(vowels.find(v) != -1)\n        {\n \
    \           int j = i;\n            while(j >= 0 && consonants.find(word[j]) !=\
    \ -1)\n            {\n                j--;\n            }\n            if(j >=\
    \ 0 && consonants.find(word[j]) == -1)\n            {\n                j++;\n\
    \            }\n            if(j >= 0 && consonants.find(word[j]) != -1)\n   \
    \         {\n                j++;\n            }\n            if(j < word.length\
    \ && consonants.find(word[j]) != -1)\n            {\n                if(abs(i\
    \ - j) < min)\n                {\n                    min = abs(i - j);\n    \
    \                index = i;\n                }\n            }\n        }\n   \
    \ }\n    if(index != 0)\n    {\n        result = word[index..index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi9odzdr4.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpi9odzdr4.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpi9odzdr4.d(30): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpi9odzdr4.d(31): Error: no\
    \ property `find` for type `string`\\n/tmp/tmpi9odzdr4.d(35): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpi9odzdr4.d(39): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpi9odzdr4.d(43): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpi9odzdr4.d(47): Error: cannot implicitly convert expression\
    \ `abs(i - cast(ulong)j)` of type `ulong` to `int`\\n/tmp/tmpi9odzdr4.d(48): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi9odzdr4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(v; vowels)\n    {\n        int index\
    \ = word.rfind(v);\n        if(index != -1)\n        {\n            int distance\
    \ = word.length - index;\n            if(distance < min_distance)\n          \
    \  {\n                min_distance = distance;\n                result = v;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpokdsa4jj.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpokdsa4jj.d(26): Error: no property `rfind`\
    \ for type `string`\\n/tmp/tmpokdsa4jj.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)index` of type `ulong` to `int`\\n/tmp/tmpokdsa4jj.d(33):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpokdsa4jj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = 0;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == 0)\n        return\
    \ \"\";\n    for (int i = index; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ == -1)\n        {\n            min = index - i;\n            break;\n      \
    \  }\n    }\n    for (int i = index - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (index - i < min)\n            {\n       \
    \         min = index - i;\n                result = word[i];\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm3igwmos.d(25): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpm3igwmos.d(27): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpm3igwmos.d(37): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpm3igwmos.d(45): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpm3igwmos.d(50): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3igwmos.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjvn0pvtu.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpjvn0pvtu.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpjvn0pvtu.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjvn0pvtu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    for (int i = 0; i < word.length; i++)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = 0;\n            for (int j = i + 1; j < word.length; j++)\n            {\n\
    \                if (vowels.find(word[j]) == -1)\n                {\n        \
    \            distance++;\n                }\n                else\n          \
    \      {\n                    break;\n                }\n            }\n     \
    \       if (distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = word[i..$];\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyzpyoym4.d(26): Error: no property `find` for type `string`\\\
    n/tmp/tmpyzpyoym4.d(31): Error: no property `find` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyzpyoym4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = word.length - 1; i >= 0;\
    \ i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_y2qhzwo.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_y2qhzwo.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp_y2qhzwo.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp_y2qhzwo.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_y2qhzwo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int vowel_index = 0;\n    int consonant_index = 0;\n    for (int i = 0; i\
    \ < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n      \
    \  {\n            vowel_index = i;\n            for (int j = vowel_index; j <\
    \ word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    consonant_index = j;\n      \
    \              distance = consonant_index - vowel_index;\n                   \
    \ if (distance < min_distance)\n                    {\n                      \
    \  min_distance = distance;\n                        result = word[vowel_index];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqgrqng83.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqgrqng83.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpqgrqng83.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpqgrqng83.d(42): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)vowel_index]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgrqng83.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            result = word[index];\n            break;\n \
    \       }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp76nd70tz.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp76nd70tz.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp76nd70tz.d(28): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76nd70tz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    foreach(i, c; word)\n    {\n        if(c\
    \ in vowels)\n        {\n            int distance = word.length - i;\n       \
    \     if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp38bnfzcn.d(26): Error: incompatible types for `(c) in (vowels)`:\
    \ `immutable(char)` and `string`\\n/tmp/tmp38bnfzcn.d(28): Error: cannot implicitly\
    \ convert expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp38bnfzcn.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp38bnfzcn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa0phhm6i.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpa0phhm6i.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpa0phhm6i.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpa0phhm6i.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpa0phhm6i.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpa0phhm6i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvacczfo6.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvacczfo6.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpvacczfo6.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpvacczfo6.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvacczfo6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvilunhgw.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvilunhgw.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpvilunhgw.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpvilunhgw.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpvilunhgw.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpvilunhgw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsjbz42pb.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpsjbz42pb.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpsjbz42pb.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpsjbz42pb.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsjbz42pb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length;\n    int vowel_index = 0;\n    int min_distance\
    \ = 0;\n    int distance = 0;\n    foreach(i, char c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            vowel_index = i;\n            distance = index\
    \ - vowel_index;\n            if(distance > 1)\n            {\n              \
    \  if(min_distance == 0)\n                {\n                    min_distance\
    \ = distance;\n                    result = c;\n                }\n          \
    \      else if(distance < min_distance)\n                {\n                 \
    \   min_distance = distance;\n                    result = c;\n              \
    \  }\n            }\n        }\n        index--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9t24k8ry.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9t24k8ry.d(29): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9t24k8ry.d(31): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp9t24k8ry.d(38): Error: cannot\
    \ implicitly convert expression `c` of type `char` to `string`\\n/tmp/tmp9t24k8ry.d(43):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9t24k8ry.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq853ly31.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpq853ly31.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpq853ly31.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpq853ly31.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq853ly31.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphxy4lbap.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphxy4lbap.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmphxy4lbap.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmphxy4lbap.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphxy4lbap.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5foqavud.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5foqavud.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp5foqavud.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp5foqavud.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5foqavud.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpooxcucpi.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpooxcucpi.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpooxcucpi.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpooxcucpi.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpooxcucpi.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpooxcucpi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index-1]) == -1)\n      \
    \      {\n                result = word[index];\n                break;\n    \
    \        }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvb4u2l3p.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpvb4u2l3p.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpvb4u2l3p.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpvb4u2l3p.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvb4u2l3p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && i < word.length - 1)\n            {\n              \
    \  if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n   \
    \             {\n                    distance = word.length - i;\n           \
    \         if (distance < min_distance)\n                    {\n              \
    \          min_distance = distance;\n                        result = word[i];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv03gged8.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpv03gged8.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpv03gged8.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpv03gged8.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpv03gged8.d(33): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpv03gged8.d(37): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv03gged8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(vowel; vowels)\n    {\n        int\
    \ index = word.rfind(vowel);\n        if(index != -1)\n        {\n           \
    \ int distance = word.length - index;\n            if(distance > 1 && distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = vowel;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7xwxyby.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpw7xwxyby.d(26): Error: no property `rfind`\
    \ for type `string`\\n/tmp/tmpw7xwxyby.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)index` of type `ulong` to `int`\\n/tmp/tmpw7xwxyby.d(33):\
    \ Error: cannot implicitly convert expression `vowel` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7xwxyby.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsb0ag0st.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpsb0ag0st.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpsb0ag0st.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpsb0ag0st.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpsb0ag0st.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpsb0ag0st.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int left = i;\n            int right = word.length - i\
    \ - 1;\n            if(left > 0 && right > 0)\n            {\n               \
    \ if(vowels.canFind(word[left - 1]) || vowels.canFind(word[right + 1]))\n    \
    \                continue;\n                if(min > abs(left - right))\n    \
    \            {\n                    min = abs(left - right);\n               \
    \     result = c;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp371e8xah.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp371e8xah.d(28): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmp371e8xah.d(29): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmp371e8xah.d(32):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp371e8xah.d(32): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmp371e8xah.d(37): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp371e8xah.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"AEIOUaeiou\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min_distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            int distance = word.length - i;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if (min_distance\
    \ != word.length)\n    {\n        result = word[index..index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpacrdh1v5.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpacrdh1v5.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpacrdh1v5.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpacrdh1v5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min = word.length;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            index = i;\n            if (index - 1 >= 0 && vowels.find(word[index\
    \ - 1]) == -1)\n            {\n                if (word.length - index < min)\n\
    \                {\n                    min = word.length - index;\n         \
    \           result = word[index];\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18nzbibt.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp18nzbibt.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp18nzbibt.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp18nzbibt.d(30): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp18nzbibt.d(34): Error: cannot\
    \ implicitly convert expression `word.length - cast(ulong)index` of type `ulong`\
    \ to `int`\\n/tmp/tmp18nzbibt.d(35): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18nzbibt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, vowel; vowels)\n    {\n        int\
    \ index = word.findLastOf(vowel);\n        if(index != -1)\n        {\n      \
    \      int distance = word.length - index;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = vowel;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpogc3fhyg.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpogc3fhyg.d(26): Error: no property `findLastOf`\
    \ for type `string`\\n/tmp/tmpogc3fhyg.d(29): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)index` of type `ulong` to `int`\\n/tmp/tmpogc3fhyg.d(33):\
    \ Error: cannot implicitly convert expression `vowel` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpogc3fhyg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    int distance = 0;\n    int index = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \           index = i;\n            }\n        }\n    }\n    if(index == 0 ||\
    \ index == word.length - 1)\n        return \"\";\n    if(!vowels.canFind(word[index\
    \ - 1]) && !vowels.canFind(word[index + 1]))\n        return result;\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps9zlg7jx.d(28): Error: no property `canFind` for type `string`\\\
    n/tmp/tmps9zlg7jx.d(30): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmps9zlg7jx.d(34): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\n/tmp/tmps9zlg7jx.d(35):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmps9zlg7jx.d(41):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmps9zlg7jx.d(41): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmps9zlg7jx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = -1;\n    int distance = 0;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            int temp = word.length\
    \ - i;\n            if(temp > distance)\n            {\n                distance\
    \ = temp;\n                index = i;\n            }\n        }\n    }\n    if(index\
    \ != -1)\n    {\n        result = word[index..$];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp92tcmq_g.d(27): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp92tcmq_g.d(29): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmp92tcmq_g.d(33): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp92tcmq_g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (i < min_distance)\n                    {\n                        min_distance\
    \ = i;\n                        result = word[i];\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplpqq3x1c.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplpqq3x1c.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmplpqq3x1c.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmplpqq3x1c.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmplpqq3x1c.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmplpqq3x1c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ closest = 999;\n    int index = 0;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            int distance = word.length - i;\n\
    \            if(distance < closest)\n            {\n                closest =\
    \ distance;\n                result = c;\n                index = i;\n       \
    \     }\n        }\n    }\n    if(index == 0 || index == word.length - 1)\n  \
    \      return \"\";\n    if(!vowels.canFind(word[index - 1]) && !vowels.canFind(word[index\
    \ + 1]))\n        return result;\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnyqdqluq.d(27): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpnyqdqluq.d(29): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpnyqdqluq.d(33): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\n/tmp/tmpnyqdqluq.d(34):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpnyqdqluq.d(40):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpnyqdqluq.d(40): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnyqdqluq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpglktqbts.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpglktqbts.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpglktqbts.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpglktqbts.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpglktqbts.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    int distance = 0;\n    int word_length =\
    \ word.length;\n    for (int i = 0; i < word_length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i == 0)\n            {\n                if\
    \ (vowels.find(word[i+1]) == -1)\n                {\n                    distance\
    \ = 1;\n                }\n            }\n            else if (i == word_length\
    \ - 1)\n            {\n                if (vowels.find(word[i-1]) == -1)\n   \
    \             {\n                    distance = 1;\n                }\n      \
    \      }\n            else\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    distance = 1;\n                }\n            }\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpf3ovy9.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpmpf3ovy9.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpmpf3ovy9.d(32): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpmpf3ovy9.d(39): Error: no property `find` for type `string`\\\
    n/tmp/tmpmpf3ovy9.d(46): Error: no property `find` for type `string`\\n/tmp/tmpmpf3ovy9.d(46):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpmpf3ovy9.d(54): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpf3ovy9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprpa3zpkk.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprpa3zpkk.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprpa3zpkk.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprpa3zpkk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcs9aeow3.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpcs9aeow3.d(25): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpcs9aeow3.d(27):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpcs9aeow3.d(29): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcs9aeow3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplxdn9x9t.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplxdn9x9t.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmplxdn9x9t.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplxdn9x9t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = word.length - 1; i >= 0;\
    \ i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i == word.length - 1)\n                continue;\n            if (vowels.find(word[i\
    \ + 1]) != -1)\n                continue;\n            int distance = word.length\
    \ - i - 1;\n            if (distance < min_distance)\n            {\n        \
    \        min_distance = distance;\n                result = word[i];\n       \
    \     }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxz74cwx9.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpxz74cwx9.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpxz74cwx9.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpxz74cwx9.d(30): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpxz74cwx9.d(32): Error: cannot\
    \ implicitly convert expression `word.length - cast(ulong)i - 1LU` of type `ulong`\
    \ to `int`\\n/tmp/tmpxz74cwx9.d(36): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)i]` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxz74cwx9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = int.max;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmggrl4vx.d(26): Error: no property `find` for type `string`\\\
    n/tmp/tmpmggrl4vx.d(28): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpmggrl4vx.d(32): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmggrl4vx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp81uwwid2.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp81uwwid2.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp81uwwid2.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp81uwwid2.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp81uwwid2.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp81uwwid2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdus6jsbx.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdus6jsbx.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpdus6jsbx.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpdus6jsbx.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpdus6jsbx.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpdus6jsbx.d(36): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdus6jsbx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe0d1r0lb.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe0d1r0lb.d(26): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpe0d1r0lb.d(28): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpe0d1r0lb.d(32):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe0d1r0lb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_dist = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int dist = word.length - i;\n            if(dist < min_dist)\n\
    \            {\n                min_dist = dist;\n                result = c;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgj6yajq9.d(26): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpgj6yajq9.d(28): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpgj6yajq9.d(32): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgj6yajq9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n        if(!vowels.canFind(word[index\
    \ - 1]) && !vowels.canFind(word[index + 1]))\n        {\n            result =\
    \ word[index..$];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2bbe8k4n.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2bbe8k4n.d(27): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp2bbe8k4n.d(29): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp2bbe8k4n.d(33):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp2bbe8k4n.d(39):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp2bbe8k4n.d(39): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2bbe8k4n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ < distance)\n            {\n                distance = i;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp576d_8oy.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp576d_8oy.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp576d_8oy.d(26):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp576d_8oy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpn0jnr9.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpmpn0jnr9.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpmpn0jnr9.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpmpn0jnr9.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpn0jnr9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (i < min_distance)\n                    {\n                  \
    \      min_distance = i;\n                        result = word[i];\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2_dp13oq.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2_dp13oq.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp2_dp13oq.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp2_dp13oq.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp2_dp13oq.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2_dp13oq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min = 0;\n    int min_index\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n\
    \        {\n            if(vowels.find(word[i+1]) != -1)\n            {\n    \
    \            index = i+1;\n                min = abs(index - i);\n           \
    \     min_index = index;\n                break;\n            }\n        }\n \
    \   }\n    foreach(i, c; word[index..$])\n    {\n        if(consonants.find(c)\
    \ != -1)\n        {\n            if(vowels.find(word[i+1]) != -1)\n          \
    \  {\n                if(abs(i+1 - index) < min)\n                {\n        \
    \            min = abs(i+1 - index);\n                    min_index = i+1;\n \
    \               }\n            }\n        }\n    }\n    if(min_index != 0)\n \
    \   {\n        result = word[min_index..min_index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpme6hvgkb.d(29): Error: no property `find` for type `string`\\\
    n/tmp/tmpme6hvgkb.d(31): Error: no property `find` for type `string`\\n/tmp/tmpme6hvgkb.d(33):\
    \ Error: cannot implicitly convert expression `i + 1LU` of type `ulong` to `int`\\\
    n/tmp/tmpme6hvgkb.d(34): Error: cannot implicitly convert expression `abs(cast(ulong)index\
    \ - i)` of type `ulong` to `int`\\n/tmp/tmpme6hvgkb.d(42): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpme6hvgkb.d(44): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpme6hvgkb.d(48): Error: cannot implicitly convert\
    \ expression `abs(i + 1LU - cast(ulong)index)` of type `ulong` to `int`\\n/tmp/tmpme6hvgkb.d(49):\
    \ Error: cannot implicitly convert expression `i + 1LU` of type `ulong` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpme6hvgkb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphg0ro311.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphg0ro311.d(24): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmphg0ro311.d(26):\
    \ Error: no property `find` for type `string`\\n/tmp/tmphg0ro311.d(28): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphg0ro311.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index - 1]) == -1)\n    \
    \        {\n                result = word[index];\n                break;\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzxrm3kwl.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpzxrm3kwl.d(26): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpzxrm3kwl.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpzxrm3kwl.d(30): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzxrm3kwl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int minDistance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < minDistance)\n                    {\n                        minDistance =\
    \ distance;\n                        result = word[i];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq5kh90y3.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpq5kh90y3.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpq5kh90y3.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpq5kh90y3.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmpq5kh90y3.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpq5kh90y3.d(36): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq5kh90y3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            int distance = word.length - i;\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7it6yzuh.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp7it6yzuh.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp7it6yzuh.d(30): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp7it6yzuh.d(30): Error: no property `find` for type `string`\\\
    n/tmp/tmp7it6yzuh.d(32): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp7it6yzuh.d(36): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7it6yzuh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if (distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = word[i..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjazf0jgq.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjazf0jgq.d(26): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjazf0jgq.d(28): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjazf0jgq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph61n9ey9.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmph61n9ey9.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmph61n9ey9.d(29): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmph61n9ey9.d(33):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph61n9ey9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if(distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \    }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp42viq4w_.d(25): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp42viq4w_.d(28): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp42viq4w_.d(30): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp42viq4w_.d(31):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp42viq4w_.d(31): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp42viq4w_.d(36): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp42viq4w_.d(43):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp42viq4w_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = word.length;\n    foreach(vowel;\
    \ vowels)\n    {\n        int distance = word.findLastOf(vowel);\n        if(distance\
    \ != -1 && distance < index)\n        {\n            index = distance;\n     \
    \       result = vowel;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0whilu3q.d(23): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0whilu3q.d(24): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmp0whilu3q.d(27):\
    \ Error: no property `findLastOf` for type `string`\\n/tmp/tmp0whilu3q.d(31):\
    \ Error: cannot implicitly convert expression `vowel` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0whilu3q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\
    \    int index = 0;\n    int min_distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n\
    \                {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if (index != 0)\n    {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiks81yfo.d(24): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpiks81yfo.d(27): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpiks81yfo.d(31): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpiks81yfo.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpiks81yfo.d(35): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpiks81yfo.d(44): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiks81yfo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
