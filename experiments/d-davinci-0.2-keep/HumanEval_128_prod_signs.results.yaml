name: HumanEval_128_prod_signs
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else\
    \ if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n\
    \        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzk5y4gcw.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpzk5y4gcw.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzk5y4gcw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa861p8_z.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpa861p8_z.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpa861p8_z.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa861p8_z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\
    \ \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt9z8e2ww.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpt9z8e2ww.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpt9z8e2ww.d(26):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9z8e2ww.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbeoii053.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpbeoii053.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbeoii053.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5knvcvw8.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5knvcvw8.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5knvcvw8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph76_t47b.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmph76_t47b.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph76_t47b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxy1qu2wx.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpxy1qu2wx.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxy1qu2wx.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxy1qu2wx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpupys2m7o.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpupys2m7o.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpupys2m7o.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpupys2m7o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n    \
    \    sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp729m1614.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp729m1614.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp729m1614.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxsuwmcvc.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpxsuwmcvc.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxsuwmcvc.d(26):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxsuwmcvc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpooxam7hy.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpooxam7hy.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpooxam7hy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp088szwyo.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp088szwyo.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp088szwyo.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp088szwyo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcppsurd_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpcppsurd_.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcppsurd_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\
    \ \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf0il4ip.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpjf0il4ip.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjf0il4ip.d(26):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjf0il4ip.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n    \
    \    sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpezkxuv6k.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpezkxuv6k.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpezkxuv6k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa64arfyy.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpa64arfyy.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpa64arfyy.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa64arfyy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwbrd8ctr.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpwbrd8ctr.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpwbrd8ctr.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwbrd8ctr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i != 0) \n        {\n            prod *= sign(i);\n   \
    \         sum += abs(i);\n        }\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpayiq0u5_.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpayiq0u5_.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpayiq0u5_.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpayiq0u5_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphh_tj_2f.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmphh_tj_2f.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphh_tj_2f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw56l36nk.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpw56l36nk.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw56l36nk.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw56l36nk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdjwyhnml.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdjwyhnml.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdjwyhnml.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu0lc3fdz.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu0lc3fdz.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu0lc3fdz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvjczy9v1.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvjczy9v1.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvjczy9v1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphz5dudp1.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmphz5dudp1.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphz5dudp1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long sum = 0;\n      \
    \  long prod = 1;\n        foreach (i; arr)\n        {\n            sum += abs(i);\n\
    \            prod *= sign(i);\n        }\n        return sum * prod;\n    }\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv2gx659e.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpv2gx659e.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv2gx659e.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2gx659e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i < 0 ? -1 : 1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7_xr6m4q.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp7_xr6m4q.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7_xr6m4q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (elem; arr)\n    {\n        if (elem < 0)\n            prod *= -1;\n       \
    \ else if (elem == 0)\n            prod = 0;\n        sum += abs(elem);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_gpt_7p.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpp_gpt_7p.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_gpt_7p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6p7uezgn.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6p7uezgn.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6p7uezgn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmrljs0gc.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpmrljs0gc.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmrljs0gc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpglg4_yj_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpglg4_yj_.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpglg4_yj_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvxao8wkz.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpvxao8wkz.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvxao8wkz.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvxao8wkz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpixg_uq2r.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpixg_uq2r.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpixg_uq2r.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptr3hgic3.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmptr3hgic3.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmptr3hgic3.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptr3hgic3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long res = 1;\n    foreach (i; arr)\n    {\n\
    \        res *= sign(i);\n    }\n    return res * arr.map!(abs).sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpazdsfpox.d(23): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpazdsfpox.d(25): Error: no property `map` for\
    \ type `long[]`\\n/tmp/tmpazdsfpox.d(19): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpazdsfpox.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpood08hxr.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpood08hxr.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpood08hxr.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpood08hxr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2sbztyhx.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2sbztyhx.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2sbztyhx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4y0y84pj.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp4y0y84pj.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y0y84pj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsy319neg.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpsy319neg.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpsy319neg.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsy319neg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi27r3ihs.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpi27r3ihs.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi27r3ihs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps27gwwft.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmps27gwwft.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps27gwwft.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf47q7z7.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpjf47q7z7.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjf47q7z7.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjf47q7z7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= -1;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_cm5ctex.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_cm5ctex.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cm5ctex.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjeh8vkmn.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpjeh8vkmn.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjeh8vkmn.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjeh8vkmn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum =\
    \ 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n\
    \        else if (i < 0)\n            prod *= -1;\n        else\n            prod\
    \ *= 0;\n        sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6fbqq92t.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6fbqq92t.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6fbqq92t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpydtb_ld0.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpydtb_ld0.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpydtb_ld0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (elem; arr)\n    {\n        sum += abs(elem);\n        prod *= sign(elem);\n\
    \    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgxpphv9l.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpgxpphv9l.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgxpphv9l.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgxpphv9l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod =\
    \ 1;\n    long sum = 0;\n    foreach(i; arr)\n    {\n        if(i < 0)\n     \
    \   {\n            prod *= -1;\n            sum += abs(i);\n        }\n      \
    \  else if(i > 0)\n        {\n            sum += i;\n        }\n        else\n\
    \        {\n            return null;\n        }\n    }\n    return sum * prod;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpus_mfzqh.d(33): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpus_mfzqh.d(36): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpus_mfzqh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        sum += abs(i);\n        prod\
    \ *= signbit(i) ? -1 : 1;\n    }\n    return sum * prod;\n}\nunittest\n{\n   \
    \ alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(271):\
    \ Error: no property `epsilon` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(272):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(292):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(335):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(353):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(371):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(6254):\
    \ Error: template instance `std.math.floatTraits!long` error instantiating\\n/tmp/tmp5b1p9lkw.d(25):\
    \        instantiated from here: `signbit!long`\\n/tmp/tmp5b1p9lkw.d(18): Error:\
    \ cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp5b1p9lkw.d(27): Error: cannot implicitly convert expression `sum * prod`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5b1p9lkw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n       \
    \     prod *= 1;\n        }\n        else if (i < 0) \n        {\n           \
    \ prod *= -1;\n        }\n        else \n        {\n            prod *= 0;\n \
    \       }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8_dn4ew9.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8_dn4ew9.d(40): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8_dn4ew9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (x; arr) \n    {\n        prod *= sign(x);\n        sum += abs(x);\n    }\n\
    \    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph7__z1pf.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmph7__z1pf.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmph7__z1pf.d(27):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7__z1pf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3193caxc.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp3193caxc.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3193caxc.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3193caxc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i < 0 ? -1 : 1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2pk1wv0q.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2pk1wv0q.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2pk1wv0q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        sum += abs(i);\n        prod\
    \ *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngbl6ngd.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpngbl6ngd.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpngbl6ngd.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngbl6ngd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrykln3r.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpcrykln3r.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcrykln3r.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        if (i <\
    \ 0)\n            prod *= -1;\n        sum += abs(i);\n    }\n    return sum *\
    \ prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxygw2b42.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxygw2b42.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxygw2b42.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaj16b87_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpaj16b87_.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaj16b87_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_nxz8xs9.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_nxz8xs9.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_nxz8xs9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpftmqi2h6.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpftmqi2h6.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpftmqi2h6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiv92i0l6.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpiv92i0l6.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiv92i0l6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum =\
    \ 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n         \
    \   prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n \
    \       {\n            prod *= -1;\n            sum += abs(i);\n        }\n  \
    \      else \n        {\n            prod *= 0;\n        }\n    }\n    return\
    \ Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_i3b76br.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_i3b76br.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_i3b76br.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum\
    \ += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu_smmybz.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpu_smmybz.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu_smmybz.d(27):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_smmybz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2dqdxnud.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2dqdxnud.d(30): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2dqdxnud.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_8s68llf.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_8s68llf.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_8s68llf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n    \
    \    sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvq3qo62q.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvq3qo62q.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvq3qo62q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2tn518un.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2tn518un.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tn518un.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg9msua3u.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpg9msua3u.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpg9msua3u.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg9msua3u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv16mu3q4.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpv16mu3q4.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv16mu3q4.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv16mu3q4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiir9k0cp.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpiir9k0cp.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiir9k0cp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpugn_ueet.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpugn_ueet.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpugn_ueet.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpugn_ueet.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl93bzm9w.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpl93bzm9w.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl93bzm9w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpefizk__u.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpefizk__u.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpefizk__u.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpefizk__u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n       \
    \     sum += abs(i);\n            prod *= -1;\n        }\n        else if (i >\
    \ 0) \n        {\n            sum += abs(i);\n            prod *= 1;\n       \
    \ }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpryy9fckb.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpryy9fckb.d(41): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpryy9fckb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvbn9i6ef.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvbn9i6ef.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvbn9i6ef.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n    \
    \    sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnl1o7j7g.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpnl1o7j7g.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnl1o7j7g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuhbkyfvd.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpuhbkyfvd.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuhbkyfvd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i < 0) \n        {\n            prod *= -1;\n         \
    \   sum += abs(i);\n        }\n        else if (i > 0) \n        {\n         \
    \   sum += i;\n        }\n        else \n        {\n            prod = 0;\n  \
    \      }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdl7c2lxs.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdl7c2lxs.d(37): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdl7c2lxs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n       \
    \     prod *= 1;\n        } \n        else if (i < 0) \n        {\n          \
    \  prod *= -1;\n        } \n        else \n        {\n            prod *= 0;\n\
    \        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo_x30j12.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpo_x30j12.d(40): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo_x30j12.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9fou89dp.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp9fou89dp.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9fou89dp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n       \
    \     prod *= -1;\n        }\n        else if (i == 0) \n        {\n         \
    \   prod = 0;\n            break;\n        }\n        sum += abs(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0dybh61e.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0dybh61e.d(37): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0dybh61e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgvugawq2.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgvugawq2.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgvugawq2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return\
    \ prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0gm7s26p.d(23): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp0gm7s26p.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0gm7s26p.d(26):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0gm7s26p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7xqiurq6.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp7xqiurq6.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp7xqiurq6.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7xqiurq6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpevthrhzy.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpevthrhzy.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpevthrhzy.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpevthrhzy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxlxhhfud.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpxlxhhfud.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxlxhhfud.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxlxhhfud.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr3tqe1y3.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpr3tqe1y3.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpr3tqe1y3.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr3tqe1y3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp908zg_9l.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp908zg_9l.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp908zg_9l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_om1rpvp.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp_om1rpvp.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_om1rpvp.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_om1rpvp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp34jyjouf.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp34jyjouf.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34jyjouf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        sum +=\
    \ abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp05q0c0va.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp05q0c0va.d(28): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp05q0c0va.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lev2tks.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1lev2tks.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1lev2tks.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpswkcqaw8.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpswkcqaw8.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpswkcqaw8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n\
    \    {\n        if (i > 0)\n        {\n            prod *= 1;\n            sum\
    \ += i;\n        }\n        else if (i < 0)\n        {\n            prod *= -1;\n\
    \            sum += abs(i);\n        }\n        else\n        {\n            prod\
    \ *= 0;\n        }\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1b3407_u.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1b3407_u.d(38): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1b3407_u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum =\
    \ 0;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n            prod\
    \ *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n \
    \           prod *= 0;\n        sum += abs(elem);\n    }\n    return Nullable!(long)(sum\
    \ * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkj5ed9lt.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkj5ed9lt.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkj5ed9lt.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk2vh7lwq.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpk2vh7lwq.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk2vh7lwq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n      \
    \      continue;\n        }\n        prod *= i / abs(i);\n        sum += abs(i);\n\
    \    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1hhfzb2w.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1hhfzb2w.d(33): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1hhfzb2w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long prod = 1;\n\
    \    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0) \n      \
    \  {\n            prod *= -1;\n        }\n        else if (i == 0) \n        {\n\
    \            prod = 0;\n            break;\n        }\n        sum += abs(i);\n\
    \    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptjza2esd.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmptjza2esd.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmptjza2esd.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptjza2esd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        sum += abs(i);\n        prod\
    \ *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx02658rw.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpx02658rw.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpx02658rw.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx02658rw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        if (i < 0) prod *= -1;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_9g8pq4h.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_9g8pq4h.d(27): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9g8pq4h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    else\n    {\n        long sum = 0;\n      \
    \  long prod = 1;\n        foreach (i; arr)\n        {\n            if (i > 0)\n\
    \                sum += i;\n            else if (i < 0)\n            {\n     \
    \           sum += abs(i);\n                prod *= -1;\n            }\n     \
    \   }\n        return sum * prod;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3cga6y1_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3cga6y1_.d(34): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3cga6y1_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9eiytyj2.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp9eiytyj2.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9eiytyj2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfs5_pcsb.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpfs5_pcsb.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfs5_pcsb.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfs5_pcsb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp696t82do.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp696t82do.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp696t82do.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp696t82do.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\
    \ \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpviur2xne.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpviur2xne.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpviur2xne.d(26):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpviur2xne.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5zu0tlwv.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5zu0tlwv.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5zu0tlwv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpky_nubxn.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpky_nubxn.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpky_nubxn.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpky_nubxn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa6kn3yfa.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpa6kn3yfa.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpa6kn3yfa.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa6kn3yfa.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmotxkckh.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpmotxkckh.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmotxkckh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8254cklc.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8254cklc.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8254cklc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long prod =\
    \ 1;\n    long sum = 0;\n    foreach(i; arr)\n    {\n        if(i == 0)\n    \
    \    {\n            return null;\n        }\n        else if(i > 0)\n        {\n\
    \            prod *= 1;\n            sum += i;\n        }\n        else\n    \
    \    {\n            prod *= -1;\n            sum += abs(i);\n        }\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkhulghmr.d(24): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkhulghmr.d(37): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkhulghmr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe6u1cn0j.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpe6u1cn0j.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpe6u1cn0j.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6u1cn0j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmparkic6fz.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmparkic6fz.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmparkic6fz.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmparkic6fz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0tv4rz2k.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0tv4rz2k.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0tv4rz2k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprfsskqr9.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmprfsskqr9.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprfsskqr9.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprfsskqr9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfcf3ltyj.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfcf3ltyj.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfcf3ltyj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp98zj57mj.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp98zj57mj.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98zj57mj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi_fo5w_e.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpi_fo5w_e.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi_fo5w_e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8jnb4n84.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8jnb4n84.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8jnb4n84.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9shev0a.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpx9shev0a.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9shev0a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long)\
    \ result = 0;\n    foreach(i; arr)\n    {\n        if(i == 0)\n        {\n   \
    \         return null;\n        }\n        else\n        {\n            result\
    \ *= i / abs(i);\n            result += abs(i);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppmvt8fw2.d(23): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppmvt8fw2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfae386ec.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpfae386ec.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfae386ec.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfae386ec.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5kkrugyu.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5kkrugyu.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5kkrugyu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqfe85rp.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpfqfe85rp.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfqfe85rp.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqfe85rp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n\
    \    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum +=\
    \ abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbl2cdm2v.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpbl2cdm2v.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpbl2cdm2v.d(27):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbl2cdm2v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprv69xy1n.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprv69xy1n.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprv69xy1n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp057e04nq.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp057e04nq.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp057e04nq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq86sqopm.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpq86sqopm.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq86sqopm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n       \
    \     prod *= 1;\n        }\n        else if (i < 0) \n        {\n           \
    \ prod *= -1;\n        }\n        else \n        {\n            prod *= 0;\n \
    \       }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkajvbjz5.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkajvbjz5.d(40): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkajvbjz5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8nj2uhht.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp8nj2uhht.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8nj2uhht.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8nj2uhht.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem;\
    \ arr) \n    {\n        sum += abs(elem);\n        prod *= sign(elem);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjsnbopvh.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpjsnbopvh.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjsnbopvh.d(26):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsnbopvh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpibkajmv1.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpibkajmv1.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpibkajmv1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeoqk3afw.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpeoqk3afw.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeoqk3afw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0q72lzvo.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0q72lzvo.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0q72lzvo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum = 0;\n\
    \    long prod = 1;\n    foreach(i; arr) \n    {\n        sum += abs(i);\n   \
    \     prod *= sign(i);\n    }\n    return prod == 0 ? null : sum * prod;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrni94hk.d(23): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpgrni94hk.d(25): Error: incompatible types\
    \ for `(null) : (sum * prod)`: `typeof(null)` and `long`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpgrni94hk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (elem; arr)\n    {\n        if (elem == 0)\n            continue;\n        prod\
    \ *= elem < 0 ? -1 : 1;\n        sum += abs(elem);\n    }\n    return sum * prod;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb076gez6.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpb076gez6.d(29): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb076gez6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3lx2i0l.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpf3lx2i0l.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3lx2i0l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw6nl681l.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw6nl681l.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw6nl681l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi4uhb9xc.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpi4uhb9xc.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi4uhb9xc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpalze134g.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpalze134g.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpalze134g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsaggo3x9.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpsaggo3x9.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpsaggo3x9.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsaggo3x9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3bb27ipd.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3bb27ipd.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3bb27ipd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpggjwkdu5.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpggjwkdu5.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpggjwkdu5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppqmomi6n.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmppqmomi6n.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppqmomi6n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmhxj_m_k.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpmhxj_m_k.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpmhxj_m_k.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmhxj_m_k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpguu2pvdr.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpguu2pvdr.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpguu2pvdr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_bo7j5_4.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_bo7j5_4.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_bo7j5_4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1eu7_wuu.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1eu7_wuu.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1eu7_wuu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzr7a_lpb.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpzr7a_lpb.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzr7a_lpb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqv85fv9x.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpqv85fv9x.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqv85fv9x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprs4yjsgw.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmprs4yjsgw.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprs4yjsgw.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprs4yjsgw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeancim3_.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpeancim3_.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpeancim3_.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeancim3_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0) \n        {\n            prod = 0;\n \
    \           break;\n        }\n        sum += abs(i);\n        prod *= sign(i);\n\
    \    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplqkj1k2i.d(30): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmplqkj1k2i.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmplqkj1k2i.d(32):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplqkj1k2i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i != 0) \n        {\n      \
    \      prod *= i / abs(i);\n            sum += abs(i);\n        }\n    }\n   \
    \ return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n\
    \        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps1csxm29.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmps1csxm29.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps1csxm29.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkoxkthac.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkoxkthac.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkoxkthac.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb1oxwdea.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpb1oxwdea.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpb1oxwdea.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1oxwdea.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv6735vpo.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpv6735vpo.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv6735vpo.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv6735vpo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpod61345u.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpod61345u.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpod61345u.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpod61345u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe6jkjt94.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpe6jkjt94.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6jkjt94.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphoqsf0ty.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmphoqsf0ty.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphoqsf0ty.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3fa8c8pv.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp3fa8c8pv.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3fa8c8pv.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3fa8c8pv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0) \n        {\n            prod = 0;\n \
    \           break;\n        }\n        prod *= i > 0 ? 1 : -1;\n        sum +=\
    \ abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ey2uyfv.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2ey2uyfv.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ey2uyfv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjbhirbz7.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjbhirbz7.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjbhirbz7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw2yfuznv.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw2yfuznv.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2yfuznv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (elem; arr) \n    {\n        if (elem < 0) \n        {\n \
    \           prod *= -1;\n        }\n        else if (elem == 0) \n        {\n\
    \            prod = 0;\n        }\n        sum += abs(elem);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp9r5vnye.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpp9r5vnye.d(36): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp9r5vnye.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else\
    \ if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwh16tfit.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpwh16tfit.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwh16tfit.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else\
    \ if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n\
    \        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmjvu1y2o.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpmjvu1y2o.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmjvu1y2o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpne2srrw4.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpne2srrw4.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpne2srrw4.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpne2srrw4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo793rpb9.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpo793rpb9.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo793rpb9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwsme0uag.d(26): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpwsme0uag.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpwsme0uag.d(29):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwsme0uag.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc0q6y44_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpc0q6y44_.d(32): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc0q6y44_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprvl1oye5.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprvl1oye5.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprvl1oye5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfobx519i.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpfobx519i.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfobx519i.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfobx519i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *=\
    \ i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu85plfoh.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu85plfoh.d(29): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu85plfoh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuyou7wji.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpuyou7wji.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuyou7wji.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgyew8uzb.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpgyew8uzb.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgyew8uzb.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgyew8uzb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphoo4batf.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmphoo4batf.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmphoo4batf.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphoo4batf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqg8fpeai.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpqg8fpeai.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqg8fpeai.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu2pwrjpa.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu2pwrjpa.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2pwrjpa.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiorck1rp.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpiorck1rp.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiorck1rp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i > 0)\n            prod *= 1;\n        else\n            prod *= 0;\n    \
    \    sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3947vnvj.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3947vnvj.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3947vnvj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5e34axhn.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5e34axhn.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5e34axhn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum\
    \ += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5mve3na1.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp5mve3na1.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5mve3na1.d(27):\
    \ Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5mve3na1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_t8ctou.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpz_t8ctou.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_t8ctou.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2wadyjum.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp2wadyjum.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2wadyjum.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wadyjum.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\
    \ \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n          \
    \  sum += i;\n        }\n        else if (i < 0) \n        {\n            prod\
    \ *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n  \
    \          prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpszkswpe9.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpszkswpe9.d(38): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpszkswpe9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n       \
    \     prod *= -1;\n        }\n        else if (i == 0) \n        {\n         \
    \   prod = 0;\n            break;\n        }\n        sum += abs(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvpjv3rs7.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvpjv3rs7.d(37): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvpjv3rs7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum +=\
    \ abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpira4kbk5.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpira4kbk5.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpira4kbk5.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpira4kbk5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        if (i <\
    \ 0)\n            prod *= -1;\n        sum += abs(i);\n    }\n    return sum *\
    \ prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0_dpv852.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0_dpv852.d(30): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0_dpv852.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0hxw8fu1.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp0hxw8fu1.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0hxw8fu1.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0hxw8fu1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp37x8dkw2.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp37x8dkw2.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp37x8dkw2.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37x8dkw2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdeumnmh3.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdeumnmh3.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdeumnmh3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxstk8mf_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxstk8mf_.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxstk8mf_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n      \
    \      continue;\n        }\n        prod *= i > 0 ? 1 : -1;\n        sum += abs(i);\n\
    \    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpltvmd_s3.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpltvmd_s3.d(33): Error: cannot\
    \ implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltvmd_s3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum = 0;\n\
    \    long prod = 1;\n    foreach(i; arr) \n    {\n        if (i == 0) \n     \
    \   {\n            return null;\n        }\n        sum += abs(i);\n        prod\
    \ *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeg8gesed.d(27): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpeg8gesed.d(24): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpeg8gesed.d(29):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeg8gesed.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    else \n    {\n\
    \        long prod = 1;\n        long sum = 0;\n        foreach (i; arr) \n  \
    \      {\n            if (i > 0) \n            {\n                prod *= 1;\n\
    \                sum += i;\n            }\n            else if (i < 0) \n    \
    \        {\n                prod *= -1;\n                sum += abs(i);\n    \
    \        }\n            else \n            {\n                prod *= 0;\n   \
    \         }\n        }\n        return Nullable!(long)(sum * prod);\n    }\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps_5eowbm.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmps_5eowbm.d(32): Error: cannot\
    \ implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps_5eowbm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0twy439q.d(25): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp0twy439q.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0twy439q.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0twy439q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
