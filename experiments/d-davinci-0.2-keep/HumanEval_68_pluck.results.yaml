name: HumanEval_68_pluck
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmposmpghvu.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmposmpghvu.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmposmpghvu.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xc5894554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpynnogkq7.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpynnogkq7.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpynnogkq7.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xec0a9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = long.max;\n\
    \    long minIndex = long.max;\n    foreach (i, v; arr)\n    {\n        if (v\
    \ % 2 == 0 && v < min)\n        {\n            min = v;\n            minIndex\
    \ = i;\n        }\n    }\n    \n    if (min == long.max)\n        return [];\n\
    \    \n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbqp7jj2e.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpbqp7jj2e.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpbqp7jj2e.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x48c65554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcz52l7rd.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpcz52l7rd.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpcz52l7rd.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x55f00554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long minIndex = 0;\n    bool\
    \ found = false;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0)\n    \
    \    {\n            if(!found)\n            {\n                found = true;\n\
    \                min = e;\n                minIndex = i;\n            }\n    \
    \        else\n            {\n                if(e < min)\n                {\n\
    \                    min = e;\n                    minIndex = i;\n           \
    \     }\n            }\n        }\n    }\n    if(found)\n    {\n        result[0]\
    \ = min;\n        result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8z7psuuy.d(77): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286f5]\\n??:? void tmp8z7psuuy.__unittest_L71_C1()\
    \ [0x4280c2]\\n??:? void tmp8z7psuuy.__modtest() [0x428474]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c753]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5bd]\\n??:? runModuleUnitTests [0x42c529]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b3f]\\n??:? _d_run_main [0x428aaa]\\n??:? main [0x428487]\\\
    n??:? __libc_start_main [0x27b71554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v < min && v % 2\
    \ == 0)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplmi3mw8v.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmplmi3mw8v.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmplmi3mw8v.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x5e07e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = int.max;\n \
    \   long minEvenIndex = int.max;\n    foreach (i, e; arr)\n    {\n        if (e\
    \ % 2 == 0 && e < minEven)\n        {\n            minEven = e;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    if (minEven == int.max)\n        return [];\n  \
    \  return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (index == -1)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min == long.max)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = 10001;\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min == 10001)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) \n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr) \n    {\n        if (v % 2 == 0 && v < min)\
    \ \n        {\n            min = v;\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0) \n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_hznt8su.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp_hznt8su.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp_hznt8su.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x16eb6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e <\
    \ min)\n        {\n            min = e;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8ojix99v.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp8ojix99v.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp8ojix99v.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x4185a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb4yfzqll.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpb4yfzqll.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpb4yfzqll.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xed6fb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2b1k899n.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp2b1k899n.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp2b1k899n.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x1741d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwcsqjku8.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpwcsqjku8.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpwcsqjku8.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x4050c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpie8m9wjc.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpie8m9wjc.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpie8m9wjc.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xf32d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = int.max;\n    long index = 0;\n \
    \   foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n        {\n\
    \            min = e;\n            index = i;\n        }\n    }\n    if(min !=\
    \ int.max)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkw4gy2t0.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmpkw4gy2t0.__unittest_L58_C1()\
    \ [0x42809e]\\n??:? void tmpkw4gy2t0.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c72b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430751]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c00]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b595]\\n??:? runModuleUnitTests [0x42c501]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0x868d5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnkfn17j1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpnkfn17j1.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpnkfn17j1.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x213e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = long.max;\n    long index\
    \ = -1;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (index == -1) return [];\n    return [min, index];\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return new long[0];\n    \n    long[] result\
    \ = new long[2];\n    long min = long.max;\n    long index = 0;\n    foreach (i,\
    \ v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n        {\n            min\
    \ = v;\n            index = i;\n        }\n    }\n    if (min == long.max)\n \
    \       return new long[0];\n    result[0] = min;\n    result[1] = index;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long smallestEven = 0;\n    long smallestEvenIndex\
    \ = 0;\n    long smallestEvenFound = false;\n    foreach(i, e; arr)\n    {\n \
    \       if(e % 2 == 0)\n        {\n            if(!smallestEvenFound)\n      \
    \      {\n                smallestEven = e;\n                smallestEvenIndex\
    \ = i;\n                smallestEvenFound = true;\n            }\n           \
    \ else\n            {\n                if(e < smallestEven)\n                {\n\
    \                    smallestEven = e;\n                    smallestEvenIndex\
    \ = i;\n                }\n            }\n        }\n    }\n    if(smallestEvenFound)\n\
    \    {\n        result[0] = smallestEven;\n        result[1] = smallestEvenIndex;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiahku3k1.d(77): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286fd]\\n??:? void tmpiahku3k1.__unittest_L71_C1()\
    \ [0x4280ca]\\n??:? void tmpiahku3k1.__modtest() [0x42847c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c75b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430781]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43070d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5c5]\\n??:? runModuleUnitTests [0x42c531]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bc0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b47]\\n??:? _d_run_main [0x428ab2]\\n??:? main [0x42848f]\\\
    n??:? __libc_start_main [0xa869a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = arr[0];\n    long minIndex = 0;\n\
    \    long minEven = 0;\n    long minEvenIndex = 0;\n    bool found = false;\n\
    \    foreach(i, e; arr)\n    {\n        if(e < min)\n        {\n            min\
    \ = e;\n            minIndex = i;\n        }\n        if(e % 2 == 0)\n       \
    \ {\n            if(!found)\n            {\n                minEven = e;\n   \
    \             minEvenIndex = i;\n                found = true;\n            }\n\
    \            else\n            {\n                if(e < minEven)\n          \
    \      {\n                    minEven = e;\n                    minEvenIndex =\
    \ i;\n                }\n            }\n        }\n    }\n    if(found)\n    {\n\
    \        result[0] = minEven;\n        result[1] = minEvenIndex;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpzwvqxu2s.d(41): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4287e6]\\n??:? long[] tmpzwvqxu2s.pluck(long[]) [0x427e48]\\\
    n??:? void tmpzwvqxu2s.__unittest_L78_C1() [0x4280c0]\\n??:? void tmpzwvqxu2s.__modtest()\
    \ [0x4284b8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c793]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b626]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430745]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5fd]\\n??:? runModuleUnitTests [0x42c569]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b7f]\\n??:? _d_run_main [0x428aea]\\n??:? main [0x4284cb]\\\
    n??:? __libc_start_main [0xaa0c7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi3g_eufa.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpi3g_eufa.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpi3g_eufa.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xc97d6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    long\
    \ i = 0;\n    foreach(long val; arr)\n    {\n        if(val % 2 == 0)\n      \
    \  {\n            if(min == 0)\n            {\n                min = val;\n  \
    \              index = i;\n            }\n            else if(val < min)\n   \
    \         {\n                min = val;\n                index = i;\n        \
    \    }\n        }\n        i++;\n    }\n    if(min != 0)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4t_gu5sx.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmp4t_gu5sx.__unittest_L68_C1()\
    \ [0x4280ba]\\n??:? void tmp4t_gu5sx.__modtest() [0x42846c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c74b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430771]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c20]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306fd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5b5]\\n??:? runModuleUnitTests [0x42c521]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x42847f]\\\
    n??:? __libc_start_main [0x128c3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = arr[0];\n    long index =\
    \ 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n   \
    \     {\n            min = v;\n            index = i;\n        }\n    }\n    if\
    \ (min % 2 == 0) return [min, index];\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpko5018m6.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpko5018m6.__unittest_L54_C1()\
    \ [0x428049]\\n??:? void tmpko5018m6.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x6505a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = int.max;\n    long\
    \ index = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (index == -1)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long[] evens = arr.filter!(a => a % 2 == 0);\n\
    \    if (evens.length == 0)\n        return result;\n    result[0] = evens.min;\n\
    \    result[1] = arr.indexOf(result[0]);\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpndqloivr.d(41): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpndqloivr.d(44): Error: no property `min` for type `long[]`\\n/tmp/tmpndqloivr.d(45):\
    \ Error: no property `indexOf` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpndqloivr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0y1vg96d.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp0y1vg96d.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp0y1vg96d.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x7a076554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (index == -1)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long minEven = long.max;\n\
    \    long minEvenIndex = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n            minEven\
    \ = arr[i];\n            minEvenIndex = i;\n        }\n    }\n    \n    if (minEvenIndex\
    \ == -1)\n        return [];\n    else\n        return [minEven, minEvenIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return new long[0];\n    \n    long min = long.max;\n\
    \    long minIndex = long.max;\n    foreach (i, e; arr)\n    {\n        if (e\
    \ % 2 == 0 && e < min)\n        {\n            min = e;\n            minIndex\
    \ = i;\n        }\n    }\n    \n    if (min == long.max)\n        return new long[0];\n\
    \    \n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6coyfetg.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp6coyfetg.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp6coyfetg.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xfcd64554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v <\
    \ min)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptid__161.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmptid__161.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmptid__161.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd3af8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    long minIndex = 0;\n    foreach (i, e; arr)\n    {\n       \
    \ if (e % 2 == 0)\n        {\n            if (e < min)\n            {\n      \
    \          min = e;\n                minIndex = i;\n            }\n        }\n\
    \    }\n    if (min == arr[0])\n        return [min, minIndex];\n    else\n  \
    \      return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfrf957ey.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmpfrf957ey.__unittest_L61_C1()\
    \ [0x427fce]\\n??:? void tmpfrf957ey.__modtest() [0x42846c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c74b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430771]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c20]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306fd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5b5]\\n??:? runModuleUnitTests [0x42c521]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x42847f]\\\
    n??:? __libc_start_main [0x41637554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [].dup;\n    \n    long minEven = long.max;\n\
    \    long minEvenIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n            minEven\
    \ = arr[i];\n            minEvenIndex = i;\n        }\n    }\n    \n    if (minEven\
    \ == long.max)\n        return [].dup;\n    \n    return [minEven, minEvenIndex].dup;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4wjfcmq6.d(41): Error: cannot implicitly convert expression `dup([])`\
    \ of type `void[]` to `long[]`\\n/tmp/tmp4wjfcmq6.d(55): Error: cannot implicitly\
    \ convert expression `dup([])` of type `void[]` to `long[]`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4wjfcmq6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpef_c7215.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpef_c7215.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpef_c7215.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x55540554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 ==\
    \ 0 && v < min)\n        {\n            min = v;\n            minIndex = i;\n\
    \        }\n    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n  \
    \  else\n        return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0kxajqpu.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp0kxajqpu.__unittest_L58_C1()\
    \ [0x428049]\\n??:? void tmp0kxajqpu.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x6d228554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long minIndex = 0;\n    foreach (i, e; arr)\n   \
    \ {\n        if (e % 2 == 0 && e < min)\n        {\n            min = e;\n   \
    \         minIndex = i;\n        }\n    }\n    if (min == arr[0])\n        return\
    \ result;\n    result[0] = min;\n    result[1] = minIndex;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpittoy5l1.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428735]\\n??:? void tmpittoy5l1.__unittest_L59_C1()\
    \ [0x4280a1]\\n??:? void tmpittoy5l1.__modtest() [0x4284b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c793]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b626]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430745]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5fd]\\n??:? runModuleUnitTests [0x42c569]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b7f]\\n??:? _d_run_main [0x428aea]\\n??:? main [0x4284c7]\\\
    n??:? __libc_start_main [0xdc40a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_507mhp8.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp_507mhp8.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp_507mhp8.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xafe7f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n    \
    \    {\n            min = v;\n            index = i;\n        }\n    }\n    if(index\
    \ == -1)\n        return [];\n    result[0] = min;\n    result[1] = index;\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7_jr05ny.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmp7_jr05ny.__unittest_L56_C1()\
    \ [0x428091]\\n??:? void tmp7_jr05ny.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0xbb3f7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = long.max;\n\
    \    long minEvenIndex = long.max;\n    foreach (i, v; arr)\n    {\n        if\
    \ (v % 2 == 0 && v < minEven)\n        {\n            minEven = v;\n         \
    \   minEvenIndex = i;\n        }\n    }\n    if (minEven == long.max)\n      \
    \  return [];\n    return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] < min && arr[i] % 2 == 0)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg1nso5xv.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpg1nso5xv.__unittest_L60_C1()\
    \ [0x4280b9]\\n??:? void tmpg1nso5xv.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0xa97d6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long min = long.max;\n    long index = -1;\n    foreach(i, v; arr)\n    {\n\
    \        if(v % 2 == 0 && v < min)\n        {\n            min = v;\n        \
    \    index = i;\n        }\n    }\n    if(index == -1)\n        return [];\n \
    \   return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = long.max;\n\
    \    long minEvenIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v %\
    \ 2 == 0 && v < minEven)\n        {\n            minEven = v;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    if (minEvenIndex == -1)\n        return [];\n  \
    \  return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = arr[0];\n  \
    \  long minEvenIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < minEven)\n\
    \            {\n                minEven = arr[i];\n                minEvenIndex\
    \ = i;\n            }\n        }\n    }\n    if (minEven % 2 == 0)\n        return\
    \ [minEven, minEvenIndex];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdi7u912o.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpdi7u912o.__unittest_L59_C1()\
    \ [0x428099]\\n??:? void tmpdi7u912o.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x581ac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ -1;\n    foreach(i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n   \
    \     {\n            min = v;\n            index = i;\n        }\n    }\n    if\
    \ (index == -1)\n        return result;\n    result[0] = min;\n    result[1] =\
    \ index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9mq7fp8b.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp9mq7fp8b.__unittest_L57_C1()\
    \ [0x4280aa]\\n??:? void tmp9mq7fp8b.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c797]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b62a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308b5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d64]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430841]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b601]\\n??:? runModuleUnitTests [0x42c56d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xc275b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long minIndex\
    \ = long.max;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  minIndex = i;\n        }\n    }\n    if (min == long.max)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = minIndex;\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptkl5mytu.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428735]\\n??:? void tmptkl5mytu.__unittest_L59_C1()\
    \ [0x428102]\\n??:? void tmptkl5mytu.__modtest() [0x4284b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b682]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43090d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430899]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b659]\\n??:? runModuleUnitTests [0x42c5c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b7f]\\n??:? _d_run_main [0x428aea]\\n??:? main [0x4284c7]\\\
    n??:? __libc_start_main [0x2bd3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long minIndex = 0;\n    long\
    \ index = 0;\n    bool isFirst = true;\n    foreach(long i; arr)\n    {\n    \
    \    if(i % 2 == 0)\n        {\n            if(isFirst)\n            {\n     \
    \           min = i;\n                minIndex = index;\n                isFirst\
    \ = false;\n            }\n            else\n            {\n                if(i\
    \ < min)\n                {\n                    min = i;\n                  \
    \  minIndex = index;\n                }\n            }\n        }\n        index++;\n\
    \    }\n    if(!isFirst)\n    {\n        result[0] = min;\n        result[1] =\
    \ minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc2cmh1l5.d(79): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286f5]\\n??:? void tmpc2cmh1l5.__unittest_L73_C1()\
    \ [0x4280c2]\\n??:? void tmpc2cmh1l5.__modtest() [0x428474]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c753]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5bd]\\n??:? runModuleUnitTests [0x42c529]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b3f]\\n??:? _d_run_main [0x428aaa]\\n??:? main [0x428487]\\\
    n??:? __libc_start_main [0xf96b1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    long minEven = 0;\n    long minEvenIndex = 0;\n \
    \   bool hasEven = false;\n    \n    foreach (i, v; arr)\n    {\n        if (v\
    \ < min)\n        {\n            min = v;\n            minIndex = i;\n       \
    \ }\n        \n        if (v % 2 == 0)\n        {\n            if (!hasEven)\n\
    \            {\n                minEven = v;\n                minEvenIndex = i;\n\
    \                hasEven = true;\n            }\n            else if (v < minEven)\n\
    \            {\n                minEven = v;\n                minEvenIndex = i;\n\
    \            }\n        }\n    }\n    \n    if (hasEven)\n        return [minEven,\
    \ minEvenIndex];\n    else\n        return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    else\n    {\n        long min\
    \ = arr[0];\n        long minIndex = 0;\n        foreach(i, v; arr)\n        {\n\
    \            if (v % 2 == 0 && v < min)\n            {\n                min =\
    \ v;\n                minIndex = i;\n            }\n        }\n        if (min\
    \ % 2 == 0)\n            return [min, minIndex];\n        else\n            return\
    \ [];\n    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6q0vwnne.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp6q0vwnne.__unittest_L60_C1()\
    \ [0x428049]\\n??:? void tmp6q0vwnne.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x41c32554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5b4n9jx5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp5b4n9jx5.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp5b4n9jx5.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x5eaac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long minEven = long.max;\n    long minEvenIndex\
    \ = -1;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < minEven)\n\
    \        {\n            minEven = e;\n            minEvenIndex = i;\n        }\n\
    \    }\n    if (minEvenIndex == -1) return [];\n    return [minEven, minEvenIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuyn8jou7.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpuyn8jou7.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpuyn8jou7.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xe11a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = long.max;\n\
    \    long index = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0\
    \ && v < min)\n        {\n            min = v;\n            index = i;\n     \
    \   }\n    }\n    \n    if (index == -1)\n        return [];\n    \n    return\
    \ [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    auto min = arr[0];\n    auto\
    \ index = 0;\n    auto found = false;\n    foreach (i, v; arr)\n    {\n      \
    \  if (v % 2 == 0)\n        {\n            if (!found)\n            {\n      \
    \          min = v;\n                index = i;\n                found = true;\n\
    \            }\n            else\n            {\n                if (v < min)\n\
    \                {\n                    min = v;\n                    index =\
    \ i;\n                }\n            }\n        }\n    }\n    if (found)\n   \
    \     return [min, index];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk_5gg0bi.d(52): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\n/tmp/tmpk_5gg0bi.d(60): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpk_5gg0bi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [long.max, long.max];\n    long[] evens = arr.filter!(a =>\
    \ a % 2 == 0);\n    if (evens.length == 0)\n        return [];\n    long min =\
    \ evens.min;\n    foreach (i, e; arr)\n    {\n        if (e == min)\n        {\n\
    \            result[0] = e;\n            result[1] = i;\n            break;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprmr7ukms.d(41): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmprmr7ukms.d(44): Error: no property `min` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprmr7ukms.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = long.max;\n\
    \    long minIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 ==\
    \ 0 && v < min)\n        {\n            min = v;\n            minIndex = i;\n\
    \        }\n    }\n    \n    if (minIndex == -1)\n        return [];\n    \n \
    \   return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ -1;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n    \
    \    {\n            min = e;\n            index = i;\n        }\n    }\n    if(index\
    \ != -1)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_6tj_vx5.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmp_6tj_vx5.__unittest_L58_C1()\
    \ [0x42809e]\\n??:? void tmp_6tj_vx5.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0x9fc16554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    long\
    \ i = 0;\n    foreach(long value; arr)\n    {\n        if(value % 2 == 0)\n  \
    \      {\n            if(min == 0)\n            {\n                min = value;\n\
    \                index = i;\n            }\n            else if(value < min)\n\
    \            {\n                min = value;\n                index = i;\n   \
    \         }\n        }\n        i++;\n    }\n    if(min != 0)\n    {\n       \
    \ result[0] = min;\n        result[1] = index;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphvvv6_po.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmphvvv6_po.__unittest_L68_C1()\
    \ [0x4280ba]\\n??:? void tmphvvv6_po.__modtest() [0x42846c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c74b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430771]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c20]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306fd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5b5]\\n??:? runModuleUnitTests [0x42c521]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x42847f]\\\
    n??:? __libc_start_main [0x6a2c6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0,0];\n    if(arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long minIndex = 0;\n    foreach(i,v; arr)\n    {\n\
    \        if(v % 2 == 0 && v < min)\n        {\n            min = v;\n        \
    \    minIndex = i;\n        }\n    }\n    if(min == arr[0])\n        return result;\n\
    \    result[0] = min;\n    result[1] = minIndex;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5zxe01tg.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428735]\\n??:? void tmp5zxe01tg.__unittest_L59_C1()\
    \ [0x4280a1]\\n??:? void tmp5zxe01tg.__modtest() [0x4284b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c793]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b626]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430745]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5fd]\\n??:? runModuleUnitTests [0x42c569]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b7f]\\n??:? _d_run_main [0x428aea]\\n??:? main [0x4284c7]\\\
    n??:? __libc_start_main [0xed99c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8riw65qx.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmp8riw65qx.__unittest_L60_C1()\
    \ [0x4280bd]\\n??:? void tmp8riw65qx.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0xde48c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp99k_0be7.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp99k_0be7.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp99k_0be7.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x52b48554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    int index = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] < min && arr[i] % 2 == 0)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp91j536sv.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428745]\\n??:? void tmp91j536sv.__unittest_L60_C1()\
    \ [0x4280b5]\\n??:? void tmp91j536sv.__modtest() [0x4284c8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7ff]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b692]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43091d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dcc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308a9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b669]\\n??:? runModuleUnitTests [0x42c5d5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c08]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b8f]\\n??:? _d_run_main [0x428afa]\\n??:? main [0x4284db]\\\
    n??:? __libc_start_main [0x58f04554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [long.max, long.max];\n    foreach(i, v; arr)\n    {\n  \
    \      if(v % 2 == 0 && v < result[0])\n        {\n            result[0] = v;\n\
    \            result[1] = i;\n        }\n    }\n    if(result[0] == long.max)\n\
    \        return [];\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    if (arr.length == 0)\n        return result;\n\
    \    \n    long smallestEven = arr[0];\n    long smallestIndex = 0;\n    bool\
    \ found = false;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0)\n  \
    \      {\n            if (!found)\n            {\n                smallestEven\
    \ = v;\n                smallestIndex = i;\n                found = true;\n  \
    \          }\n            else\n            {\n                if (v < smallestEven)\n\
    \                {\n                    smallestEven = v;\n                  \
    \  smallestIndex = i;\n                }\n            }\n        }\n    }\n  \
    \  if (found)\n    {\n        result[0] = smallestEven;\n        result[1] = smallestIndex;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx9ah32ik.d(80): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpx9ah32ik.__unittest_L74_C1()\
    \ [0x4280fa]\\n??:? void tmpx9ah32ik.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xbf009554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = arr[0];\n  \
    \  long minEvenIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < minEven)\n\
    \            {\n                minEven = arr[i];\n                minEvenIndex\
    \ = i;\n            }\n        }\n    }\n    if (minEven % 2 == 0)\n        return\
    \ [minEven, minEvenIndex];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmporavviuw.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmporavviuw.__unittest_L59_C1()\
    \ [0x428099]\\n??:? void tmporavviuw.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xe03dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwg1rio4o.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpwg1rio4o.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpwg1rio4o.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x8abf6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwfd9dc90.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpwfd9dc90.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpwfd9dc90.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x4c9ed554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = long.max;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 &&\
    \ v < min)\n        {\n            min = v;\n            index = i;\n        }\n\
    \    }\n    if (min == long.max)\n        return [];\n    return [min, index];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long[] evens = arr.filter!(a\
    \ => a % 2 == 0).array;\n    if (evens.length == 0)\n        return [];\n    long\
    \ min = evens[0];\n    long index = 0;\n    foreach (i, e; evens)\n    {\n   \
    \     if (e < min)\n        {\n            min = e;\n            index = i;\n\
    \        }\n    }\n    return [min, index];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsu2t1dn2.d(42): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsu2t1dn2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] ret = new long[2];\n    long min = long.max;\n    long minIndex =\
    \ long.max;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            minIndex = i;\n        }\n    }\n\
    \    if(min == long.max)\n        return ret;\n    ret[0] = min;\n    ret[1] =\
    \ minIndex;\n    return ret;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5uo0wm8k.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp5uo0wm8k.__unittest_L57_C1()\
    \ [0x4280ae]\\n??:? void tmp5uo0wm8k.__modtest() [0x428460]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c797]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b62a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308b5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d64]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430841]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b601]\\n??:? runModuleUnitTests [0x42c56d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x428473]\\\
    n??:? __libc_start_main [0x153eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] res = new long[2];\n    long min = long.max;\n    long index = 0;\n\
    \    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n        {\n\
    \            min = e;\n            index = i;\n        }\n    }\n    if(min ==\
    \ long.max) return res;\n    res[0] = min;\n    res[1] = index;\n    return res;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpddgla_l8.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286e5]\\n??:? void tmpddgla_l8.__unittest_L56_C1()\
    \ [0x4280b2]\\n??:? void tmpddgla_l8.__modtest() [0x428464]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c79f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b632]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308bd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430849]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b609]\\n??:? runModuleUnitTests [0x42c575]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b2f]\\n??:? _d_run_main [0x428a9a]\\n??:? main [0x428477]\\\
    n??:? __libc_start_main [0xa9f0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long minEven = long.max;\n    long minEvenIndex\
    \ = -1;\n    foreach(i, value; arr)\n    {\n        if(value % 2 == 0 && value\
    \ < minEven)\n        {\n            minEven = value;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    if(minEvenIndex != -1)\n    {\n        result[0]\
    \ = minEven;\n        result[1] = minEvenIndex;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf490uo5u.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmpf490uo5u.__unittest_L58_C1()\
    \ [0x42809e]\\n??:? void tmpf490uo5u.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0x85129554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ minIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v\
    \ < min)\n        {\n            min = v;\n            minIndex = i;\n       \
    \ }\n    }\n    if (minIndex == -1)\n        return [];\n    return [min, minIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (index == -1)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = long.max;\n\
    \    long minEvenIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2\
    \ == 0 && v < minEven)\n        {\n            minEven = v;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    if (minEven == long.max)\n        return [];\n \
    \   return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [].dup;\n    \n    long minEven = long.max;\n\
    \    long minEvenIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v %\
    \ 2 == 0 && v < minEven)\n        {\n            minEven = v;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    \n    if (minEvenIndex == -1)\n        return [].dup;\n\
    \    \n    return [minEven, minEvenIndex].dup;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpacqt264y.d(41): Error: cannot implicitly convert expression `dup([])`\
    \ of type `void[]` to `long[]`\\n/tmp/tmpacqt264y.d(55): Error: cannot implicitly\
    \ convert expression `dup([])` of type `void[]` to `long[]`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpacqt264y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    \n    long min = arr[0];\n    long minIndex = 0;\n    for (int i = 0; i <\
    \ arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n    \
    \    {\n            min = arr[i];\n            minIndex = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = minIndex;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprbu5w81x.d(66): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmprbu5w81x.__unittest_L61_C1()\
    \ [0x4280bd]\\n??:? void tmprbu5w81x.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x98bba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long smallest = arr[0];\n \
    \   long index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n      \
    \  if (arr[i] % 2 == 0 && arr[i] < smallest)\n        {\n            smallest\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (smallest % 2 ==\
    \ 0)\n        return [smallest, index];\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp434ceg0v.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp434ceg0v.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp434ceg0v.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x33db1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpit9c8q48.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpit9c8q48.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpit9c8q48.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x8eb56554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9gzo2ybz.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp9gzo2ybz.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp9gzo2ybz.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x6d789554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkx3x7jcq.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpkx3x7jcq.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpkx3x7jcq.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x1fe2d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo61sany0.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpo61sany0.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpo61sany0.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x7264a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    long\
    \ i = 0;\n    foreach(e; arr)\n    {\n        if(e % 2 == 0)\n        {\n    \
    \        if(result[0] == 0)\n            {\n                result[0] = e;\n \
    \               result[1] = i;\n            }\n            else if(e < result[0])\n\
    \            {\n                result[0] = e;\n                result[1] = i;\n\
    \            }\n        }\n        i++;\n    }\n    if(result[0] == 0)\n    {\n\
    \        result = [];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph2g0ostt.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42879d]\\n??:? void tmph2g0ostt.__unittest_L67_C1()\
    \ [0x42820c]\\n??:? void tmph2g0ostt.__modtest() [0x42851c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b68e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430cd0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4307ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b665]\\n??:? runModuleUnitTests [0x42c5d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c60]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428be7]\\n??:? _d_run_main [0x428b52]\\n??:? main [0x42852f]\\\
    n??:? __libc_start_main [0xf5ce8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplotjsph4.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmplotjsph4.__unittest_L56_C1()\
    \ [0x428091]\\n??:? void tmplotjsph4.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0x4baa4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppbhnn22f.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmppbhnn22f.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmppbhnn22f.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xa03a0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptgksxkq1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmptgksxkq1.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmptgksxkq1.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xf2fd6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvt_ujg6v.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpvt_ujg6v.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpvt_ujg6v.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x53b3f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) \n        return [];\n    long min = long.max;\n   \
    \ long index = -1;\n    foreach (i, v; arr) \n    {\n        if (v % 2 == 0 &&\
    \ v < min) \n        {\n            min = v;\n            index = i;\n       \
    \ }\n    }\n    if (index == -1) \n        return [];\n    return [min, index];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = arr[0];\n    long index =\
    \ 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n   \
    \     {\n            min = v;\n            index = i;\n        }\n    }\n    if\
    \ (min % 2 == 0) return [min, index];\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk6h7x783.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpk6h7x783.__unittest_L54_C1()\
    \ [0x428049]\\n??:? void tmpk6h7x783.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xbb78a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = long.max;\n    long index = 0;\n\
    \    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n\
    \            min = v;\n            index = i;\n        }\n    }\n    if(min !=\
    \ long.max)\n    {\n        result[0] = min;\n        result[1] = index;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp29gvmptm.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp29gvmptm.__unittest_L58_C1()\
    \ [0x4280ae]\\n??:? void tmp29gvmptm.__modtest() [0x428460]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x428473]\\\
    n??:? __libc_start_main [0xc8cb6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    if (arr.length == 0)\n        return result;\n\
    \    \n    long smallestEven = int.max;\n    long smallestEvenIndex = int.max;\n\
    \    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < smallestEven)\n\
    \        {\n            smallestEven = v;\n            smallestEvenIndex = i;\n\
    \        }\n    }\n    if (smallestEven == int.max)\n        return result;\n\
    \    return [smallestEven, smallestEvenIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphvlsydf7.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286c5]\\n??:? void tmphvlsydf7.__unittest_L58_C1()\
    \ [0x428092]\\n??:? void tmphvlsydf7.__modtest() [0x428444]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6af]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b542]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b84]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430661]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b519]\\n??:? runModuleUnitTests [0x42c485]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b14]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428a9b]\\n??:? _d_run_main [0x428a06]\\n??:? main [0x428457]\\\
    n??:? __libc_start_main [0x93eec554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp2jajive.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpp2jajive.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpp2jajive.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x4f4f5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = arr[0];\n  \
    \  long minEvenIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n\
    \        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < minEven)\n\
    \            {\n                minEven = arr[i];\n                minEvenIndex\
    \ = i;\n            }\n        }\n    }\n    if (minEven % 2 == 0)\n        return\
    \ [minEven, minEvenIndex];\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe8il62pq.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpe8il62pq.__unittest_L59_C1()\
    \ [0x428099]\\n??:? void tmpe8il62pq.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xe6308554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, val; arr)\n    {\n        if (val % 2 == 0 &&\
    \ val < min)\n        {\n            min = val;\n            minIndex = i;\n \
    \       }\n    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n   \
    \ return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbuh8tmuw.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpbuh8tmuw.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpbuh8tmuw.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xbf5bb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaghbmet1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpaghbmet1.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpaghbmet1.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd24aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0_7yra4g.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp0_7yra4g.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp0_7yra4g.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x38d0f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return new long[0];\n    \n    long min = long.max;\n\
    \    long minIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 ==\
    \ 0 && v < min)\n        {\n            min = v;\n            minIndex = i;\n\
    \        }\n    }\n    \n    if (minIndex == -1)\n        return new long[0];\n\
    \    \n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0,0];\n    long min = 0;\n    long index = 0;\n    bool\
    \ found = false;\n    foreach(long i; arr)\n    {\n        if(i%2 == 0)\n    \
    \    {\n            if(!found)\n            {\n                min = i;\n    \
    \            index = arr.indexOf(i);\n                found = true;\n        \
    \    }\n            else\n            {\n                if(i < min)\n       \
    \         {\n                    min = i;\n                    index = arr.indexOf(i);\n\
    \                }\n            }\n        }\n    }\n    if(found)\n    {\n  \
    \      result[0] = min;\n        result[1] = index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu7i7xr_5.d(51): Error: no property `indexOf` for type `long[]`\\\
    n/tmp/tmpu7i7xr_5.d(59): Error: no property `indexOf` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu7i7xr_5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    int index = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphmh2jnh3.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmphmh2jnh3.__unittest_L60_C1()\
    \ [0x4280b9]\\n??:? void tmphmh2jnh3.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0xd01dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp036zv2h0.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp036zv2h0.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp036zv2h0.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x20c43554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n        return [];\n  \
    \  return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++) \n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min) \n        {\n            min = arr[i];\n         \
    \   index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min,\
    \ index];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n  \
    \  assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmhn3t4xl.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpmhn3t4xl.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpmhn3t4xl.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x6ac89554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min == long.max)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8hjthwss.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmp8hjthwss.__unittest_L56_C1()\
    \ [0x428091]\\n??:? void tmp8hjthwss.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0x51a3c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf5bttqck.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpf5bttqck.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpf5bttqck.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xbb10554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) \n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++) \n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min) \n        {\n            min = arr[i];\n \
    \           minIndex = i;\n        }\n    }\n    if (min % 2 == 0) \n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphp6vlm8z.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmphp6vlm8z.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmphp6vlm8z.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x92899554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7qu14avp.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp7qu14avp.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp7qu14avp.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x8bc48554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph7e1gu6r.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmph7e1gu6r.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmph7e1gu6r.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xf2dca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return new long[0];\n    long min = arr[0];\n\
    \    long index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 &&\
    \ v < min)\n        {\n            min = v;\n            index = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, index];\n    return new long[0];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8p5ky04b.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmp8p5ky04b.__unittest_L56_C1()\
    \ [0x42803d]\\n??:? void tmp8p5ky04b.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0xc9c35554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmwl0scus.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpmwl0scus.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpmwl0scus.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x73776554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e <\
    \ min)\n        {\n            min = e;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcwofdfox.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpcwofdfox.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpcwofdfox.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xdb7e7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v <\
    \ min)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpscct8yre.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpscct8yre.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpscct8yre.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x50b06554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbnqjfrjf.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmpbnqjfrjf.__unittest_L56_C1()\
    \ [0x428091]\\n??:? void tmpbnqjfrjf.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0xab59e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7ggv05an.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp7ggv05an.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp7ggv05an.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x70f68554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [];\n    long min = long.max;\n    long minIndex = long.max;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0\
    \ && arr[i] < min)\n        {\n            min = arr[i];\n            minIndex\
    \ = i;\n        }\n    }\n    if (min != long.max)\n    {\n        result ~= min;\n\
    \        result ~= minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long minEven = long.max;\n\
    \    long minEvenIndex = -1;\n    foreach (i, e; arr)\n    {\n        if (e %\
    \ 2 == 0 && e < minEven)\n        {\n            minEven = e;\n            minEvenIndex\
    \ = i;\n        }\n    }\n    if (minEvenIndex == -1)\n        return [];\n  \
    \  return [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpheu3qmns.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpheu3qmns.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpheu3qmns.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xde84d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    long\
    \ i = 0;\n    foreach(e; arr)\n    {\n        if(e % 2 == 0)\n        {\n    \
    \        if(min == 0)\n            {\n                min = e;\n             \
    \   index = i;\n            }\n            else if(e < min)\n            {\n \
    \               min = e;\n                index = i;\n            }\n        }\n\
    \        i++;\n    }\n    if(min != 0)\n    {\n        result[0] = min;\n    \
    \    result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdz_asvjj.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmpdz_asvjj.__unittest_L68_C1()\
    \ [0x4280ba]\\n??:? void tmpdz_asvjj.__modtest() [0x42846c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c74b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430771]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c20]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306fd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5b5]\\n??:? runModuleUnitTests [0x42c521]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x42847f]\\\
    n??:? __libc_start_main [0xecce4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxcjnq7c5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpxcjnq7c5.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpxcjnq7c5.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd50e8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long minIndex = 0;\n    foreach (i, v; arr)\n   \
    \ {\n        if (v % 2 == 0 && v < min)\n        {\n            min = v;\n   \
    \         minIndex = i;\n        }\n    }\n    if (min == arr[0])\n        return\
    \ result;\n    result[0] = min;\n    result[1] = minIndex;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdv8b2egr.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428735]\\n??:? void tmpdv8b2egr.__unittest_L59_C1()\
    \ [0x4280a1]\\n??:? void tmpdv8b2egr.__modtest() [0x4284b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c793]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b626]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430745]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5fd]\\n??:? runModuleUnitTests [0x42c569]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b7f]\\n??:? _d_run_main [0x428aea]\\n??:? main [0x4284c7]\\\
    n??:? __libc_start_main [0x4733c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n    \
    \    {\n            min = v;\n            index = i;\n        }\n    }\n    if(index\
    \ != -1)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk_wt9ju7.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmpk_wt9ju7.__unittest_L58_C1()\
    \ [0x42809e]\\n??:? void tmpk_wt9ju7.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0xe656f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    long\
    \ i = 0;\n    foreach(long val; arr)\n    {\n        if(val % 2 == 0)\n      \
    \  {\n            if(min == 0)\n            {\n                min = val;\n  \
    \              index = i;\n            }\n            else if(val < min)\n   \
    \         {\n                min = val;\n                index = i;\n        \
    \    }\n        }\n        i++;\n    }\n    if(min != 0)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp07l7hht2.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmp07l7hht2.__unittest_L68_C1()\
    \ [0x4280ba]\\n??:? void tmp07l7hht2.__modtest() [0x42846c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c74b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430771]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c20]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306fd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5b5]\\n??:? runModuleUnitTests [0x42c521]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x42847f]\\\
    n??:? __libc_start_main [0x253ea554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = arr[0];\n    long minIndex\
    \ = 0;\n    foreach (i, value; arr)\n    {\n        if (value % 2 == 0 && value\
    \ < min)\n        {\n            min = value;\n            minIndex = i;\n   \
    \     }\n    }\n    if (min % 2 == 0)\n    {\n        return [min, minIndex];\n\
    \    }\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdc0gxx0r.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpdc0gxx0r.__unittest_L57_C1()\
    \ [0x428049]\\n??:? void tmpdc0gxx0r.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x3133554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] %\
    \ 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (index != -1)\n    {\n        result[0] = min;\n\
    \        result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpglzpein5.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428715]\\n??:? void tmpglzpein5.__unittest_L58_C1()\
    \ [0x4280e6]\\n??:? void tmpglzpein5.__modtest() [0x428498]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b662]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308ed]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430879]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b639]\\n??:? runModuleUnitTests [0x42c5a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bd8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b5f]\\n??:? _d_run_main [0x428aca]\\n??:? main [0x4284ab]\\\
    n??:? __libc_start_main [0x8494e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4qzborel.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp4qzborel.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp4qzborel.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x22aee554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i]\
    \ < min)\n            {\n                min = arr[i];\n                index\
    \ = i;\n            }\n        }\n    }\n    if (min % 2 == 0)\n    {\n      \
    \  result[0] = min;\n        result[1] = index;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp982z5myn.d(68): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmp982z5myn.__unittest_L63_C1()\
    \ [0x4280bd]\\n??:? void tmp982z5myn.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x350c1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa6nwkud1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpa6nwkud1.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpa6nwkud1.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x2915e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd25bulb7.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpd25bulb7.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpd25bulb7.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x799ef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    bool isFirst = true;\n  \
    \  for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            if (isFirst)\n            {\n                min = arr[i];\n\
    \                result[0] = min;\n                result[1] = i;\n          \
    \      isFirst = false;\n            }\n            else\n            {\n    \
    \            if (arr[i] < min)\n                {\n                    min = arr[i];\n\
    \                    result[0] = min;\n                    result[1] = i;\n  \
    \              }\n            }\n        }\n    }\n    if (isFirst)\n    {\n \
    \       return [];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = long.max;\n    long index = 0;\n\
    \    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n        {\n\
    \            min = e;\n            index = i;\n        }\n    }\n    if(min !=\
    \ long.max)\n    {\n        result[0] = min;\n        result[1] = index;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpautvp0kp.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpautvp0kp.__unittest_L58_C1()\
    \ [0x4280ae]\\n??:? void tmpautvp0kp.__modtest() [0x428460]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x428473]\\\
    n??:? __libc_start_main [0xbb679554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    auto min = arr[0];\n    auto\
    \ minIndex = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e <\
    \ min)\n        {\n            min = e;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp283bkq_e.d(49): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp283bkq_e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3hkojqq5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp3hkojqq5.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp3hkojqq5.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x8edde554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long index =\
    \ long.max;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n        return result;\n    result[0] = min;\n    result[1]\
    \ = index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzdt9w9qb.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpzdt9w9qb.__unittest_L57_C1()\
    \ [0x4280ae]\\n??:? void tmpzdt9w9qb.__modtest() [0x428460]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c797]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b62a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308b5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d64]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430841]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b601]\\n??:? runModuleUnitTests [0x42c56d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x428473]\\\
    n??:? __libc_start_main [0xd9846554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpze3ez0jw.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpze3ez0jw.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpze3ez0jw.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xc6790554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd84nqpw2.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpd84nqpw2.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpd84nqpw2.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xc972a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] res = new long[2];\n    long min = long.max;\n    long minIndex =\
    \ long.max;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  minIndex = i;\n        }\n    }\n    if (min == long.max)\n        return res;\n\
    \    res[0] = min;\n    res[1] = minIndex;\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi9cyj1tc.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpi9cyj1tc.__unittest_L57_C1()\
    \ [0x4280fe]\\n??:? void tmpi9cyj1tc.__modtest() [0x4284b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b67a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430905]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430891]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b651]\\n??:? runModuleUnitTests [0x42c5bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284c3]\\\
    n??:? __libc_start_main [0xb7129554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    bool hasEven = false;\n    foreach (i, v; arr)\n\
    \    {\n        if (v % 2 == 0)\n        {\n            hasEven = true;\n    \
    \        if (v < min)\n            {\n                min = v;\n             \
    \   minIndex = i;\n            }\n        }\n    }\n    if (hasEven)\n       \
    \ return [min, minIndex];\n    else\n        return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppsiw_rcn.d(68): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286d5]\\n??:? void tmppsiw_rcn.__unittest_L63_C1()\
    \ [0x428045]\\n??:? void tmppsiw_rcn.__modtest() [0x428458]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c733]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5c6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430759]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b59d]\\n??:? runModuleUnitTests [0x42c509]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b98]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b1f]\\n??:? _d_run_main [0x428a8a]\\n??:? main [0x42846b]\\\
    n??:? __libc_start_main [0x14dd8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = long.max;\n\
    \    long index = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0\
    \ && v < min)\n        {\n            min = v;\n            index = i;\n     \
    \   }\n    }\n    \n    if (index == -1)\n        return [];\n    \n    return\
    \ [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3mz52ha0.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp3mz52ha0.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp3mz52ha0.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x11706554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [];\n    long min = long.max;\n    long index = 0;\n    foreach(i,\
    \ e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n        {\n            min\
    \ = e;\n            index = i;\n        }\n    }\n    if(min != long.max)\n  \
    \  {\n        result ~= min;\n        result ~= index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 &&\
    \ v < min)\n        {\n            min = v;\n            index = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, index];\n    else\n      \
    \  return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpahy36duh.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpahy36duh.__unittest_L58_C1()\
    \ [0x428049]\\n??:? void tmpahy36duh.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd4747554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v <\
    \ min)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi5a03qnd.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpi5a03qnd.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpi5a03qnd.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xe47aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpehtqzh9c.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpehtqzh9c.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpehtqzh9c.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x2668d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4i1dwlkp.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp4i1dwlkp.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp4i1dwlkp.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x4f5fd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    bool hasEven = false;\n    foreach(i, val; arr)\n\
    \    {\n        if(val % 2 == 0)\n        {\n            hasEven = true;\n   \
    \         if(result[0] == 0 || val < result[0])\n            {\n             \
    \   result[0] = val;\n                result[1] = i;\n            }\n        }\n\
    \    }\n    if(!hasEven)\n        return [];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2gl2wmsb.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmp2gl2wmsb.__unittest_L58_C1()\
    \ [0x428194]\\n??:? void tmp2gl2wmsb.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0x62412554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long[] evens = arr.filter!(a\
    \ => a % 2 == 0).array;\n    if (evens.length == 0)\n        return [];\n    long\
    \ min = evens[0];\n    long index = 0;\n    for (long i = 1; i < evens.length;\
    \ i++)\n    {\n        if (evens[i] < min)\n        {\n            min = evens[i];\n\
    \            index = i;\n        }\n    }\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppzsxy9os.d(42): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppzsxy9os.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    int index = 0;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxa0yet2d.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpxa0yet2d.__unittest_L60_C1()\
    \ [0x4280b9]\\n??:? void tmpxa0yet2d.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0x5614e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpymamrk1o.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpymamrk1o.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpymamrk1o.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xc8b50554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnuzbv1o_.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpnuzbv1o_.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpnuzbv1o_.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x9ecb7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, val; arr)\n    {\n        if (val % 2 == 0 &&\
    \ val < min)\n        {\n            min = val;\n            minIndex = i;\n \
    \       }\n    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n   \
    \ return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpry0dz1z1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpry0dz1z1.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpry0dz1z1.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x12582554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long[] evens = arr.filter!(a => a %\
    \ 2 == 0).sort;\n    if (evens.length == 0) return [];\n    long smallest = evens[0];\n\
    \    long index = arr.indexOf(smallest);\n    return [smallest, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyt_0mrcf.d(41): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpyt_0mrcf.d(44): Error: no property `indexOf` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyt_0mrcf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_hmwofsv.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp_hmwofsv.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp_hmwofsv.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x1e496554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbr3rlxak.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpbr3rlxak.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpbr3rlxak.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd3a51554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvov_xmvx.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpvov_xmvx.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpvov_xmvx.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x55a7a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    bool found = false;\n   \
    \ for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            if (!found)\n            {\n                min = arr[i];\n\
    \                result[0] = min;\n                result[1] = i;\n          \
    \      found = true;\n            }\n            else\n            {\n       \
    \         if (arr[i] < min)\n                {\n                    min = arr[i];\n\
    \                    result[0] = min;\n                    result[1] = i;\n  \
    \              }\n            }\n        }\n    }\n    if (!found)\n    {\n  \
    \      return [];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = long.max;\n    long minIndex\
    \ = long.max;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            minIndex = i;\n        }\n    }\n\
    \    if(min != long.max)\n    {\n        result[0] = min;\n        result[1] =\
    \ minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc84_9job.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286d5]\\n??:? void tmpc84_9job.__unittest_L58_C1()\
    \ [0x4280a2]\\n??:? void tmpc84_9job.__modtest() [0x428454]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b622]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308ad]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430839]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f9]\\n??:? runModuleUnitTests [0x42c565]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b98]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b1f]\\n??:? _d_run_main [0x428a8a]\\n??:? main [0x428467]\\\
    n??:? __libc_start_main [0x4c98f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbo70v3vh.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpbo70v3vh.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpbo70v3vh.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xf35a5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppfg_76fi.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmppfg_76fi.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmppfg_76fi.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xa971e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzlwiaduf.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428725]\\n??:? void tmpzlwiaduf.__unittest_L56_C1()\
    \ [0x428091]\\n??:? void tmpzlwiaduf.__modtest() [0x4284a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c783]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b616]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430735]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ed]\\n??:? runModuleUnitTests [0x42c559]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428be8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b6f]\\n??:? _d_run_main [0x428ada]\\n??:? main [0x4284b7]\\\
    n??:? __libc_start_main [0x61e43554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = arr[0];\n    long index =\
    \ 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n   \
    \     {\n            min = e;\n            index = i;\n        }\n    }\n    if\
    \ (min % 2 == 0) return [min, index];\n    return [];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjsxniuap.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpjsxniuap.__unittest_L54_C1()\
    \ [0x428049]\\n??:? void tmpjsxniuap.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x4c640554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    bool\
    \ found = false;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0)\n    \
    \    {\n            if(!found)\n            {\n                min = e;\n    \
    \            index = i;\n                found = true;\n            }\n      \
    \      else\n            {\n                if(e < min)\n                {\n \
    \                   min = e;\n                    index = i;\n               \
    \ }\n            }\n        }\n    }\n    if(found)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1mff7z4z.d(77): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286f5]\\n??:? void tmp1mff7z4z.__unittest_L71_C1()\
    \ [0x4280c2]\\n??:? void tmp1mff7z4z.__modtest() [0x428474]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c753]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5bd]\\n??:? runModuleUnitTests [0x42c529]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b3f]\\n??:? _d_run_main [0x428aaa]\\n??:? main [0x428487]\\\
    n??:? __libc_start_main [0x624c2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v <\
    \ min)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8bwqcpkb.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp8bwqcpkb.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp8bwqcpkb.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xb7098554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] < min && arr[i] % 2 == 0)\n        {\n     \
    \       min = arr[i];\n            minIndex = i;\n        }\n    }\n    if (min\
    \ % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = minIndex;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxx9ag0ca.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpxx9ag0ca.__unittest_L60_C1()\
    \ [0x4280b9]\\n??:? void tmpxx9ag0ca.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0xc0027554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long minEven = arr[0];\n    long minEvenIndex = 0;\n    bool found = false;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            if (!found)\n            {\n                minEven =\
    \ arr[i];\n                minEvenIndex = i;\n                found = true;\n\
    \            }\n            else\n            {\n                if (arr[i] <\
    \ minEven)\n                {\n                    minEven = arr[i];\n       \
    \             minEvenIndex = i;\n                }\n            }\n        }\n\
    \    }\n    if (found)\n    {\n        result[0] = minEven;\n        result[1]\
    \ = minEvenIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmposy9qa_x.d(79): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428785]\\n??:? void tmposy9qa_x.__unittest_L73_C1()\
    \ [0x428156]\\n??:? void tmposy9qa_x.__modtest() [0x428508]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c83f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b6d2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43095d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430e0c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308e9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b6a9]\\n??:? runModuleUnitTests [0x42c615]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c48]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428bcf]\\n??:? _d_run_main [0x428b3a]\\n??:? main [0x42851b]\\\
    n??:? __libc_start_main [0x8779554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphcy2jc66.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmphcy2jc66.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmphcy2jc66.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x19e62554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = -1;\n    long index = -1;\n\
    \    foreach(i, v; arr)\n    {\n        if(v % 2 == 0)\n        {\n          \
    \  if(min == -1)\n            {\n                min = v;\n                index\
    \ = i;\n            }\n            else if(v < min)\n            {\n         \
    \       min = v;\n                index = i;\n            }\n        }\n    }\n\
    \    if(min == -1)\n    {\n        return result;\n    }\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp83senlbg.d(73): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286ed]\\n??:? void tmp83senlbg.__unittest_L67_C1()\
    \ [0x4280be]\\n??:? void tmp83senlbg.__modtest() [0x428470]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b63a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d74]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430851]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b611]\\n??:? runModuleUnitTests [0x42c57d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b37]\\n??:? _d_run_main [0x428aa2]\\n??:? main [0x428483]\\\
    n??:? __libc_start_main [0x6b049554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq7tjkz3z.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpq7tjkz3z.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpq7tjkz3z.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x6d029554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = long.max;\n\
    \    long minIndex = long.max;\n    foreach (i, v; arr)\n    {\n        if (v\
    \ % 2 == 0 && v < min)\n        {\n            min = v;\n            minIndex\
    \ = i;\n        }\n    }\n    \n    if (min == long.max)\n        return [];\n\
    \    \n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    bool\
    \ found = false;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0)\n    \
    \    {\n            if(!found)\n            {\n                min = v;\n    \
    \            index = i;\n                found = true;\n            }\n      \
    \      else\n            {\n                if(v < min)\n                {\n \
    \                   min = v;\n                    index = i;\n               \
    \ }\n            }\n        }\n    }\n    if(found)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpplfuq39x.d(77): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286f5]\\n??:? void tmpplfuq39x.__unittest_L71_C1()\
    \ [0x4280c2]\\n??:? void tmpplfuq39x.__modtest() [0x428474]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c753]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5bd]\\n??:? runModuleUnitTests [0x42c529]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b3f]\\n??:? _d_run_main [0x428aaa]\\n??:? main [0x428487]\\\
    n??:? __libc_start_main [0xa1220554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9didgks5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp9didgks5.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp9didgks5.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x8c6a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpji3ium6q.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpji3ium6q.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpji3ium6q.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xabc8e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] res = new long[2];\n    if (arr.length == 0)\n        return res;\n\
    \    long min = arr[0];\n    long minIndex = 0;\n    foreach (i, e; arr)\n   \
    \ {\n        if (e % 2 == 0 && e < min)\n        {\n            min = e;\n   \
    \         minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n    \
    \    res[0] = min;\n        res[1] = minIndex;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbr89fo51.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286fd]\\n??:? void tmpbr89fo51.__unittest_L60_C1()\
    \ [0x42806d]\\n??:? void tmpbr89fo51.__modtest() [0x428480]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7b7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b64a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d84]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430861]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b621]\\n??:? runModuleUnitTests [0x42c58d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bc0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b47]\\n??:? _d_run_main [0x428ab2]\\n??:? main [0x428493]\\\
    n??:? __libc_start_main [0x51105554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long smallestEven = 0;\n    long smallestIndex\
    \ = 0;\n    long index = 0;\n    bool isEven = false;\n    foreach(long element;\
    \ arr)\n    {\n        if(element % 2 == 0)\n        {\n            if(!isEven)\n\
    \            {\n                smallestEven = element;\n                smallestIndex\
    \ = index;\n                isEven = true;\n            }\n            else\n\
    \            {\n                if(element < smallestEven)\n                {\n\
    \                    smallestEven = element;\n                    smallestIndex\
    \ = index;\n                }\n            }\n        }\n        index++;\n  \
    \  }\n    if(isEven)\n    {\n        result[0] = smallestEven;\n        result[1]\
    \ = smallestIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxji892h2.d(79): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286f5]\\n??:? void tmpxji892h2.__unittest_L73_C1()\
    \ [0x4280c2]\\n??:? void tmpxji892h2.__modtest() [0x428474]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c753]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5bd]\\n??:? runModuleUnitTests [0x42c529]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bb8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b3f]\\n??:? _d_run_main [0x428aaa]\\n??:? main [0x428487]\\\
    n??:? __libc_start_main [0xf4435554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e <\
    \ min)\n        {\n            min = e;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv49v4o4a.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpv49v4o4a.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpv49v4o4a.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xaa487554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppv9x3ywv.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmppv9x3ywv.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmppv9x3ywv.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x21f5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ minIndex = -1;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v\
    \ < min)\n        {\n            min = v;\n            minIndex = i;\n       \
    \ }\n    }\n    if (minIndex == -1)\n        return [];\n    return [min, minIndex];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    long min = arr[0];\n    long index =\
    \ 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2\
    \ == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if (min % 2 == 0) return [min, index];\n    return\
    \ [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzswvh7f9.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpzswvh7f9.__unittest_L54_C1()\
    \ [0x428099]\\n??:? void tmpzswvh7f9.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xf1e34554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0L, 0L];\n    long min = long.max;\n    foreach(i, v; arr)\n\
    \    {\n        if(v % 2 == 0 && v < min)\n        {\n            min = v;\n \
    \           result[0] = v;\n            result[1] = i;\n        }\n    }\n   \
    \ if(min == long.max)\n        return [];\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4zp8hlgm.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp4zp8hlgm.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp4zp8hlgm.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xd2836554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return new long[0];\n    long[] result = new long[2];\n\
    \    long min = int.max;\n    foreach (i, v; arr)\n    {\n        if (v % 2 ==\
    \ 0 && v < min)\n        {\n            min = v;\n            result[0] = v;\n\
    \            result[1] = i;\n        }\n    }\n    if (min == int.max) return\
    \ new long[0];\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    long min = int.max;\n    long index = -1;\n\
    \    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n        {\n\
    \            min = e;\n            index = i;\n        }\n    }\n    if(index\
    \ == -1)\n        return [];\n    result[0] = min;\n    result[1] = index;\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9kxu1bk5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp9kxu1bk5.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp9kxu1bk5.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x8c6d0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [0, 0];\n    long min = 0;\n    long index = 0;\n    foreach(i,\
    \ e; arr)\n    {\n        if(e % 2 == 0)\n        {\n            if(min == 0)\n\
    \            {\n                min = e;\n                index = i;\n       \
    \     }\n            else if(e < min)\n            {\n                min = e;\n\
    \                index = i;\n            }\n        }\n    }\n    if(min != 0)\n\
    \    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkks6zua7.d(72): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286e5]\\n??:? void tmpkks6zua7.__unittest_L66_C1()\
    \ [0x4280b6]\\n??:? void tmpkks6zua7.__modtest() [0x428468]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c743]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5d6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430769]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c18]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5ad]\\n??:? runModuleUnitTests [0x42c519]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b2f]\\n??:? _d_run_main [0x428a9a]\\n??:? main [0x42847b]\\\
    n??:? __libc_start_main [0x47f72554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd__n2ixr.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpd__n2ixr.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpd__n2ixr.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x47686554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    bool found = false;\n    foreach (i, v; arr)\n  \
    \  {\n        if (v % 2 == 0)\n        {\n            if (!found)\n          \
    \  {\n                min = v;\n                minIndex = i;\n              \
    \  found = true;\n            }\n            else\n            {\n           \
    \     if (v < min)\n                {\n                    min = v;\n        \
    \            minIndex = i;\n                }\n            }\n        }\n    }\n\
    \    if (found)\n        return [min, minIndex];\n    else\n        return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ min_index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e\
    \ < min)\n        {\n            min = e;\n            min_index = i;\n      \
    \  }\n    }\n    if (min % 2 == 0)\n        return [min, min_index];\n    return\
    \ [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvxwtaxl1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpvxwtaxl1.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpvxwtaxl1.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x1e42f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = long.max;\n    long\
    \ minIndex = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (minIndex == -1)\n        return\
    \ [];\n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3s7lgmom.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp3s7lgmom.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp3s7lgmom.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x775aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0) return result;\n \
    \   long min = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpku4l98aq.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpku4l98aq.__unittest_L59_C1()\
    \ [0x4280bd]\\n??:? void tmpku4l98aq.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x23b5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ minIndex = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 && v <\
    \ min)\n        {\n            min = v;\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, minIndex];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp03uvq_w9.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmp03uvq_w9.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmp03uvq_w9.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0x2030a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp34jqpzg5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmp34jqpzg5.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmp34jqpzg5.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0xcaa74554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    long minEven = arr[0];\n    long minEvenIndex = 0;\n\
    \    bool foundEven = false;\n    \n    foreach (i, v; arr)\n    {\n        if\
    \ (v < min)\n        {\n            min = v;\n            minIndex = i;\n    \
    \    }\n        \n        if (v % 2 == 0)\n        {\n            if (!foundEven)\n\
    \            {\n                minEven = v;\n                minEvenIndex = i;\n\
    \                foundEven = true;\n            }\n            else if (v < minEven)\n\
    \            {\n                minEven = v;\n                minEvenIndex = i;\n\
    \            }\n        }\n    }\n    \n    if (foundEven)\n        return [minEven,\
    \ minEvenIndex];\n    else\n        return [min, minIndex];\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp79qsbkn0.d(89): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmp79qsbkn0.__unittest_L78_C1()\
    \ [0x42841a]\\n??:? void tmp79qsbkn0.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7ab]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b63e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43075d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b615]\\n??:? runModuleUnitTests [0x42c581]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0xcd2c4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = new long[2];\n    if (arr.length == 0)\n        return result;\n\
    \    long min = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] < min && arr[i] % 2 == 0)\n        {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqjxdzrf3.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpqjxdzrf3.__unittest_L60_C1()\
    \ [0x4280b9]\\n??:? void tmpqjxdzrf3.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0x8380554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] result = [long.max, long.max];\n    foreach(i, v; arr)\n    {\n  \
    \      if(v % 2 == 0 && v < result[0])\n        {\n            result[0] = v;\n\
    \            result[1] = i;\n        }\n    }\n    if(result[0] == long.max)\n\
    \        return [];\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n        return [min, index];\n\
    \    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt_9knh_0.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42872d]\\n??:? void tmpt_9knh_0.__unittest_L56_C1()\
    \ [0x428099]\\n??:? void tmpt_9knh_0.__modtest() [0x4284ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c78b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4307b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43073d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f5]\\n??:? runModuleUnitTests [0x42c561]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428bf0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b77]\\n??:? _d_run_main [0x428ae2]\\n??:? main [0x4284bf]\\\
    n??:? __libc_start_main [0x99e55554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return new long[0];\n    \n    long min = arr[0];\n\
    \    long minIndex = 0;\n    long minEven = long.max;\n    long minEvenIndex =\
    \ 0;\n    \n    foreach (i, v; arr)\n    {\n        if (v < min)\n        {\n\
    \            min = v;\n            minIndex = i;\n        }\n        \n      \
    \  if (v % 2 == 0 && v < minEven)\n        {\n            minEven = v;\n     \
    \       minEvenIndex = i;\n        }\n    }\n    \n    if (minEven == long.max)\n\
    \        return new long[0];\n    \n    return [minEven, minEvenIndex];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if (min % 2 == 0)\n        return [min, index];\n    return [];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj6k1p5em.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmpj6k1p5em.__unittest_L56_C1()\
    \ [0x428049]\\n??:? void tmpj6k1p5em.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c73b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5a5]\\n??:? runModuleUnitTests [0x42c511]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b27]\\n??:? _d_run_main [0x428a92]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xa6633554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
