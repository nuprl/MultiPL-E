name: HumanEval_132_is_nested
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkuquhalz.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpkuquhalz.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpkuquhalz.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x271ca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9pgywt5c.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp9pgywt5c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmz903xfe.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpmz903xfe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7682rgw8.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp7682rgw8.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp7682rgw8.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc1dec554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4y6eovvo.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp4y6eovvo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!(char)();\n    foreach(c; string)\n    {\n \
    \       if(c == '[')\n        {\n            stack.push(c);\n        }\n     \
    \   else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprb1x5vj3.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmprb1x5vj3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjr0zl6fs.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpjr0zl6fs.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpjr0zl6fs.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xecccb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n        if(count > 0)\n\
    \        {\n            is_nested = true;\n        }\n    }\n    return is_nested;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2efri1ey.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmp2efri1ey.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmp2efri1ey.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0xf8041554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa5x51a9n.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpa5x51a9n.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpa5x51a9n.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5c596554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnkxzcwx6.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpnkxzcwx6.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpnkxzcwx6.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc0422554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n        if(count > 0)\n\
    \        {\n            is_nested = true;\n        }\n    }\n    return is_nested;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_uz1klrq.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmp_uz1klrq.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmp_uz1klrq.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0x276a7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpndlo_l_y.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpndlo_l_y.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpndlo_l_y.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1fd20554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpunk1jbwv.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpunk1jbwv.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpunk1jbwv.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7f8c4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0cr9lrw7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp0cr9lrw7.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp0cr9lrw7.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1a73c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph_qyiue0.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmph_qyiue0.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmph_qyiue0.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9702b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprw10ruqx.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprw10ruqx.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprw10ruqx.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc64ce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    if(count >\
    \ 0)\n    {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc5pww4wb.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmpc5pww4wb.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmpc5pww4wb.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0xd65dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgr9ubtdc.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpgr9ubtdc.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpgr9ubtdc.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x831f8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiv4zoqvx.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpiv4zoqvx.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpiv4zoqvx.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xaf1e9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    if(count >\
    \ 0)\n    {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw50r1nd6.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmpw50r1nd6.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmpw50r1nd6.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0x4e3a4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk9kv9jcb.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpk9kv9jcb.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpk9kv9jcb.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa695f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptqbvv3bd.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmptqbvv3bd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaxju5qwo.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpaxju5qwo.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpaxju5qwo.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x45b8d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjovhbgh1.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpjovhbgh1.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpjovhbgh1.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xf3b1b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpll84yc2h.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpll84yc2h.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpll84yc2h.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x57f2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj4oqz10x.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpj4oqz10x.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpj4oqz10x.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9ec0d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_phkenoc.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp_phkenoc.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp_phkenoc.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7afcf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsuo5s8wt.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpsuo5s8wt.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpsuo5s8wt.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9087b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9me76ihs.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp9me76ihs.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp9me76ihs.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4c088554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7vh1sv17.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp7vh1sv17.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp7vh1sv17.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x454e1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzme2iw9c.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpzme2iw9c.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpzme2iw9c.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x48643554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4y952ssa.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp4y952ssa.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp4y952ssa.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7b6e3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppfob4r8p.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmppfob4r8p.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmppfob4r8p.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x92148554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpztxwak_a.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpztxwak_a.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpztxwak_a.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x187a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4oslsjxk.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp4oslsjxk.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp4oslsjxk.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xde9da554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp01bo67_j.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp01bo67_j.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp01bo67_j.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa728f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpesscls4c.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpesscls4c.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpesscls4c.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc0ea4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1bvu6v98.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1bvu6v98.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp1bvu6v98.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xfbbd6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqn6230xf.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpqn6230xf.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmpqn6230xf.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x37638554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n\
    \            count++;\n        else if(ch == ']')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsfghmaep.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpsfghmaep.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpsfghmaep.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4c2f9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd98hwhku.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpd98hwhku.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpd98hwhku.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7608554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw8ro8ter.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpw8ro8ter.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpw8ro8ter.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x70626554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // create a stack of chars\n    Stack!char stack;\n    // loop through\
    \ the string\n    foreach(char c; string)\n    {\n        // if the char is an\
    \ opening bracket, push it to the stack\n        if(c == '[')\n            stack.push(c);\n\
    \        // if the char is a closing bracket, pop the stack\n        else if(c\
    \ == ']')\n            stack.pop();\n    }\n    // if the stack is empty, there\
    \ is a valid subsequence\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp786pgknb.d(20): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp786pgknb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8dlq414h.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8dlq414h.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8dlq414h.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x97131554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8csmwhir.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8csmwhir.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8csmwhir.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x159bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxdp54vdt.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpxdp54vdt.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpxdp54vdt.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x35430554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9op0yyco.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp9op0yyco.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp9op0yyco.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x864db554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; string)\n    {\n        if(i == '[')\n\
    \            count++;\n        else if(i == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd7gyz1fj.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpd7gyz1fj.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpd7gyz1fj.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x42a20554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe3rwfv35.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpe3rwfv35.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpe3rwfv35.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xb09c5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt_ge0w3i.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpt_ge0w3i.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpt_ge0w3i.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd4271554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj0q3q5x_.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpj0q3q5x_.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpj0q3q5x_.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xbf5bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp392w2cxr.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp392w2cxr.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmp392w2cxr.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xcd4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpam705ez2.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpam705ez2.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpam705ez2.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xcf3c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz_y4ovz4.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpz_y4ovz4.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpz_y4ovz4.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xca43e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjwcsvuyi.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpjwcsvuyi.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpjwcsvuyi.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xfe817554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptkq1c3ze.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmptkq1c3ze.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmptkq1c3ze.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x63b29554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpby4pga8k.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpby4pga8k.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpby4pga8k.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xdc9b0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjj1igjlf.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpjj1igjlf.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpjj1igjlf.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x49149554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuel60ij5.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpuel60ij5.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpuel60ij5.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x6f6f8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n    {\n   \
    \     if(c == '[')\n        {\n            stack.push(c);\n        }\n       \
    \ else if(c == ']')\n        {\n            if(stack.empty)\n            {\n \
    \               return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzqhvv_rq.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpzqhvv_rq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp026n47oe.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp026n47oe.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp026n47oe.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x764b0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp66b1fnca.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp66b1fnca.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp66b1fnca.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x20ede554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // create a stack to hold the brackets\n    Stack!char stack;\n   \
    \ // iterate through the string\n    foreach(char c; string)\n    {\n        //\
    \ if the char is a left bracket, push it to the stack\n        if(c == '[')\n\
    \            stack.push(c);\n        // if the char is a right bracket, pop the\
    \ stack\n        else if(c == ']')\n            stack.pop();\n    }\n    // if\
    \ the stack is empty, return true\n    if(stack.empty)\n        return true;\n\
    \    // otherwise return false\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvpyum2oo.d(20): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpvpyum2oo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxhr9defx.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpxhr9defx.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpxhr9defx.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9ada0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi6b9qzxz.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpi6b9qzxz.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpi6b9qzxz.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5980a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7ahy55w3.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp7ahy55w3.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp7ahy55w3.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xaf0e7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n\
    \            count++;\n        else if(ch == ']')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb_ovh5ob.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpb_ovh5ob.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpb_ovh5ob.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xb9fad554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n\
    \        if(string[i] == '[')\n        {\n            count++;\n        }\n  \
    \      else if(string[i] == ']')\n        {\n            count--;\n        }\n\
    \        if(count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpirqmvlu8.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmpirqmvlu8.__unittest_L37_C1()\
    \ [0x427b1c]\\n??:? void tmpirqmvlu8.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0xbd91a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi_3_1d6h.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpi_3_1d6h.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpi_3_1d6h.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5c1dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg52182qp.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpg52182qp.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpg52182qp.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc5ef5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    if(string.length < 2)\n        return false;\n    else if(string.length\
    \ == 2)\n        return true;\n    \n    int count = 0;\n    for(int i = 0; i\
    \ < string.length; i++)\n    {\n        if(string[i] == '[')\n            count++;\n\
    \        else if(string[i] == ']')\n            count--;\n        if(count < 0)\n\
    \            return false;\n    }\n    return count == 0;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplnsqr90h.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f8d]\\n??:? void tmplnsqr90h.__unittest_L36_C1()\
    \ [0x427b38]\\n??:? void tmplnsqr90h.__modtest() [0x427d0c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd27]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd4d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301fc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcd9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab91]\\n??:? runModuleUnitTests [0x42bafd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428450]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283d7]\\n??:? _d_run_main [0x428342]\\n??:? main [0x427d1f]\\\
    n??:? __libc_start_main [0xfda92554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    if(count >\
    \ 0)\n    {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd3t4dyst.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmpd3t4dyst.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmpd3t4dyst.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0xeab06554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8s2vnotr.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8s2vnotr.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8s2vnotr.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5c7e4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfxtsd4qy.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpfxtsd4qy.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpfxtsd4qy.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd8dbd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1yrvf9z3.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1yrvf9z3.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp1yrvf9z3.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xac8b6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe1qf2aa6.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpe1qf2aa6.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpe1qf2aa6.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xab517554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; string)\n    {\n        if(i == '[')\n\
    \            count++;\n        else if(i == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphf5wbjut.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmphf5wbjut.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmphf5wbjut.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9a89d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpytoc1mdl.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpytoc1mdl.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpytoc1mdl.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x3bf68554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; string)\n    {\n        if(i == '[')\n\
    \            count++;\n        else if(i == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpphdsgai9.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpphdsgai9.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpphdsgai9.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x2a128554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprcmv_7rb.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprcmv_7rb.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprcmv_7rb.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5690b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2p70e2fr.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp2p70e2fr.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp2p70e2fr.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x39695554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl3101jio.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpl3101jio.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpl3101jio.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd4b36554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx8scpo52.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpx8scpo52.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmpx8scpo52.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x65625554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n\
    \            count++;\n        else if(ch == ']')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7syxsmv6.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp7syxsmv6.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp7syxsmv6.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x3ab61554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbemsbwq7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpbemsbwq7.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpbemsbwq7.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9a053554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n\
    \        if(string[i] == '[')\n        {\n            count++;\n        }\n  \
    \      else if(string[i] == ']')\n        {\n            count--;\n        }\n\
    \        if(count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0b41u_x2.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmp0b41u_x2.__unittest_L37_C1()\
    \ [0x427b1c]\\n??:? void tmp0b41u_x2.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0x83f21554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt5gz6cvw.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpt5gz6cvw.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpt5gz6cvw.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5da7e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzvukm_az.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpzvukm_az.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpzvukm_az.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x743c7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n    {\n   \
    \     if(c == '[')\n        {\n            stack.push(c);\n        }\n       \
    \ else if(c == ']')\n        {\n            if(stack.empty)\n            {\n \
    \               return false;\n            }\n            stack.pop();\n     \
    \   }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplmvn8xql.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmplmvn8xql.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpduo72_v4.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpduo72_v4.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpduo72_v4.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4fe39554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp37_wwn2o.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp37_wwn2o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n\
    \        if(string[i] == '[')\n        {\n            count++;\n        }\n  \
    \      else if(string[i] == ']')\n        {\n            count--;\n        }\n\
    \        if(count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5iylcwwz.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmp5iylcwwz.__unittest_L37_C1()\
    \ [0x427b1c]\\n??:? void tmp5iylcwwz.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0x30db2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n\
    \        if(string[i] == '[')\n        {\n            count++;\n        }\n  \
    \      else if(string[i] == ']')\n        {\n            count--;\n        }\n\
    \        if(count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps5kr9hy3.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmps5kr9hy3.__unittest_L37_C1()\
    \ [0x427b1c]\\n??:? void tmps5kr9hy3.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0xf5100554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8okx3a3f.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8okx3a3f.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8okx3a3f.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xae010554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp481jy0gu.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp481jy0gu.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp481jy0gu.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4d71b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprxqpgcpt.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprxqpgcpt.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprxqpgcpt.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa50cf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbo350y97.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpbo350y97.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpbo350y97.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4e11a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvzrtftcd.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpvzrtftcd.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpvzrtftcd.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4ac07554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n\
    \            count++;\n        else if(ch == ']')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpen406vds.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpen406vds.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpen406vds.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x74599554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsmozni16.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpsmozni16.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpsmozni16.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x41137554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int open = 0;\n    int close = 0;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n            open++;\n        else if(c == ']')\n      \
    \      close++;\n        if(open < close)\n            return false;\n    }\n\
    \    return open == close;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1lv2lk7p.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1lv2lk7p.__unittest_L32_C1()\
    \ [0x427afc]\\n??:? void tmp1lv2lk7p.__modtest() [0x427cd0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427ce3]\\\
    n??:? __libc_start_main [0x8bc67554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n\
    \            open_brackets++;\n        }\n        else if(c == ']')\n        {\n\
    \            close_brackets++;\n        }\n    }\n    if(open_brackets > 0 &&\
    \ close_brackets > 0)\n    {\n        if(open_brackets == close_brackets)\n  \
    \      {\n            is_nested = false;\n        }\n        else\n        {\n\
    \            is_nested = true;\n        }\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt2zg4me9.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f5d]\\n??:? void tmpt2zg4me9.__unittest_L46_C1()\
    \ [0x427ab6]\\n??:? void tmpt2zg4me9.__modtest() [0x427cdc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430158]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aaed]\\n??:? runModuleUnitTests [0x42ba59]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428333]\\n??:? _d_run_main [0x42829e]\\n??:? main [0x427cef]\\\
    n??:? __libc_start_main [0x5e2d3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa9ige07x.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpa9ige07x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzlmq0jh_.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpzlmq0jh_.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpzlmq0jh_.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1118a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkh7nokm3.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpkh7nokm3.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpkh7nokm3.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xe8bab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpal7t4c14.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpal7t4c14.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpal7t4c14.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd32e7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmpo4sgta.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpmpo4sgta.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpmpo4sgta.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x2d695554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int open_brackets = 0;\n    int closed_brackets\
    \ = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n\
    \            open_brackets++;\n        }\n        else if(c == ']')\n        {\n\
    \            closed_brackets++;\n        }\n    }\n    if(open_brackets > closed_brackets)\n\
    \    {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwch12hua.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpwch12hua.__unittest_L39_C1()\
    \ [0x427aa6]\\n??:? void tmpwch12hua.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x35e41554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpye5et_k7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpye5et_k7.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpye5et_k7.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xbc6bb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphhr13ix8.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmphhr13ix8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppbq46t60.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmppbq46t60.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmppbq46t60.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x2da44554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk0j_gpr_.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpk0j_gpr_.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpk0j_gpr_.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd95be554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppn10rkft.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmppn10rkft.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmppn10rkft.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc7a31554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    return string.count('[') == string.count(']');\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxrp4m655.d(19): Error: no property `count` for type `string`\\\
    n/tmp/tmpxrp4m655.d(19): Error: no property `count` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxrp4m655.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n\
    \            open_brackets++;\n        }\n        else if(c == ']')\n        {\n\
    \            close_brackets++;\n        }\n    }\n    if(open_brackets > close_brackets)\n\
    \    {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcxck0tio.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpcxck0tio.__unittest_L39_C1()\
    \ [0x427aa6]\\n??:? void tmpcxck0tio.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x273e0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1cd6tet_.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1cd6tet_.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmp1cd6tet_.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x8b4ae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_69x9v2j.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp_69x9v2j.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp_69x9v2j.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xe3541554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprbdso1ir.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprbdso1ir.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprbdso1ir.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xff7cc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    if(count >\
    \ 0)\n    {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq8j4ahwv.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmpq8j4ahwv.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmpq8j4ahwv.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0x7d6e2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpte2kmnmy.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpte2kmnmy.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpte2kmnmy.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x15864554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpew56qn1s.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpew56qn1s.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpew56qn1s.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x151c2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt7lp1uef.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpt7lp1uef.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpt7lp1uef.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x58fc5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwc07nhzc.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpwc07nhzc.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpwc07nhzc.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd909d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpacsdz1hy.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpacsdz1hy.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpacsdz1hy.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa33a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp39v6yq_d.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp39v6yq_d.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp39v6yq_d.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xf1370554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpklf4_02g.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpklf4_02g.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpklf4_02g.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xe3b4f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg7uuubm0.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpg7uuubm0.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpg7uuubm0.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x17de0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n        if(count > 0)\n\
    \        {\n            is_nested = true;\n        }\n    }\n    return is_nested;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1gcfu547.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmp1gcfu547.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmp1gcfu547.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0x33fd0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnssj2i3g.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpnssj2i3g.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpnssj2i3g.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1cf84554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(ch; string)\n    {\n    \
    \    if(ch == '[')\n        {\n            stack.push(ch);\n        }\n      \
    \  else if(ch == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfddasmft.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpfddasmft.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp_pcztt1.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpp_pcztt1.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpp_pcztt1.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd3760554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4l96h9w9.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp4l96h9w9.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp4l96h9w9.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x6164c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1ge15gmt.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1ge15gmt.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp1ge15gmt.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x6845c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi0vlkddb.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpi0vlkddb.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpi0vlkddb.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x3ad7f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n    {\n   \
    \     if(c == '[')\n        {\n            stack.push(c);\n        }\n       \
    \ else if(c == ']')\n        {\n            if(stack.empty)\n            {\n \
    \               return false;\n            }\n            stack.pop();\n     \
    \   }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9jm0ahf2.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp9jm0ahf2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n    {\n   \
    \     if(c == '[')\n        {\n            stack.push(c);\n        }\n       \
    \ else if(c == ']')\n        {\n            if(stack.empty)\n            {\n \
    \               return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5emb16bg.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp5emb16bg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; 0 .. string.length)\n    {\n       \
    \ if(string[i] == '[')\n        {\n            count++;\n        }\n        else\
    \ if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpalccpx7h.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f7d]\\n??:? void tmpalccpx7h.__unittest_L37_C1()\
    \ [0x427b2c]\\n??:? void tmpalccpx7h.__modtest() [0x427d00]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd17]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abaa]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd3d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301ec]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcc9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab81]\\n??:? runModuleUnitTests [0x42baed]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428440]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283c7]\\n??:? _d_run_main [0x428332]\\n??:? main [0x427d13]\\\
    n??:? __libc_start_main [0xf15fd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp25th91ca.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp25th91ca.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9m_ha9bo.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp9m_ha9bo.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp9m_ha9bo.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x4efc6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw2u77x53.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpw2u77x53.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpw2u77x53.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xbf5fb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7gr5pj4r.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp7gr5pj4r.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp7gr5pj4r.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xe163b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    if(count >\
    \ 0)\n    {\n        return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7mqvtg_d.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmp7mqvtg_d.__unittest_L42_C1()\
    \ [0x427b00]\\n??:? void tmp7mqvtg_d.__modtest() [0x427cd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ce7]\\\
    n??:? __libc_start_main [0x4bd7e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp__32joye.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp__32joye.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp__32joye.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x64fde554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsmyn5f5a.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpsmyn5f5a.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpsmyn5f5a.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9b6fe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    string[] brackets = [\"[]\", \"[[]]\", \"[[[]]]\", \"[[[[]]]]\", \"\
    [[[[[]]]]]\", \"[[[[[[]]]]]]\"];\n    foreach(string bracket; brackets)\n    {\n\
    \        if(string.contains(bracket))\n        {\n            return true;\n \
    \       }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3kx0ydx.d(19): Error: `string` is used as a type\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3kx0ydx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptjot437m.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmptjot437m.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmptjot437m.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x93f88554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe4x6b9dr.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpe4x6b9dr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb4b06uej.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpb4b06uej.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpb4b06uej.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x381dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1rs4iico.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp1rs4iico.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp1rs4iico.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x6e529554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0vd33jyn.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp0vd33jyn.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp0vd33jyn.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xae791554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpum00x1y_.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpum00x1y_.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpum00x1y_.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x11b2d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzkshl_q5.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpzkshl_q5.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpzkshl_q5.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x8d7d8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplupmepy5.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmplupmepy5.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmplupmepy5.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5d44f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; string)\n    {\n        if(i == '[')\n\
    \            count++;\n        else if(i == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprpnvb2u5.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprpnvb2u5.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprpnvb2u5.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xd7d3a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0uaox1i7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp0uaox1i7.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp0uaox1i7.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x22e52554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxav0br12.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpxav0br12.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpxav0br12.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa5792554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnma2c16k.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpnma2c16k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk9p5090g.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpk9p5090g.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpk9p5090g.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x38d8b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprqr3mzr6.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmprqr3mzr6.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmprqr3mzr6.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x54821554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int open = 0;\n    int close = 0;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n            open++;\n        else if(c == ']')\n      \
    \      close++;\n    }\n    return open == close;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp35x755j.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f3d]\\n??:? void tmpp35x755j.__unittest_L30_C1()\
    \ [0x427aec]\\n??:? void tmpp35x755j.__modtest() [0x427cc0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc63]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aaf6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc89]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430138]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc15]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aacd]\\n??:? runModuleUnitTests [0x42ba39]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42838c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428313]\\n??:? _d_run_main [0x42827e]\\n??:? main [0x427cd3]\\\
    n??:? __libc_start_main [0xcb1c6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt7rgi27p.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpt7rgi27p.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpt7rgi27p.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xad083554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2iv1ib01.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp2iv1ib01.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfi5jvc4t.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpfi5jvc4t.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpfi5jvc4t.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x995e5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf0nmfns7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpf0nmfns7.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpf0nmfns7.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x8a73e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3ou35ujq.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp3ou35ujq.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp3ou35ujq.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xb9742554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbce40we1.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpbce40we1.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpbce40we1.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x88980554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    string open = \"[\";\n    string close = \"]\";\n    int open_count\
    \ = 0;\n    int close_count = 0;\n    bool nested = false;\n    foreach(char c;\
    \ string)\n    {\n        if(c == open[0])\n        {\n            open_count++;\n\
    \        }\n        else if(c == close[0])\n        {\n            close_count++;\n\
    \        }\n    }\n    if(open_count > close_count)\n    {\n        nested = true;\n\
    \    }\n    return nested;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzrdm_qjb.d(19): Error: `string` is used as a type\\n/tmp/tmpzrdm_qjb.d(20):\
    \ Error: `string` is used as a type\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzrdm_qjb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps_06_qqk.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmps_06_qqk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi4t376az.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpi4t376az.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpi4t376az.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xa00b8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp68zulbxv.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp68zulbxv.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp68zulbxv.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x9494d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(i, c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplj27awfp.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmplj27awfp.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmplj27awfp.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x8857a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(i; string)\n    {\n        if(i == '[')\n\
    \            count++;\n        else if(i == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj7tcccxq.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpj7tcccxq.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpj7tcccxq.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x8f660554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfxpie5jq.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpfxpie5jq.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpfxpie5jq.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7268d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplx7wh55b.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmplx7wh55b.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmplx7wh55b.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x35e33554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcu_gsjit.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpcu_gsjit.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpcu_gsjit.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x30f05554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1qpy9jpn.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp1qpy9jpn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdy49jo0c.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpdy49jo0c.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpdy49jo0c.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x424c3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkx6re7ep.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpkx6re7ep.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpkx6re7ep.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1e3eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n\
    \        if(string[i] == '[')\n        {\n            count++;\n        }\n  \
    \      else if(string[i] == ']')\n        {\n            count--;\n        }\n\
    \        if(count < 0)\n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqwsl2lzm.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f6d]\\n??:? void tmpqwsl2lzm.__unittest_L37_C1()\
    \ [0x427b1c]\\n??:? void tmpqwsl2lzm.__modtest() [0x427cf0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab71]\\n??:? runModuleUnitTests [0x42badd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428430]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283b7]\\n??:? _d_run_main [0x428322]\\n??:? main [0x427d03]\\\
    n??:? __libc_start_main [0xb0354554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv39f9xy1.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpv39f9xy1.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpv39f9xy1.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x5d03a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch == '[')\n\
    \            count++;\n        else if(ch == ']')\n            count--;\n    \
    \    if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8mhi63f0.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8mhi63f0.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8mhi63f0.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xc8d66554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnrwtao5y.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpnrwtao5y.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpnrwtao5y.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x3cc18554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count > 0)\n \
    \   {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb93uriw6.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpb93uriw6.__unittest_L42_C1()\
    \ [0x427aa6]\\n??:? void tmpb93uriw6.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x76c56554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8u02fq6e.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8u02fq6e.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8u02fq6e.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x6df11554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8y1cvsw1.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp8y1cvsw1.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp8y1cvsw1.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x3989b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool is_nested = false;\n    int open_brackets = 0;\n    int closed_brackets\
    \ = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n\
    \            open_brackets++;\n        }\n        else if(c == ']')\n        {\n\
    \            closed_brackets++;\n        }\n    }\n    if(open_brackets > closed_brackets)\n\
    \    {\n        is_nested = true;\n    }\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf5zccsf2.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpf5zccsf2.__unittest_L39_C1()\
    \ [0x427aa6]\\n??:? void tmpf5zccsf2.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x2ac37554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyufyqb1o.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpyufyqb1o.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpyufyqb1o.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x48412554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyffaebyy.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpyffaebyy.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpyffaebyy.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7d83b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqxaeyzyq.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpqxaeyzyq.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpqxaeyzyq.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xf94e7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbthjo47c.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpbthjo47c.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpbthjo47c.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x698d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3275vnjn.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp3275vnjn.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp3275vnjn.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xac715554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpn_hc8gxv.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpn_hc8gxv.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpn_hc8gxv.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xf8008554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3swm7cl0.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp3swm7cl0.__unittest_L42_C1()\
    \ [0x427af8]\\n??:? void tmp3swm7cl0.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x863fd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            else\n            {\n   \
    \             stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy0h0uk1v.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpy0h0uk1v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            stack.push(c);\n        }\n        else\
    \ if(c == ']')\n        {\n            if(stack.empty)\n            {\n      \
    \          return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm6gdsdvc.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpm6gdsdvc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = Stack!char();\n    foreach(c; string)\n    {\n       \
    \ if(c == '[')\n            stack.push(c);\n        else if(c == ']')\n      \
    \  {\n            if(stack.empty)\n                return false;\n           \
    \ else\n                stack.pop();\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptuso9kkt.d(19): Error: template instance `Stack!char` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmptuso9kkt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp86uy_jlj.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmp86uy_jlj.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmp86uy_jlj.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x2573e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n        if(c ==\
    \ '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg11s5fic.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpg11s5fic.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpg11s5fic.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0xb6140554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkm99b9yt.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpkm99b9yt.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpkm99b9yt.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x1730f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n\
    \            count++;\n        else if(c == ']')\n            count--;\n     \
    \   if(count < 0)\n            return false;\n    }\n    return count == 0;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg_m7yrig.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f4d]\\n??:? void tmpg_m7yrig.__unittest_L31_C1()\
    \ [0x427af8]\\n??:? void tmpg_m7yrig.__modtest() [0x427ccc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aadd]\\n??:? runModuleUnitTests [0x42ba49]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42839c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428323]\\n??:? _d_run_main [0x42828e]\\n??:? main [0x427cdf]\\\
    n??:? __libc_start_main [0x7dfe9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
