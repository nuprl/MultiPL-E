name: HumanEval_116_sort_array
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int a_ones = a.countOnes();\n        int b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw8vshv4c.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw8vshv4c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfwdy8_b5.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfwdy8_b5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfdy_n4g5.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfdy_n4g5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes\
    \ == b.countOnes && a > b));\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw0k43xa6.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0k43xa6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        if (a == b) return 0;\n        if (a < 0) return -1;\n    \
    \    if (b < 0) return 1;\n        int aOnes = countOnes(a);\n        int bOnes\
    \ = countOnes(b);\n        if (aOnes == bOnes) return a < b ? -1 : 1;\n      \
    \  return aOnes < bOnes ? -1 : 1;\n    });\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp68u38yrz.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp68u38yrz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aCount = countOnes(a);\n        int bCount = countOnes(b);\n\
    \        return aCount == bCount ? a.compare(b) : aCount.compare(bCount);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ssatc__.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ssatc__.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq9dye4d9.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq9dye4d9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzqbk7z0o.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzqbk7z0o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = new long[arr.length];\n    long[] ones = new long[arr.length];\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        ones[i] = arr[i] == 0 ? 0 : countOnes(arr[i]);\n\
    \    }\n    long[] sorted = sort(ones);\n    long[] sorted_arr = sort(arr);\n\
    \    int index = 0;\n    for (int i = 0; i < sorted.length; i++)\n    {\n    \
    \    for (int j = 0; j < sorted_arr.length; j++)\n        {\n            if (sorted[i]\
    \ == countOnes(sorted_arr[j]))\n            {\n                result[index] =\
    \ sorted_arr[j];\n                index++;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4t657m_e.d(21): Error: undefined identifier `countOnes`\\n/tmp/tmp4t657m_e.d(23):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmp4t657m_e.d(24):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmp4t657m_e.d(30):\
    \ Error: undefined identifier `countOnes`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp4t657m_e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(x => tuple(x, countOnes(x)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5782wvuu.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5782wvuu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a.compare(b) : aOnes.compare(bOnes);\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8eusgquc.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8eusgquc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8go8eeps.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8go8eeps.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmporaysrxd.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmporaysrxd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a.compare(b) : aOnes.compare(bOnes);\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2bia2rh2.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bia2rh2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuvf9eu8o.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvf9eu8o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones\
    \ > b_ones ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdff23pr4.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdff23pr4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] ret = arr.dup;\n\
    \    ret.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a <\
    \ b;\n        return a_ones < b_ones;\n    });\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplndatrlv.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplndatrlv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1qdkrw3g.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1qdkrw3g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_1kgylid.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1kgylid.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_i8tqap.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_i8tqap.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count('1');\n\
    \        auto b1 = b.to!string.count('1');\n        return a1 < b1 ? -1 : a1 >\
    \ b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj_q9q22z.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj_q9q22z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto b1\
    \ = b.countOnes;\n        if (a1 == b1)\n            return a - b;\n        return\
    \ a1 - b1;\n    });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpouqdcol9.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpouqdcol9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a1 = a.countOnes();\n        int b1 = b.countOnes();\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi_dy0i9o.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi_dy0i9o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => countOnes(a) == countOnes(b) ? a < b : countOnes(a)\
    \ < countOnes(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl7qeq9a6.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl7qeq9a6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcsyjevlz.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcsyjevlz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0k5w2132.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0k5w2132.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) {\n        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnid522wb.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnid522wb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        if (a2 == b2)\n            return a < b;\n        return a2 < b2;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr_chn_ad.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_chn_ad.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd6rn2lm_.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6rn2lm_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6kssdi06.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6kssdi06.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort!((a, b) => (a.countOnes, a) < (b.countOnes, b))(sorted);\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_3kzrej.d(18): Error: template instance `sort!((a, b) => (a.countOnes\
    \ , a) < (b.countOnes , b))` template `sort` is not defined, did you mean sqrt?\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_3kzrej.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp52a4yinx.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52a4yinx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) => countOnes(a) < countOnes(b) || (countOnes(a)\
    \ == countOnes(b) && a < b));\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpugwaf9pn.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpugwaf9pn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_with_ones.map!(a => a[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0tf2g1jn.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0tf2g1jn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sort_by_ones\
    \ = (a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    };\n    return arr.sort!sort_by_ones;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_00_7s_.d(17): Error: variable `tmpp_00_7s_.sort_array.sort_by_ones`\
    \ type `void` is inferred from initializer `(a, b) => ()\\n{\\nauto a_ones = a.countOnes;\\\
    nauto b_ones = b.countOnes;\\nreturn a_ones == b_ones ? a - b : a_ones - b_ones;\\\
    n}\\n`, and variables cannot be of type `void`\\n/tmp/tmpp_00_7s_.d(17): Error:\
    \ template lambda has no value\\n/tmp/tmpp_00_7s_.d(23): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_00_7s_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2).count('1');\n\
    \        auto b1 = b.to!string(2).count('1');\n        if (a1 == b1)\n       \
    \     return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplczu5yez.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplczu5yez.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        if (a2 == b2)\n            return a < b;\n        return a2 < b2;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcbrwl3ud.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcbrwl3ud.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ones\
    \ = arr.map!(x => tuple(x, x.countOnes)).array;\n    arr_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_ones.map!(x =>\
    \ x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeb4fxnod.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeb4fxnod.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        return a2 == b2 ? a < b : a2 < b2;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpekagpr4e.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekagpr4e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        long a1 = a.countOnes;\n        long b1 = b.countOnes;\n\
    \        return a1 < b1 ? -1 : a1 > b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n   \
    \ });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmr43j4j2.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmr43j4j2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count(\"1\");\n\
    \        auto b1 = b.to!string.count(\"1\");\n        return a1 == b1 ? a.compare(b)\
    \ : a1.compare(b1);\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcfsx2b7w.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcfsx2b7w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplyx0036t.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplyx0036t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        long aOnes = a.countOnes();\n        long bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a.compare(b) : aOnes.compare(bOnes);\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx8vryb5u.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx8vryb5u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwd_3oxwf.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwd_3oxwf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyk7i89q8.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyk7i89q8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto result =\
    \ arr.dup;\n    result.sort!((a, b) => countOnes(a) < countOnes(b) || (countOnes(a)\
    \ == countOnes(b) && a < b));\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc2i9upwl.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc2i9upwl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpinxo30dj.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpinxo30dj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort!((a, b) =>\n    {\n        int aOnes = countOnes(a);\n\
    \        int bOnes = countOnes(b);\n        if (aOnes == bOnes)\n            return\
    \ a - b;\n        return aOnes - bOnes;\n    })(sorted);\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv4l5us4f.d(18): Error: template instance `sort!((a, b) => ()\\\
    n{\\nint aOnes = countOnes(a);\\nint bOnes = countOnes(b);\\nif (aOnes == bOnes)\\\
    nreturn a - b;\\nreturn aOnes - bOnes;\\n}\\n)` template `sort` is not defined,\
    \ did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4l5us4f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = arr.dup;\n    result.sort!((a, b) => (a.countOnes == b.countOnes) ? a - b\
    \ : a.countOnes - b.countOnes);\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp04ddjmu5.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04ddjmu5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx4k1o83y.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx4k1o83y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpms87jnto.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpms87jnto.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    auto arr3 = arr.dup;\n    auto arr4 = arr.dup;\n    auto arr5 = arr.dup;\n\
    \    auto arr6 = arr.dup;\n    auto arr7 = arr.dup;\n    auto arr8 = arr.dup;\n\
    \    auto arr9 = arr.dup;\n    auto arr10 = arr.dup;\n    auto arr11 = arr.dup;\n\
    \    auto arr12 = arr.dup;\n    auto arr13 = arr.dup;\n    auto arr14 = arr.dup;\n\
    \    auto arr15 = arr.dup;\n    auto arr16 = arr.dup;\n    auto arr17 = arr.dup;\n\
    \    auto arr18 = arr.dup;\n    auto arr19 = arr.dup;\n    auto arr20 = arr.dup;\n\
    \    auto arr21 = arr.dup;\n    auto arr22 = arr.dup;\n    auto arr23 = arr.dup;\n\
    \    auto arr24 = arr.dup;\n    auto arr25 = arr.dup;\n    auto arr26 = arr.dup;\n\
    \    auto arr27 = arr.dup;\n    auto arr28 = arr.dup;\n    auto arr29 = arr.dup;\n\
    \    auto arr30 = arr.dup;\n    auto arr31 = arr.dup;\n    auto arr32 = arr.dup;\n\
    \    auto arr33 = arr.dup;\n    auto arr34 = arr.dup;\n    auto arr35 = arr.dup;\n\
    \    auto arr36 = arr.dup;\n    auto arr37 = arr.dup;\n    auto arr38 = arr.dup;\n\
    \    auto arr39 = arr.dup;\n    auto arr40 = arr.dup;\n    auto arr41 = arr.dup;\n\
    \    auto arr42 = arr.dup;\n    auto arr43 = arr.dup;\n    auto arr44 = arr.dup;\n\
    \    auto arr45 = arr.dup;\n    auto arr46 = arr.dup;\n    auto arr47 = arr.dup;\n\
    \    auto arr\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pse7km0.d(64): Error: no identifier for declarator `arr`\\n/tmp/tmp5pse7km0.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5pse7km0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt_mviw51.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt_mviw51.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        if (a.countOnes == b.countOnes)\n            return a.compare(b);\n\
    \        return a.countOnes.compare(b.countOnes);\n    });\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv0tiijxi.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv0tiijxi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        if (a.countOnes == b.countOnes)\n            return a\
    \ < b ? -1 : 1;\n        return a.countOnes < b.countOnes ? -1 : 1;\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_hoixm0.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_hoixm0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmfu_dnht.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfu_dnht.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(x => tuple(x, countOnes(x)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_with_ones.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpitv4_yew.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpitv4_yew.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_z31eczl.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_z31eczl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpinl5vq_o.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpinl5vq_o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzh3vr2g0.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzh3vr2g0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.to!string.count(\"1\");\n\
    \        auto b1 = b.to!string.count(\"1\");\n        return a1 == b1 ? a - b\
    \ : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp273d19qc.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp273d19qc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes)).array;\n    arr_with_ones.sort!((a, b)\
    \ => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdyj6kp9e.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdyj6kp9e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes() == b.countOnes()) ? a.cmp(b) : a.countOnes().cmp(b.countOnes()));\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpde6ppkzz.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpde6ppkzz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7d_lwhvx.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7d_lwhvx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpufld544h.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpufld544h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count('1');\n\
    \        auto b1 = b.to!string.count('1');\n        return a1 < b1 ? -1 : a1 >\
    \ b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm8g_c0k3.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm8g_c0k3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuvwfiem1.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvwfiem1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        if (a == b) return 0;\n        if (a\
    \ < 0) return -1;\n        if (b < 0) return 1;\n        auto a1 = a.countOnes;\n\
    \        auto b1 = b.countOnes;\n        if (a1 == b1) return a < b ? -1 : 1;\n\
    \        return a1 < b1 ? -1 : 1;\n    });\n    return arr2;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmg4awtmb.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmg4awtmb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        if (a_.count('1') == b_.count('1'))\n        \
    \    return a < b;\n        return a_.count('1') < b_.count('1');\n    });\n \
    \   return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6k596se9.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6k596se9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    return arr.sort!((a, b) =>\n    {\n        int aOnes = a.countOnes();\n \
    \       int bOnes = b.countOnes();\n        return aOnes == bOnes ? a.compare(b)\
    \ : aOnes.compare(bOnes);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmyy40vnv.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmyy40vnv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5wkkx28l.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5wkkx28l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a_ones = a.countOnes();\n        int b_ones = b.countOnes();\n\
    \        if (a_ones == b_ones)\n            return a.compare(b);\n        return\
    \ a_ones.compare(b_ones);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplp04k5h2.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplp04k5h2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n        long a_ones = count_ones(a);\n\
    \        long b_ones = count_ones(b);\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdecx033n.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdecx033n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n    \
    \    if (a1 == b1)\n            return a - b;\n        return a1 - b1;\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqqw2j7jf.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqqw2j7jf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) => \n    {\n        long a_ones = count_ones(a);\n\
    \        long b_ones = count_ones(b);\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw27nacc9.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw27nacc9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a.compare(b);\n        return\
    \ a_ones.compare(b_ones);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw5zxcetr.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw5zxcetr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp83hyf3w9.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83hyf3w9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_nsdm8mb.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_nsdm8mb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(x => tuple(x, x.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(x =>\
    \ x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyc4ibqze.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyc4ibqze.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpppg80ro2.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpppg80ro2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_mt01lmk.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_mt01lmk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.map!(x\
    \ => tuple(x, x.countOnes)).sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0]\
    \ < b[0]));\n    return a.map!(x => x[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_1s3ha24.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1s3ha24.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => {\n        auto aa = a.to!string(2);\n        auto bb =\
    \ b.to!string(2);\n        return aa.count('1') == bb.count('1') ? a - b : aa.count('1')\
    \ - bb.count('1');\n    });\n    return a;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbvre3e24.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbvre3e24.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        long[] aBin = a.toBinaryString.to!long[];\n        long[]\
    \ bBin = b.toBinaryString.to!long[];\n        long aOnes = aBin.count!(x => x\
    \ == 1);\n        long bOnes = bBin.count!(x => x == 1);\n        if (aOnes ==\
    \ bOnes)\n            return a < b;\n        return aOnes < bOnes;\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0rh7q1sa.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rh7q1sa.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    int[] ones = new\
    \ int[arr.length];\n    int[] zeros = new int[arr.length];\n    int[] tmp = new\
    \ int[arr.length];\n    int[] tmp2 = new int[arr.length];\n    int[] tmp3 = new\
    \ int[arr.length];\n    int[] tmp4 = new int[arr.length];\n    int[] tmp5 = new\
    \ int[arr.length];\n    int[] tmp6 = new int[arr.length];\n    int[] tmp7 = new\
    \ int[arr.length];\n    int[] tmp8 = new int[arr.length];\n    int[] tmp9 = new\
    \ int[arr.length];\n    int[] tmp10 = new int[arr.length];\n    int[] tmp11 =\
    \ new int[arr.length];\n    int[] tmp12 = new int[arr.length];\n    int[] tmp13\
    \ = new int[arr.length];\n    int[] tmp14 = new int[arr.length];\n    int[] tmp15\
    \ = new int[arr.length];\n    int[] tmp16 = new int[arr.length];\n    int[] tmp17\
    \ = new int[arr.length];\n    int[] tmp18 = new int[arr.length];\n    int[] tmp19\
    \ = new int[arr.length];\n    int[] tmp20 = new int[arr.length];\n    int[] tmp21\
    \ = new int[arr.length];\n    int[] tmp22 = new int[arr.length];\n    int[] tmp23\
    \ = new int[arr.length];\n    int[] tmp24 = new int[arr.length];\n    int[] tmp25\
    \ = new int[arr.length];\n    int[] tmp26 = new int[arr.length];\n    int[] tmp27\
    \ = new int[arr.length];\n    int[] tmp28 = new int[arr.length];\n    int[] tmp29\
    \ = new int[arr.length];\n    int[] tmp30 = new int[arr.length];\n    int[] tmp31\
    \ = new int[arr.length];\n    int[] tmp32 = new int[arr.length];\n    int[] tmp33\
    \ = new int[arr.length];\n    int[] tmp34 = new int[arr.length];\n    int[] tmp35\
    \ = new\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzel1b3zo.d(54): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpzel1b3zo.d(54): Error: semicolon expected, not `unittest`\\n/tmp/tmpzel1b3zo.d(54):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpzel1b3zo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count(\"1\");\n\
    \        auto b1 = b.to!string.count(\"1\");\n        return a1 < b1 ? -1 : a1\
    \ > b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbpsld7h2.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbpsld7h2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 :\
    \ a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1_hijfu5.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1_hijfu5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        if (a1.count('1') == b1.count('1'))\n        \
    \    return a < b;\n        return a1.count('1') < b1.count('1');\n    });\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp04hfzmbb.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04hfzmbb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjsy40sve.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsy40sve.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) ? 1 : (a.countOnes < b.countOnes)\
    \ ? -1 : a.compare(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw3rjr9ec.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw3rjr9ec.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmnr89viu.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmnr89viu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sort_func\
    \ = (a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        if (a_ones == b_ones)\n            return a - b;\n \
    \       return a_ones - b_ones;\n    };\n    return arr.sort!sort_func;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz33wx4eb.d(17): Error: variable `tmpz33wx4eb.sort_array.sort_func`\
    \ type `void` is inferred from initializer `(a, b) => ()\\n{\\nauto a_ones = a.countOnes;\\\
    nauto b_ones = b.countOnes;\\nif (a_ones == b_ones)\\nreturn a - b;\\nreturn a_ones\
    \ - b_ones;\\n}\\n`, and variables cannot be of type `void`\\n/tmp/tmpz33wx4eb.d(17):\
    \ Error: template lambda has no value\\n/tmp/tmpz33wx4eb.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpz33wx4eb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9fwybv8o.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9fwybv8o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptipqpy66.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptipqpy66.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string;\n        auto\
    \ b1 = b.to!string;\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        return a2 == b2 ? a - b : a2 - b2;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvninb616.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvninb616.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) ? 1 : (a.countOnes < b.countOnes)\
    \ ? -1 : (a > b) ? 1 : -1);\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptj087xtn.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptj087xtn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort!((a, b) =>\n    {\n        long aOnes = countOnes(a);\n\
    \        long bOnes = countOnes(b);\n        return aOnes == bOnes ? a.compare(b)\
    \ : aOnes.compare(bOnes);\n    })(sorted);\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4pt8xhru.d(18): Error: template instance `sort!((a, b) => ()\\\
    n{\\nlong aOnes = countOnes(a);\\nlong bOnes = countOnes(b);\\nreturn aOnes ==\
    \ bOnes ? a.compare(b) : aOnes.compare(bOnes);\\n}\\n)` template `sort` is not\
    \ defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4pt8xhru.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = new long[arr.length];\n    long[] temp = new long[arr.length];\n    int[]\
    \ ones = new int[arr.length];\n    int i = 0;\n    foreach(long n; arr)\n    {\n\
    \        temp[i] = n;\n        ones[i] = countOnes(n);\n        i++;\n    }\n\
    \    sort(temp, ones);\n    i = 0;\n    foreach(long n; temp)\n    {\n       \
    \ result[i] = n;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeitweii8.d(24): Error: undefined identifier `countOnes`\\n/tmp/tmpeitweii8.d(27):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeitweii8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2vjt4qfl.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2vjt4qfl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => \n    {\n        auto c = a.countOnes;\n        auto d\
    \ = b.countOnes;\n        if (c == d)\n            return a - b;\n        return\
    \ c - d;\n    });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxhdjfrgh.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxhdjfrgh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppnx7p42o.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnx7p42o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        long a_ones = a.countOnes();\n        long b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr7lq8kqr.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr7lq8kqr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzl_3ya34.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzl_3ya34.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count(\"1\");\n\
    \        auto b1 = b.to!string.count(\"1\");\n        if (a1 == b1)\n        \
    \    return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqzj_2oy8.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqzj_2oy8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n        int aOnes = countOnes(a);\n\
    \        int bOnes = countOnes(b);\n        if (aOnes == bOnes)\n            return\
    \ a - b;\n        return aOnes - bOnes;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp50liu8bl.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp50liu8bl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        if (a2 == b2)\n            return a < b;\n        return a2 < b2;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8yuuc0ul.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8yuuc0ul.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes)).array;\n    arr_with_ones.sort!((a, b)\
    \ => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgvc7et_0.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgvc7et_0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes()));\n    arr_with_ones.sort!((a, b) =>\
    \ \n    {\n        if (a[1] == b[1])\n            return a[0] > b[0];\n      \
    \  return a[1] > b[1];\n    });\n    return arr_with_ones.map!(a => a[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkv6zpx98.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkv6zpx98.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        if (a1.count!(x => x == '1') == b1.count!(x =>\
    \ x == '1'))\n            return a < b;\n        return a1.count!(x => x == '1')\
    \ < b1.count!(x => x == '1');\n    });\n    return arr2;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp70ofd4ly.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp70ofd4ly.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn_lmqmh4.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_lmqmh4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpixvnbpqm.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpixvnbpqm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count('1');\n\
    \        auto b1 = b.to!string.count('1');\n        if (a1 == b1)\n          \
    \  return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cwywh6a.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5cwywh6a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxeyn_1my.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxeyn_1my.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp878334rs.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp878334rs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuwqo3u5t.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuwqo3u5t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        return aOnes == bOnes ? a.compare(b) : aOnes.compare(bOnes);\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd44o6pq8.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd44o6pq8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl1p5i0vx.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl1p5i0vx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcqm8cuku.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcqm8cuku.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto aa = a.to!string(2);\n        auto bb =\
    \ b.to!string(2);\n        if (aa.count('1') == bb.count('1'))\n            return\
    \ a < b;\n        return aa.count('1') < bb.count('1');\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnhv5igh.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnhv5igh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones >\
    \ b_ones ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplvfjt94j.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvfjt94j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    auto arr3 = arr.dup;\n    auto arr4 = arr.dup;\n    auto arr5 = arr.dup;\n\
    \    auto arr6 = arr.dup;\n    auto arr7 = arr.dup;\n    auto arr8 = arr.dup;\n\
    \    auto arr9 = arr.dup;\n    auto arr10 = arr.dup;\n    auto arr11 = arr.dup;\n\
    \    auto arr12 = arr.dup;\n    auto arr13 = arr.dup;\n    auto arr14 = arr.dup;\n\
    \    auto arr15 = arr.dup;\n    auto arr16 = arr.dup;\n    auto arr17 = arr.dup;\n\
    \    auto arr18 = arr.dup;\n    auto arr19 = arr.dup;\n    auto arr20 = arr.dup;\n\
    \    auto arr21 = arr.dup;\n    auto arr22 = arr.dup;\n    auto arr23 = arr.dup;\n\
    \    auto arr24 = arr.dup;\n    auto arr25 = arr.dup;\n    auto arr26 = arr.dup;\n\
    \    auto arr27 = arr.dup;\n    auto arr28 = arr.dup;\n    auto arr29 = arr.dup;\n\
    \    auto arr30 = arr.dup;\n    auto arr31 = arr.dup;\n    auto arr32 = arr.dup;\n\
    \    auto arr33 = arr.dup;\n    auto arr34 = arr.dup;\n    auto arr35 = arr.dup;\n\
    \    auto arr36 = arr.dup;\n    auto arr37 = arr.dup;\n    auto arr38 = arr.dup;\n\
    \    auto arr39 = arr.dup;\n    auto arr40 = arr.dup;\n    auto arr41 = arr.dup;\n\
    \    auto arr42 = arr.dup;\n    auto arr43 = arr.dup;\n    auto arr44 = arr.dup;\n\
    \    auto arr45 = arr.dup;\n    auto arr46 = arr.dup;\n    auto arr47 = arr.dup;\n\
    \    auto arr\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo9g64uus.d(64): Error: no identifier for declarator `arr`\\n/tmp/tmpo9g64uus.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpo9g64uus.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3er3w4qg.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3er3w4qg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n\
    \        if (a1 == b1)\n            return a - b;\n        return a1 - b1;\n \
    \   });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7al2sj_b.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7al2sj_b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) => \n    {\n        int aCount = countOnes(a);\n\
    \        int bCount = countOnes(b);\n        if (aCount == bCount)\n         \
    \   return a - b;\n        return aCount - bCount;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo7vzegyh.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo7vzegyh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqjmgaw_9.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqjmgaw_9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeps9_xcb.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeps9_xcb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_copy\
    \ = arr.dup;\n    arr_copy.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_copy;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4js6gvpk.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4js6gvpk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a.compare(b);\n        return a_ones.compare(b_ones);\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp48ul3yli.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp48ul3yli.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2j2smsb6.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2j2smsb6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a_ones = a.countOnes();\n        int b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9a15fvv0.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9a15fvv0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes.cmp(b.countOnes));\n    a.sort!((a, b) => a.cmp(b));\n\
    \    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbn1cj2v_.d(18): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbn1cj2v_.d(19): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbn1cj2v_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpteiwyqat.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpteiwyqat.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto aBin = a.to!string(2);\n        auto bBin\
    \ = b.to!string(2);\n        auto aOnes = aBin.count('1');\n        auto bOnes\
    \ = bBin.count('1');\n        if (aOnes == bOnes)\n            return a < b;\n\
    \        return aOnes < bOnes;\n    });\n    return arr2;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl152l69m.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl152l69m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) => \n    {\n        if (a == b)\n      \
    \      return 0;\n        else if (a < 0)\n            return -1;\n        else\
    \ if (b < 0)\n            return 1;\n        else\n        {\n            long\
    \ a_ones = countOnes(a);\n            long b_ones = countOnes(b);\n          \
    \  if (a_ones == b_ones)\n                return a < b ? -1 : 1;\n           \
    \ else\n                return a_ones < b_ones ? -1 : 1;\n        }\n    });\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpef46rcet.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpef46rcet.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        if (a_ones == b_ones)\n            return a < b ? -1\
    \ : 1;\n        return a_ones < b_ones ? -1 : 1;\n    });\n    return a;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph5igqtdp.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5igqtdp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg4cichcw.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg4cichcw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdaizm_t1.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdaizm_t1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n        int a_ones = countOnes(a);\n\
    \        int b_ones = countOnes(b);\n        if (a_ones == b_ones)\n         \
    \   return a - b;\n        return a_ones - b_ones;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rkx8uw9.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rkx8uw9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) => \n    {\n        long a_ones = count_ones(a);\n\
    \        long b_ones = count_ones(b);\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbjlhwj43.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbjlhwj43.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n    \
    \    if (a1 == b1)\n            return a - b;\n        return a1 - b1;\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4o25vskf.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4o25vskf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        if (a_ones == b_ones)\n            return a < b;\n \
    \       return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpadd7q3ux.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpadd7q3ux.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5oei4p49.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5oei4p49.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n        auto aa =\
    \ a.to!string(2);\n        auto bb = b.to!string(2);\n        if (aa.count('1')\
    \ == bb.count('1'))\n            return a < b;\n        return aa.count('1') <\
    \ bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsj8dqdyg.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsj8dqdyg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string.count('1');\n\
    \        auto bb = b.to!string.count('1');\n        if (aa == bb)\n          \
    \  return a < b;\n        return aa < bb;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2amktlo.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2amktlo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpforq1dg8.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpforq1dg8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort!((a, b) =>\n    {\n        long a_ones = countOnes(a);\n\
    \        long b_ones = countOnes(b);\n        return a_ones == b_ones ? a.compare(b)\
    \ : a_ones.compare(b_ones);\n    })(sorted);\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2s9odouu.d(18): Error: template instance `sort!((a, b) => ()\\\
    n{\\nlong a_ones = countOnes(a);\\nlong b_ones = countOnes(b);\\nreturn a_ones\
    \ == b_ones ? a.compare(b) : a_ones.compare(b_ones);\\n}\\n)` template `sort`\
    \ is not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2s9odouu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo3ncdgj5.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3ncdgj5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoz3j6g4g.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoz3j6g4g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => {\n        int a1 =\
    \ countOnes(a);\n        int b1 = countOnes(b);\n        if (a1 == b1)\n     \
    \       return a - b;\n        return a1 - b1;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp__qqjqyy.d(19): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp__qqjqyy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        auto a_ones = a_.count!(c => c == '1');\n    \
    \    auto b_ones = b_.count!(c => c == '1');\n        if (a_ones == b_ones)\n\
    \            return a < b;\n        return a_ones < b_ones;\n    });\n    return\
    \ arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi26zncqe.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi26zncqe.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        if (a == b)\n            return 0;\n        else if (a\
    \ < 0)\n            return -1;\n        else if (b < 0)\n            return 1;\n\
    \        else\n        {\n            int aOnes = countOnes(a);\n            int\
    \ bOnes = countOnes(b);\n            if (aOnes == bOnes)\n                return\
    \ a - b;\n            else\n                return aOnes - bOnes;\n        }\n\
    \    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk7yan4vn.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7yan4vn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n\
    \        if (a_ones == b_ones)\n            return a - b;\n        return a_ones\
    \ - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjsulrzi.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjsulrzi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppu0q980a.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppu0q980a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3i7831lp.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3i7831lp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) => a.countOnes() == b.countOnes() ? a < b : a.countOnes()\
    \ < b.countOnes());\n    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0m0pv75u.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0m0pv75u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted\
    \ = arr.dup;\n    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjdqjpnx_.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjdqjpnx_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm3zfeay0.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3zfeay0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    sort(arr2, (a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0560rq15.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0560rq15.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aBits = a.countOnes();\n        int bBits = b.countOnes();\n\
    \        return aBits == bBits ? a - b : aBits - bBits;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx7v4wnes.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7v4wnes.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort!((a, b) => \n    {\n        int a_ones = a.countOnes;\n\
    \        int b_ones = b.countOnes;\n        if (a_ones == b_ones)\n          \
    \  return a < b;\n        return a_ones < b_ones;\n    })(sorted);\n    return\
    \ sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp55siywb6.d(18): Error: template instance `sort!((a, b) => ()\\\
    n{\\nint a_ones = a.countOnes;\\nint b_ones = b.countOnes;\\nif (a_ones == b_ones)\\\
    nreturn a < b;\\nreturn a_ones < b_ones;\\n}\\n)` template `sort` is not defined,\
    \ did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55siywb6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmxvbabbb.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmxvbabbb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgamoq573.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgamoq573.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        if (a == b) return 0;\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        if (aOnes == bOnes) return a < b\
    \ ? -1 : 1;\n        return aOnes < bOnes ? -1 : 1;\n    });\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ja83abx.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ja83abx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto cmp = (long\
    \ a, long b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    };\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpon7t8lyo.d(19): Error: no property `countOnes` for type `long`\\\
    n/tmp/tmpon7t8lyo.d(20): Error: no property `countOnes` for type `long`\\n/tmp/tmpon7t8lyo.d(23):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpon7t8lyo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!(a, b => a.countOnes.cmp(b.countOnes));\n    return arr_;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_30sea4u.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_30sea4u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, count_ones(a)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpekk6j6ok.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekk6j6ok.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_0u1nk9.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_0u1nk9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw51qcgcr.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw51qcgcr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto aOnes = a.countOnes();\n        auto bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo11xf90j.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo11xf90j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphuujg8uv.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphuujg8uv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n \
    \       return aOnes < bOnes ? -1 : aOnes > bOnes ? 1 : a < b ? -1 : a > b ? 1\
    \ : 0;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp26irwnrv.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp26irwnrv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = arr.dup;\n    result.sort!((a, b) => \n    {\n        auto a_ones = countOnes(a);\n\
    \        auto b_ones = countOnes(b);\n        if (a_ones == b_ones)\n        \
    \    return a < b;\n        return a_ones < b_ones;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo4da5rts.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo4da5rts.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones\
    \ = arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) =>\
    \ a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxs1tflql.d(17): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxs1tflql.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbuug5f6x.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbuug5f6x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string.count(\"1\");\n\
    \        auto b1 = b.to!string.count(\"1\");\n        return a1 < b1 ? -1 : a1\
    \ > b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsnrceg6k.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsnrceg6k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_avu39t5.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_avu39t5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0j70l8jj.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0j70l8jj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuime32ai.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuime32ai.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmputhjb64q.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmputhjb64q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdimanlee.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdimanlee.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a.compare(b) : aOnes.compare(bOnes);\n    });\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwjlmpfxh.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwjlmpfxh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1fxx6duf.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1fxx6duf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        return (a1 == b1) ? a.compare(b) : a1.compare(b1);\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpznq7dqxy.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpznq7dqxy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        return a_.count!(c => c == '1') == b_.count!(c\
    \ => c == '1') ? a - b : a_.count!(c => c == '1') - b_.count!(c => c == '1');\n\
    \    });\n    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp01g68cgz.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp01g68cgz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5dnj9dmm.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5dnj9dmm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        if (a_.count('1') == b_.count('1'))\n        \
    \    return a < b;\n        return a_.count('1') < b_.count('1');\n    });\n \
    \   return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rfkrag1.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rfkrag1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) => \n    {\n        int aBits = countBits(a);\n\
    \        int bBits = countBits(b);\n        return aBits == bBits ? a - b : aBits\
    \ - bBits;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppfcc_bgy.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfcc_bgy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted\
    \ = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n        long a_ones = countOnes(a);\n\
    \        long b_ones = countOnes(b);\n        return (a_ones == b_ones) ? a -\
    \ b : a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbkab6exs.d(18): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbkab6exs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n        long\
    \ a_ones = a.countOnes;\n        long b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a < b ? -1 : 1;\n        return a_ones < b_ones\
    \ ? -1 : 1;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrndrlap.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgrndrlap.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    return arr.sort!((a, b) => \n    {\n        int a1 = a.countOnes();\n   \
    \     int b1 = b.countOnes();\n        if (a1 == b1)\n            return a - b;\n\
    \        return a1 - b1;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0yf8q0qi.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0yf8q0qi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = arr.dup;\n    result.sort!((a, b) => {\n        long a_ones = a.countOnes;\n\
    \        long b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b ? -1 : 1;\n        return a_ones < b_ones ? -1 : 1;\n    });\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5a141hba.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5a141hba.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!(a\
    \ => a.countOnes, a => a);\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkx1ojeq.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqkx1ojeq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result\
    \ = arr.dup;\n    result.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n\
    \        auto b_ones = countOnes(b);\n        if (a_ones == b_ones)\n        \
    \    return a < b;\n        return a_ones < b_ones;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmil41kz.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbmil41kz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgnc6tllk.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgnc6tllk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    auto arr3 = arr.dup;\n    auto arr4 = arr.dup;\n    auto arr5 = arr.dup;\n\
    \    auto arr6 = arr.dup;\n    auto arr7 = arr.dup;\n    auto arr8 = arr.dup;\n\
    \    auto arr9 = arr.dup;\n    auto arr10 = arr.dup;\n    auto arr11 = arr.dup;\n\
    \    auto arr12 = arr.dup;\n    auto arr13 = arr.dup;\n    auto arr14 = arr.dup;\n\
    \    auto arr15 = arr.dup;\n    auto arr16 = arr.dup;\n    auto arr17 = arr.dup;\n\
    \    auto arr18 = arr.dup;\n    auto arr19 = arr.dup;\n    auto arr20 = arr.dup;\n\
    \    auto arr21 = arr.dup;\n    auto arr22 = arr.dup;\n    auto arr23 = arr.dup;\n\
    \    auto arr24 = arr.dup;\n    auto arr25 = arr.dup;\n    auto arr26 = arr.dup;\n\
    \    auto arr27 = arr.dup;\n    auto arr28 = arr.dup;\n    auto arr29 = arr.dup;\n\
    \    auto arr30 = arr.dup;\n    auto arr31 = arr.dup;\n    auto arr32 = arr.dup;\n\
    \    auto arr33 = arr.dup;\n    auto arr34 = arr.dup;\n    auto arr35 = arr.dup;\n\
    \    auto arr36 = arr.dup;\n    auto arr37 = arr.dup;\n    auto arr38 = arr.dup;\n\
    \    auto arr39 = arr.dup;\n    auto arr40 = arr.dup;\n    auto arr41 = arr.dup;\n\
    \    auto arr42 = arr.dup;\n    auto arr43 = arr.dup;\n    auto arr44 = arr.dup;\n\
    \    auto arr45 = arr.dup;\n    auto arr46 = arr.dup;\n    auto arr47 = arr.dup;\n\
    \    auto arr\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwtkvg2jj.d(64): Error: no identifier for declarator `arr`\\n/tmp/tmpwtkvg2jj.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwtkvg2jj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp23vep898.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23vep898.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a.compare(b) :\
    \ a_ones.compare(b_ones);\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpefp0i6tn.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpefp0i6tn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        if (a2 == b2)\n            return a - b;\n        return a2 - b2;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_k4ikp1a.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_k4ikp1a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvvte3bwl.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvvte3bwl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp836k1cn.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp836k1cn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
