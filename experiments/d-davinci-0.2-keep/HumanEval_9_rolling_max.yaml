name: HumanEval_9_rolling_max
language: humaneval_to_dlang.py
prompt: "import std.typecons;\nimport std.math;\n/*\n From a given list of integers,\
  \ generate a list of rolling maximum element found until given moment\n    in the\
  \ sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4,\
  \ 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L])\
  \ == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        max\
    \ = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, v; numbers)\n    {\n        max = max(max, v);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n        max = max(max,\
    \ n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ number; numbers) \n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        max\
    \ = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach(i, number; numbers[1..$])\n    {\n        min\
    \ = min(min, number);\n        result[i+1] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach(i, number; numbers[1..$])\n    {\n        sum\
    \ += number;\n        result[i+1] = sum;\n    }\n    return result;\n}\n/*\n \
    \   From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n*/\n\
    long[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = numbers", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n\
    \    {\n        max = max(max, n);\n        result[i+1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n\
    \        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        max =\
    \ max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, e;\
    \ numbers[1 .. $])\n    {\n        result[i] = max(result[i - 1], e);\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i] = max(result[i - 1], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, number; numbers)\n    {\n        max = max(max, number);\n   \
    \     result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$])\n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, n; numbers[1..$]) \n    {\n        max = max(max, n);\n      \
    \  result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    for (long i =\
    \ 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i - 1],\
    \ numbers[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, v; numbers[1..$])\n\
    \    {\n        max = max(max, v);\n        result[i+1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        if\
    \ (number > max)\n        {\n            max = number;\n        }\n        result[i\
    \ + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n  \
    \  {\n        if (numbers[i] > max) \n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 1, 1, 1, 1, 1, 1]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] <\
    \ min) \n        {\n            min = numbers[i];\n        }\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8,\
    \ 11, 15, 17]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling average of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5,\
    \ 2, 2.5, 3.2, 3.8, 4.2]\n    \n*/\ndouble[] rolling_avg(", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_so_far\
    \ = max(max_so_far, number);\n        result[i+1] = max_so_far;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    result[0] = min_so_far;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min_so_far = min(min_so_far, number);\n        result[i+1]\
    \ = min_so_far;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8,\
    \ 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum_so_far = numbers[0];\n    result[0]\
    \ = sum_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum_so_far\
    \ += number;\n        result[i+1] = sum_so_far;\n    }\n    return result;\n}\n\
    /*\n    From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4", "{\n    long[] result = new long[numbers.length];\n    auto\
    \ max = numbers[0];\n    foreach (i, n; numbers) \n    {\n        max = max(max,\
    \ n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, v; numbers[1..$]) \n    {\n        max =\
    \ max(max, v);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        result[i + 1] = max(result[i],\
    \ n);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    auto result = new long[];\n    long max = numbers[0];\n\
    \    foreach(i, n; numbers) \n    {\n        if (n > max) \n        {\n      \
    \      max = n;\n        }\n        result ~= max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        max =\
    \ max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i+1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n*/\n\
    long[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = numbers", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[numbers.length];\n    long max = numbers[0];\n   \
    \ result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        max = max(max,\
    \ n);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        if (n > max) \n  \
    \      {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i+1] = max;\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, v; numbers[1..$])\n    {\n        max = max(max, v);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$])\n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, n;\
    \ numbers[1 .. $]) \n    {\n        result[i + 1] = max(result[i], n);\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, e; numbers[1..$])\n\
    \    {\n        max = max(max, e);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n\
    \        max = max(max, n);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n\
    \    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, n; numbers[1..$])\n    {\n        max = max(max, n);\n       \
    \ result[i+1] = max;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1,\
    \ 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n\
    \    foreach(i, n; numbers[1..$])\n    {\n        min = min(min, n);\n       \
    \ result[i+1] = min;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3,\
    \ 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach(i, n; numbers[1..$])\n    {\n        sum += n;\n        result[i+1]\
    \ = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 12, 36, 144, 288]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long product = numbers[0];", "{\n  \
    \  long[] result = new long[numbers.length];\n    long max = numbers[0];\n   \
    \ for (long i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] >\
    \ max) \n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, e; numbers)\n    {\n        max =\
    \ max(max, e);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++) \n    {\n        if (numbers[i] > max) \n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        if (number >\
    \ max) \n        {\n            max = number;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n\
    \    {\n        if (n > max)\n        {\n            max = n;\n        }\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, e; numbers[1..$]) \n    {\n        max = max(max, e);\n      \
    \  result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {", "{\n \
    \   long[] result = new long[numbers.length];\n    long max = numbers[0];\n  \
    \  result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach(i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        max =\
    \ max(max, n);\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, e; numbers)\
    \ \n    {\n        max = max(max, e);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, e; numbers[1..$])\n    {\n\
    \        max = max(max, e);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        if (n\
    \ > max) \n        {\n            max = n;\n        }\n        result[i + 1] =\
    \ max;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        if (n < min) \n        {\n            min = n;\n        }\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    Given a list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3,\
    \ 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach(i, n; numbers[1..$]) \n    {\n        sum += n;\n        result[i\
    \ + 1] = sum;\n    }\n    return result;\n}\n/*\n    Given a list of integers,\
    \ generate a list of rolling average of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5,\
    \ 2, 2.5, 3.2, 3.8, 4.4]\n*/\ndouble[] rolling", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i+1] = max;\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n   \
    \ {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n  \
    \  return result;\n}", "{\n    long[] result = new long[numbers.length];\n   \
    \ long max = 0;\n    foreach(i, n; numbers)\n    {\n        max = max(max, n);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$])\n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i] = max(result[i - 1], number);\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        if(number > max)\n        {\n            max = number;\n     \
    \   }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 3, 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for\
    \ (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n \
    \       result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 6, 12, 36, 144, 288]\n*/\nlong[] rolling_product(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long product = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n  \
    \      max_so_far = max(max_so_far, n);\n        result[i + 1] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min_so_far = numbers[0];\n    result[0] = min_so_far;\n    foreach (i,\
    \ n; numbers[1 .. $]) \n    {\n        min_so_far = min(min_so_far, n);\n    \
    \    result[i + 1] = min_so_far;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 3, 6, 8, 11, 15, 17]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n\
    \    result[0] = sum_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n  \
    \      sum_so_far += n;\n        result[i + 1] = sum_so_far;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3,", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n\
    \    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n   \
    \ {\n        if (numbers[i] > max) \n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 1, 1, 1, 1, 1, 1]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] <\
    \ min) \n        {\n            min = numbers[i];\n        }\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n  \
    \  \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 1.5, 2, 2.5, 3.4, 3.8, 4.4]\n    \n*/\ndouble[]\
    \ rolling_average(long[] numbers) ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    foreach(i, e; numbers)\n    {\n        max = max(max,\
    \ e);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i] = max(result[i - 1], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, e; numbers)\n    {\n        if (e > max)\n            max = e;\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = 0;\n    foreach(i, n; numbers) \n\
    \    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, n; numbers) \n    {\n        min = min(min, n);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 3, 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long sum = 0;\n    foreach(i,\
    \ n; numbers) \n    {\n        sum += n;\n        result[i] = sum;\n    }\n  \
    \  return result;\n}\n/*\n    From a given list of integers, generate a list of\
    \ rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n\
    */\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = 1;\n    foreach(i, n; numbers) \n    {\n        product *=\
    \ n;\n        result[i] = product;\n    }\n    return result;\n}\n/*\n    From\
    \ a given", "{\n    long[] result = new long[numbers.length];\n    long max_so_far\
    \ = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max_so_far = max(max_so_far, number);\n        result[i + 1]\
    \ = max_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1,\
    \ 1, 1, 1]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long min_so_far = numbers[0];\n    result[0]\
    \ = min_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        min_so_far\
    \ = min(min_so_far, number);\n        result[i + 1] = min_so_far;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far\
    \ = numbers[0];\n    result[0] = sum_so_far;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        sum_so_far += number;\n        result[i + 1] = sum_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n  \
    \  \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 36, 144, 288]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = 0;\n    foreach(i,\
    \ number; numbers) \n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, e; numbers[1..$])\n\
    \    {\n        max = max(max, e);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n\
    \        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, num; numbers)\n    {\n        max = max(max, num);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i+1] = max;\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ n; numbers)\n    {\n        max = max(max, n);\n        result[i] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long current_max = numbers[0];\n    foreach(i, number; numbers) \n    {\n\
    \        current_max = max(current_max, number);\n        result[i] = current_max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, e; numbers[1..$])\n\
    \    {\n        if (e > max)\n        {\n            max = e;\n        }\n   \
    \     result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    foreach(i, number; numbers)\
    \ \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, e; numbers[1 .. $]) \n    {\n        result[i] = max(result[i\
    \ - 1], e);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        if(number > max)\n        {\n            max = number;\n     \
    \   }\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, n; numbers[1..$]) \n    {\n        max = max(max, n);\n      \
    \  result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach(i, e; numbers[1..$]) \n    {\n        max = max(max, e);\n      \
    \  result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach(i, n; numbers[1..$]) \n    {\n        if (n > max) \n        {\n  \
    \          max = n;\n        }\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n  \
    \  {\n        if (numbers[i] > max) \n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$])\n    {\n        if(number > max)\n\
    \        {\n            max = number;\n        }\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, v; numbers)\n    {\n        max =\
    \ max(max, v);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, v; numbers)\n    {\n        max = max(max, v);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n\
    \    {\n        max = max(max, n);\n        result[i+1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n\
    \        max = max(max, n);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    for (int i = 1; i < numbers.length; i++) \n    {\n        result[i] = max(result[i\
    \ - 1], numbers[i]);\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach(i, n; numbers[1..$]) \n    {\n        max = max(max, n);\n        result[i\
    \ + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, v; numbers)\n    {\n        max =\
    \ max(max, v);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, n; numbers[1..$]) \n    {\n        max =\
    \ max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n Given\
    \ a list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n Given a list of\
    \ integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3,\
    \ 6, 8, 11, 15, 17]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate\
    \ a list of rolling average of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5, 2, 2.5, 3.5, 4.5,\
    \ 5]\n*/\ndouble[] rolling_average(long[] numbers) \n{\n    double[] result =\
    \ new double[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach(i, n; numbers[1..$])\n    {\n        max = max(max,\
    \ n);\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach(i, number; numbers[1..$])\n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   foreach(i, number; numbers)\n    {\n        max = max(max, number);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i\
    \ < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n      \
    \  result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach(i, n; numbers[1..$]) \n    {\n        max = max(max, n);\n        result[i+1]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
