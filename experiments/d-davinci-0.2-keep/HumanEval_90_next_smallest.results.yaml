name: HumanEval_90_next_smallest
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvm8_17og.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvm8_17og.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvm8_17og.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        } \n        else if (e < min2) \n        {\n         \
    \   min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpomulja_u.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpomulja_u.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpomulja_u.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n\
    \            second_min = min;\n            min = e;\n        }\n        else\
    \ if (e < second_min)\n        {\n            second_min = e;\n        }\n   \
    \ }\n    if (min == second_min)\n        return Nullable!(long)();\n    return\
    \ Nullable!(long)(second_min);\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpy0k2__yc.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpy0k2__yc.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpy0k2__yc.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x7550f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long next_min = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       next_min = min;\n            min = e;\n        }\n        else if (e <\
    \ next_min)\n        {\n            next_min = e;\n        }\n    }\n    \n  \
    \  if (min == next_min)\n        return null;\n    \n    return next_min;\n}\n\
    unittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeua35o3m.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpeua35o3m.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpeua35o3m.d(39): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpeua35o3m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq4qhceme.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpq4qhceme.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpq4qhceme.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpq4qhceme.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst) \n    {\n        if (e < min) \n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2) \n        {\n   \
    \         min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzfzq4jac.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpzfzq4jac.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzfzq4jac.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long smallest = lst[0];\n    long second_smallest = lst[1];\n   \
    \ foreach (i, e; lst) \n    {\n        if (e < smallest) \n        {\n       \
    \     second_smallest = smallest;\n            smallest = e;\n        } \n   \
    \     else if (e < second_smallest) \n        {\n            second_smallest =\
    \ e;\n        }\n    }\n    return second_smallest;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjvl_rfds.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjvl_rfds.d(32): Error: cannot\
    \ implicitly convert expression `second_smallest` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjvl_rfds.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n            next_min\
    \ = min;\n            min = e;\n        }\n        else if (e < next_min)\n  \
    \      {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6s160_2d.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6s160_2d.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6s160_2d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        } \n   \
    \     else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4nk2d0_7.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4nk2d0_7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx5n9ok4d.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpx5n9ok4d.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx5n9ok4d.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpygoky7ng.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpygoky7ng.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpygoky7ng.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpygoky7ng.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ min2 = min;\n            min = v;\n        }\n        else if (v < min2)\n \
    \       {\n            min2 = v;\n        }\n    }\n    if (min == min2)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp66ioy2ie.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp66ioy2ie.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp66ioy2ie.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xddcaf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long second_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e\
    \ < min) \n        {\n            second_min = min;\n            min = e;\n  \
    \      }\n        else if (e < second_min) \n        {\n            second_min\
    \ = e;\n        }\n    }\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpudsictgq.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpudsictgq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1jp89_cm.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1jp89_cm.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp1jp89_cm.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1jp89_cm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0u6yti8e.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0u6yti8e.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp0u6yti8e.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp0u6yti8e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i; lst) \n    {\n        if (i < min) \n        {\n\
    \            second_min = min;\n            min = i;\n        }\n        else\
    \ if (i < second_min) \n        {\n            second_min = i;\n        }\n  \
    \  }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0cvl82h5.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0cvl82h5.d(35): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0cvl82h5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long second_min = lst[1];\n    foreach (i,\
    \ e; lst) \n    {\n        if (e < min) \n        {\n            second_min =\
    \ min;\n            min = e;\n        } \n        else if (e < second_min) \n\
    \        {\n            second_min = e;\n        }\n    }\n    return second_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv2g5jwko.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv2g5jwko.d(32): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2g5jwko.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach (i, v; lst)\
    \ \n    {\n        if (v < min) \n        {\n            next = min;\n       \
    \     min = v;\n        } \n        else if (v < next) \n        {\n         \
    \   next = v;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfch9mj9y.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfch9mj9y.d(32): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfch9mj9y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3_avcs1r.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3_avcs1r.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp3_avcs1r.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3_avcs1r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ second = min;\n            min = v;\n        }\n        else if (v < second)\n\
    \        {\n            second = v;\n        }\n    }\n    if (min == second)\n\
    \        return Nullable!(long)();\n    return Nullable!(long)(second);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjtg6mmz6.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpjtg6mmz6.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpjtg6mmz6.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x8cb4f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4jn1ln__.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp4jn1ln__.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp4jn1ln__.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4jn1ln__.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n\
    \        {\n            min2 = e;\n        }\n    }\n    \n    if (min2 == min)\n\
    \        return null;\n    \n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb31oak7x.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpb31oak7x.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpb31oak7x.d(39): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpb31oak7x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min1 = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min1 > min2)\n        swap(min1, min2);\n    foreach (i, e; lst[2..$])\n  \
    \  {\n        if (e < min1)\n        {\n            min2 = min1;\n           \
    \ min1 = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp19cjc2f5.d(22): Error: undefined identifier `swap`, did you mean\
    \ template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable,\
    \ Targets))`?\\n/tmp/tmp19cjc2f5.d(18): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp19cjc2f5.d(35): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp19cjc2f5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpohctdgei.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpohctdgei.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpohctdgei.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpohctdgei.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long next_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e <\
    \ min) \n        {\n            next_min = min;\n            min = e;\n      \
    \  }\n        else if (e < next_min) \n        {\n            next_min = e;\n\
    \        }\n    }\n    return next_min;\n}\nunittest\n{\n    alias candidate =\
    \ next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy1zaih9r.d(35): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpy1zaih9r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long smallest = lst[0];\n    long second_smallest = lst[1];\n   \
    \ foreach (i, v; lst)\n    {\n        if (v < smallest)\n        {\n         \
    \   second_smallest = smallest;\n            smallest = v;\n        }\n      \
    \  else if (v < second_smallest)\n        {\n            second_smallest = v;\n\
    \        }\n    }\n    if (smallest == second_smallest) return null;\n    return\
    \ second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm2tjchyg.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpm2tjchyg.d(32): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpm2tjchyg.d(33): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpm2tjchyg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n            next_min\
    \ = min;\n            min = e;\n        }\n        else if (e < next_min)\n  \
    \      {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvp_6r162.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvp_6r162.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvp_6r162.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i; lst) \n    {\n        if (i < min) \n        {\n\
    \            second_min = min;\n            min = i;\n        } \n        else\
    \ if (i < second_min) \n        {\n            second_min = i;\n        }\n  \
    \  }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp60xz6bf_.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp60xz6bf_.d(35): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp60xz6bf_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long second_min = lst[1];\n    foreach (i,\
    \ v; lst)\n    {\n        if (v < min)\n        {\n            second_min = min;\n\
    \            min = v;\n        }\n        else if (v < second_min)\n        {\n\
    \            second_min = v;\n        }\n    }\n    return second_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwryzlv0.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpbwryzlv0.d(32): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwryzlv0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min == min2)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp20re2cta.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp20re2cta.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp20re2cta.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xf31c8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyrd_smb2.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpyrd_smb2.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpyrd_smb2.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyrd_smb2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpblt3wqra.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmpblt3wqra.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmpblt3wqra.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0xbcce5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1le8l3ep.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1le8l3ep.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp1le8l3ep.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1le8l3ep.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next_min = lst[1];\n    foreach (i,\
    \ e; lst)\n    {\n        if (e < min)\n        {\n            next_min = min;\n\
    \            min = e;\n        }\n        else if (e < next_min)\n        {\n\
    \            next_min = e;\n        }\n    }\n    return next_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptiwzpzgu.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmptiwzpzgu.d(32): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptiwzpzgu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppfy_t_u5.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmppfy_t_u5.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfy_t_u5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lzbimiq.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1lzbimiq.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp1lzbimiq.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1lzbimiq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        }\n    \
    \    else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9fcriazv.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9fcriazv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\n\
    \        {\n            second_min = e;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy9k2ruzj.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpy9k2ruzj.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpy9k2ruzj.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpy9k2ruzj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n            next_min\
    \ = min;\n            min = e;\n        }\n        else if (e < next_min)\n  \
    \      {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw0tmxbmv.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw0tmxbmv.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0tmxbmv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ second_min = min;\n            min = v;\n        }\n        else if (v < second_min)\n\
    \        {\n            second_min = v;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe2bbmk5h.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpe2bbmk5h.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpe2bbmk5h.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpe2bbmk5h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n            next_min\
    \ = min;\n            min = e;\n        }\n        else if (e < next_min)\n  \
    \      {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ts5rqvz.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8ts5rqvz.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ts5rqvz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppzzkmjot.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmppzzkmjot.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppzzkmjot.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach (i, e;\
    \ lst)\n    {\n        if (e < min)\n        {\n            second = min;\n  \
    \          min = e;\n        }\n        else if (e < second)\n        {\n    \
    \        second = e;\n        }\n    }\n    return second;\n}\nunittest\n{\n \
    \   alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuopj1vx3.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpuopj1vx3.d(32): Error: cannot\
    \ implicitly convert expression `second` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuopj1vx3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ Nullable!(long)();\n    long min1 = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min1 > min2) swap(min1, min2);\n    foreach (i, e; lst[2..$]) \n    {\n   \
    \     if (e < min1) \n        {\n            min2 = min1;\n            min1 =\
    \ e;\n        } \n        else if (e < min2) \n        {\n            min2 = e;\n\
    \        }\n    }\n    return Nullable!(long)(min2);\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8tfdo78p.d(20): Error: undefined identifier `swap`, did you mean\
    \ template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable,\
    \ Targets))`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8tfdo78p.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = minElement(lst);\n    long min2 = long.max;\n    foreach\
    \ (i; lst)\n    {\n        if (i == min) continue;\n        if (i < min2) min2\
    \ = i;\n    }\n    if (min2 == long.max) return null;\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnzu018o2.d(18): Error: undefined identifier `minElement`\\n/tmp/tmpnzu018o2.d(17):\
    \ Error: cannot implicitly convert expression `null` of type `typeof(null)` to\
    \ `Nullable!long`\\n/tmp/tmpnzu018o2.d(25): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpnzu018o2.d(26): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnzu018o2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2o7o5mp9.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2o7o5mp9.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp2o7o5mp9.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2o7o5mp9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n            next_min\
    \ = min;\n            min = e;\n        }\n        else if (e < next_min)\n  \
    \      {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppqumvop3.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmppqumvop3.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppqumvop3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i; lst) \n    {\n        if (i < min) \n        {\n\
    \            second_min = min;\n            min = i;\n        }\n        else\
    \ if (i < second_min) \n        {\n            second_min = i;\n        }\n  \
    \  }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu2a9586g.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu2a9586g.d(35): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2a9586g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach (i, v; lst)\n\
    \    {\n        if (v < min)\n        {\n            next = min;\n           \
    \ min = v;\n        }\n        else if (v < next)\n        {\n            next\
    \ = v;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpak4qp3fh.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpak4qp3fh.d(32): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpak4qp3fh.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    if (min > min2)\n    {\n        min = min2;\n        min2 = lst[0];\n   \
    \ }\n    foreach (i, e; lst[2..$])\n    {\n        if (e < min)\n        {\n \
    \           min2 = min;\n            min = e;\n        }\n        else if (e <\
    \ min2)\n        {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbk1fr54v.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455b09]\\n??:? void tmpbk1fr54v.__unittest_L40_C1()\
    \ [0x4419fa]\\n??:? void tmpbk1fr54v.__modtest() [0x453618]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x455136]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a34d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2d9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x45510d]\\n??:? runModuleUnitTests [0x45e8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a94]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a1b]\\n??:? _d_run_main [0x456986]\\n??:? main [0x4536eb]\\\
    n??:? __libc_start_main [0x55496554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvxvcxfcl.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvxvcxfcl.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvxvcxfcl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgi8gpq9p.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgi8gpq9p.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgi8gpq9p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach (i, v;\
    \ lst)\n    {\n        if (v < min)\n        {\n            second = min;\n  \
    \          min = v;\n        }\n        else if (v < second)\n        {\n    \
    \        second = v;\n        }\n    }\n    return second;\n}\nunittest\n{\n \
    \   alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxcti1k_8.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxcti1k_8.d(32): Error: cannot\
    \ implicitly convert expression `second` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxcti1k_8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\n\
    \        {\n            second_min = e;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpndxfgmir.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpndxfgmir.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpndxfgmir.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpndxfgmir.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n            next_min\
    \ = min;\n            min = v;\n        }\n        else if (v < next_min)\n  \
    \      {\n            next_min = v;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pqnwrl7.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5pqnwrl7.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5pqnwrl7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long smallest = lst[0];\n    long second_smallest =\
    \ lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < smallest)\n       \
    \ {\n            second_smallest = smallest;\n            smallest = e;\n    \
    \    }\n        else if (e < second_smallest)\n        {\n            second_smallest\
    \ = e;\n        }\n    }\n    if (smallest == second_smallest)\n        return\
    \ null;\n    return second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpam1eju3i.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpam1eju3i.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpam1eju3i.d(35): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpam1eju3i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6wef8t_g.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6wef8t_g.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp6wef8t_g.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6wef8t_g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8c24cutm.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8c24cutm.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8c24cutm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsh084_d7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpsh084_d7.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpsh084_d7.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xd6324554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = minElement(lst);\n    long min2 = min;\n\
    \    foreach (e; lst)\n    {\n        if (e < min2 && e != min)\n            min2\
    \ = e;\n    }\n    if (min2 == min)\n        return null;\n    return min2;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv5_xuu93.d(19): Error: undefined identifier `minElement`\\n/tmp/tmpv5_xuu93.d(18):\
    \ Error: cannot implicitly convert expression `null` of type `typeof(null)` to\
    \ `Nullable!long`\\n/tmp/tmpv5_xuu93.d(27): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv5_xuu93.d(28): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv5_xuu93.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ min2 = min;\n            min = v;\n        }\n        else if (v < min2)\n \
    \       {\n            min2 = v;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2poff9eu.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp2poff9eu.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp2poff9eu.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x1ce8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, val;\
    \ lst)\n    {\n        if (val < min)\n        {\n            min2 = min;\n  \
    \          min = val;\n        }\n        else if (val < min2)\n        {\n  \
    \          min2 = val;\n        }\n    }\n    return min2;\n}\nunittest\n{\n \
    \   alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxplzsned.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxplzsned.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxplzsned.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg09zvga9.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpg09zvga9.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpg09zvga9.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpg09zvga9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphcijortp.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmphcijortp.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmphcijortp.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x3ed97554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        }\n    \
    \    else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ybb4822.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp0ybb4822.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n         \
    \   min2 = min;\n            min = e;\n        }\n        else if (e < min2) \n\
    \        {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps9ffw4s0.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmps9ffw4s0.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmps9ffw4s0.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x565aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt45i0jk0.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpt45i0jk0.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt45i0jk0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    long min = lst[0];\n  \
    \  long min2 = lst[0];\n    foreach(i; lst)\n    {\n        if(i < min)\n    \
    \    {\n            min2 = min;\n            min = i;\n        }\n        else\
    \ if(i < min2)\n        {\n            min2 = i;\n        }\n    }\n    if(min2\
    \ == min)\n    {\n        return Nullable!(long)();\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi5pkqltc.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab9]\\n??:? void tmpi5pkqltc.__unittest_L37_C1()\
    \ [0x441886]\\n??:? void tmpi5pkqltc.__modtest() [0x4535c8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eabb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550e6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2fd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a38c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a289]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550bd]\\n??:? runModuleUnitTests [0x45e891]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a44]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569cb]\\n??:? _d_run_main [0x456936]\\n??:? main [0x45369b]\\\
    n??:? __libc_start_main [0x6009f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        } \n        else if (e < min2) \n        {\n         \
    \   min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv3wtwbho.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpv3wtwbho.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv3wtwbho.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        }\n    \
    \    else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphl2q50by.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphl2q50by.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n\
    \            second_min = min;\n            min = e;\n        }\n        else\
    \ if (e < second_min)\n        {\n            second_min = e;\n        }\n   \
    \ }\n    if (min == second_min)\n        return Nullable!(long)();\n    return\
    \ Nullable!(long)(second_min);\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl9r5kzig.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpl9r5kzig.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpl9r5kzig.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xe1883554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc1208v31.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpc1208v31.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpc1208v31.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc1208v31.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst) \n    {\n        if (e < min) \n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2) \n        {\n   \
    \         min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw25pxgtc.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw25pxgtc.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw25pxgtc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min == min2)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6upsrusy.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp6upsrusy.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp6upsrusy.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xa2e6c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach (i, e;\
    \ lst) \n    {\n        if (e < min) \n        {\n            second = min;\n\
    \            min = e;\n        } \n        else if (e < second) \n        {\n\
    \            second = e;\n        }\n    }\n    return second;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ox61_9c.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5ox61_9c.d(32): Error: cannot\
    \ implicitly convert expression `second` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ox61_9c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp4rs5mr1.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpp4rs5mr1.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4rs5mr1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpalt9tvkt.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpalt9tvkt.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpalt9tvkt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, val;\
    \ lst) \n    {\n        if (val < min) \n        {\n            min2 = min;\n\
    \            min = val;\n        }\n        else if (val < min2) \n        {\n\
    \            min2 = val;\n        }\n    }\n    return min2;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdatxskhf.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdatxskhf.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdatxskhf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4yn94dr4.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp4yn94dr4.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp4yn94dr4.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4yn94dr4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_js_k1md.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp_js_k1md.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp_js_k1md.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xa7dde554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long next = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ next = min;\n            min = e;\n        }\n        else if (e < next)\n \
    \       {\n            next = e;\n        }\n    }\n    if (min == next)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(next);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqs2e2yfe.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpqs2e2yfe.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpqs2e2yfe.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x20dfb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long next_min =\
    \ lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n \
    \           next_min = min;\n            min = e;\n        }\n        else if\
    \ (e < next_min)\n        {\n            next_min = e;\n        }\n    }\n   \
    \ return next_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0dpzi4nd.d(33): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp0dpzi4nd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long smallest = lst[0];\n    long second_smallest = long.max;\n \
    \   foreach (i; lst) \n    {\n        if (i < smallest) \n        {\n        \
    \    second_smallest = smallest;\n            smallest = i;\n        }\n     \
    \   else if (i < second_smallest) \n        {\n            second_smallest = i;\n\
    \        }\n    }\n    if (second_smallest == long.max) return null;\n    return\
    \ second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgdjs0egk.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgdjs0egk.d(32): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpgdjs0egk.d(33): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpgdjs0egk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long second_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e\
    \ < min) \n        {\n            second_min = min;\n            min = e;\n  \
    \      }\n        else if (e < second_min) \n        {\n            second_min\
    \ = e;\n        }\n    }\n    if (min == second_min) \n    {\n        return Nullable!(long).init;\n\
    \    }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy27syjje.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpy27syjje.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpposk109n.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpposk109n.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpposk109n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\
    \ \n    {\n        if (v < min) \n        {\n            min2 = min;\n       \
    \     min = v;\n        }\n        else if (v < min2) \n        {\n          \
    \  min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8aeodtb6.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp8aeodtb6.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8aeodtb6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long next_min =\
    \ lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n \
    \           next_min = min;\n            min = e;\n        }\n        else if\
    \ (e < next_min)\n        {\n            next_min = e;\n        }\n    }\n   \
    \ return Nullable!(long)(next_min);\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5o9fi8lf.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp5o9fi8lf.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmp5o9fi8lf.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0xcc6f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long next_min = lst[1];\n    for (long i = 1; i < lst.length; i++) \n   \
    \ {\n        if (lst[i] < min) \n        {\n            next_min = min;\n    \
    \        min = lst[i];\n        }\n        else if (lst[i] < next_min) \n    \
    \    {\n            next_min = lst[i];\n        }\n    }\n    if (min == next_min)\
    \ \n    {\n        return Nullable!(long).init;\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0g07vcxo.d(39): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp0g07vcxo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next_min = lst[1];\n    foreach (i,\
    \ e; lst) \n    {\n        if (e < min) \n        {\n            next_min = min;\n\
    \            min = e;\n        } \n        else if (e < next_min) \n        {\n\
    \            next_min = e;\n        }\n    }\n    return next_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_n_2i_ut.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_n_2i_ut.d(32): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n_2i_ut.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpex60jdql.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpex60jdql.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpex60jdql.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpex60jdql.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ second = min;\n            min = v;\n        }\n        else if (v < second)\n\
    \        {\n            second = v;\n        }\n    }\n    if (min == second)\n\
    \        return Nullable!(long)();\n    return Nullable!(long)(second);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp69wu0797.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp69wu0797.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp69wu0797.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x505dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long smallest = lst[0];\n    long next_smallest = lst[1];\n    foreach\
    \ (i, e; lst) \n    {\n        if (e < smallest) \n        {\n            next_smallest\
    \ = smallest;\n            smallest = e;\n        }\n        else if (e < next_smallest)\
    \ \n        {\n            next_smallest = e;\n        }\n    }\n    if (smallest\
    \ == next_smallest) return null;\n    return next_smallest;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplwwd8wjw.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmplwwd8wjw.d(32): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmplwwd8wjw.d(33): Error: cannot implicitly convert expression `next_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplwwd8wjw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    else\n    {\n        long min = lst[0];\n\
    \        long min2 = lst[1];\n        foreach (i; lst)\n        {\n          \
    \  if (i < min)\n            {\n                min2 = min;\n                min\
    \ = i;\n            }\n            else if (i < min2)\n                min2 =\
    \ i;\n        }\n        return Nullable!(long)(min2);\n    }\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr_r02ltt.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmpr_r02ltt.__unittest_L36_C1()\
    \ [0x44187e]\\n??:? void tmpr_r02ltt.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x12937554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdbdgxx18.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpdbdgxx18.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpdbdgxx18.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x1f944554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       second_min = min;\n            min = e;\n        }\n        else if (e\
    \ < second_min)\n        {\n            second_min = e;\n        }\n    }\n  \
    \  \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj7w3ub2u.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpj7w3ub2u.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpj7w3ub2u.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpj7w3ub2u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length <= 1)\n\
    \        return null;\n    long min = lst[0];\n    long next_min = long.max;\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n        {\n            next_min\
    \ = min;\n            min = i;\n        }\n        else if (i < next_min)\n  \
    \      {\n            next_min = i;\n        }\n    }\n    if (next_min == long.max)\n\
    \        return null;\n    return next_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_6fmjlzy.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_6fmjlzy.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp_6fmjlzy.d(35): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_6fmjlzy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqtvscn4z.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpqtvscn4z.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqtvscn4z.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        } \n        else if (e < min2) \n        {\n         \
    \   min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1s0uzepk.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1s0uzepk.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1s0uzepk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i, val; lst)\n    {\n        if (val < min)\n      \
    \  {\n            second_min = min;\n            min = val;\n        }\n     \
    \   else if (val < second_min)\n        {\n            second_min = val;\n   \
    \     }\n    }\n    if (min == second_min)\n        return Nullable!(long)();\n\
    \    return Nullable!(long)(second_min);\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6qjz3aln.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp6qjz3aln.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp6qjz3aln.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x24973554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    for\
    \ (long i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n      \
    \  {\n            min2 = min;\n            min = lst[i];\n        }\n        else\
    \ if (lst[i] < min2)\n        {\n            min2 = lst[i];\n        }\n    }\n\
    \    if (min == min2)\n        return null;\n    return min2;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsr6k74ag.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpsr6k74ag.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpsr6k74ag.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsr6k74ag.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    for\
    \ (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n       \
    \ {\n            min2 = min;\n            min = lst[i];\n        }\n        else\
    \ if (lst[i] < min2)\n        {\n            min2 = lst[i];\n        }\n    }\n\
    \    if (min == min2)\n        return null;\n    return min2;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps7791ovm.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmps7791ovm.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmps7791ovm.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmps7791ovm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    auto min = lst[0];\n\
    \    auto second_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e\
    \ < min) \n        {\n            second_min = min;\n            min = e;\n  \
    \      } \n        else if (e < second_min) \n        {\n            second_min\
    \ = e;\n        }\n    }\n    if (min == second_min) \n    {\n        return Nullable!(long).init;\n\
    \    }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6su72izw.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6su72izw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long smallest = lst[0];\n    long second_smallest =\
    \ lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < smallest)\n       \
    \ {\n            second_smallest = smallest;\n            smallest = e;\n    \
    \    }\n        else if (e < second_smallest)\n        {\n            second_smallest\
    \ = e;\n        }\n    }\n    if (smallest == second_smallest)\n        return\
    \ null;\n    return second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvae36e5q.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpvae36e5q.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpvae36e5q.d(35): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpvae36e5q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8pu06o82.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp8pu06o82.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp8pu06o82.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x3dbb9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfvhxai1r.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpfvhxai1r.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpfvhxai1r.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfvhxai1r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst) \n    {\n        if (v < min) \n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2) \n        {\n   \
    \         min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7hsyqsge.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp7hsyqsge.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7hsyqsge.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1r48xmjt.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp1r48xmjt.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp1r48xmjt.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1r48xmjt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeob8cbt1.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpeob8cbt1.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpeob8cbt1.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpeob8cbt1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n         \
    \   second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\
    \ \n        {\n            second_min = e;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsl8902l0.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpsl8902l0.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpsl8902l0.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpsl8902l0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdiplzpjc.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdiplzpjc.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpdiplzpjc.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpdiplzpjc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8xnqv2bn.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp8xnqv2bn.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmp8xnqv2bn.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0xfc37e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqd3lc3ao.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpqd3lc3ao.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpqd3lc3ao.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x267ac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdooq_s_t.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdooq_s_t.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdooq_s_t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst) \n    {\n        if (e < min) \n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2) \n        {\n   \
    \         min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ud78_vv.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6ud78_vv.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ud78_vv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            second = min;\n\
    \            min = v;\n        }\n        else if (v < second)\n        {\n  \
    \          second = v;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3_b85ho.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu3_b85ho.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpu3_b85ho.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpu3_b85ho.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8zln54p6.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp8zln54p6.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmp8zln54p6.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x1b7a9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplbe9g9uz.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmplbe9g9uz.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmplbe9g9uz.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplbe9g9uz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long next_min\
    \ = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n\
    \            next_min = min;\n            min = e;\n        }\n        else if\
    \ (e < next_min) \n        {\n            next_min = e;\n        }\n    }\n  \
    \  if (min == next_min) \n    {\n        return null;\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpt7kb4y.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpmpt7kb4y.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpmpt7kb4y.d(39): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpmpt7kb4y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    auto min = lst[0];\n\
    \    auto second_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e\
    \ < min) \n        {\n            second_min = min;\n            min = e;\n  \
    \      }\n        else if (e < second_min) \n        {\n            second_min\
    \ = e;\n        }\n    }\n    if (min == second_min) \n    {\n        return Nullable!(long).init;\n\
    \    }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprd0jc_9b.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmprd0jc_9b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\n\
    \    {\n        if (v < min)\n        {\n            min2 = min;\n           \
    \ min = v;\n        }\n        else if (v < min2)\n        {\n            min2\
    \ = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzjjfkbtw.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpzjjfkbtw.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjjfkbtw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long second_min\
    \ = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n\
    \            second_min = min;\n            min = e;\n        } \n        else\
    \ if (e < second_min) \n        {\n            second_min = e;\n        }\n  \
    \  }\n    return second_min;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxfg3xeet.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxfg3xeet.d(35): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxfg3xeet.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6jbok0yl.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6jbok0yl.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp6jbok0yl.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6jbok0yl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\n\
    \        {\n            second_min = e;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxm94uqc5.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpxm94uqc5.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpxm94uqc5.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxm94uqc5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n\
    \        {\n            min2 = e;\n        }\n    }\n    \n    return min2;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4aq59w4_.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp4aq59w4_.d(36): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4aq59w4_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min2 < min)\n    {\n        min = min2;\n        min2 = lst[0];\n    }\n  \
    \  foreach (i; lst[2..$])\n    {\n        if (i < min)\n        {\n          \
    \  min2 = min;\n            min = i;\n        }\n        else if (i < min2)\n\
    \        {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_zcweape.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_zcweape.d(38): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_zcweape.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp115tmwih.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp115tmwih.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp115tmwih.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp115tmwih.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ min2 = min;\n            min = v;\n        }\n        else if (v < min2)\n \
    \       {\n            min2 = v;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0a2ks2if.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp0a2ks2if.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmp0a2ks2if.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x7a9a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next_min = lst[1];\n    foreach (i,\
    \ e; lst) \n    {\n        if (e < min) \n        {\n            next_min = min;\n\
    \            min = e;\n        }\n        else if (e < next_min) \n        {\n\
    \            next_min = e;\n        }\n    }\n    return next_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpinzkeytp.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpinzkeytp.d(32): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpinzkeytp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbvy4nlr9.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpbvy4nlr9.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpbvy4nlr9.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpbvy4nlr9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz77kd1o5.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpz77kd1o5.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz77kd1o5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = minElement(lst);\n    long\
    \ min2 = min;\n    foreach (e; lst) \n    {\n        if (e != min && e < min2)\
    \ \n        {\n            min2 = e;\n        }\n    }\n    if (min2 == min) \n\
    \    {\n        return null;\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2c982ha8.d(21): Error: undefined identifier `minElement`\\n/tmp/tmp2c982ha8.d(19):\
    \ Error: cannot implicitly convert expression `null` of type `typeof(null)` to\
    \ `Nullable!long`\\n/tmp/tmp2c982ha8.d(32): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp2c982ha8.d(34): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2c982ha8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpslaajbm1.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpslaajbm1.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpslaajbm1.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpslaajbm1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk85girbh.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpk85girbh.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk85girbh.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    \n    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n   \
    \         min2 = min;\n            min = e;\n        }\n        else if (e < min2)\
    \ \n        {\n            min2 = e;\n        }\n    }\n    \n    return min2;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87duqs1g.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp87duqs1g.d(36): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp87duqs1g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, x; lst)\n    {\n        if (x < min)\n        {\n           \
    \ second_min = min;\n            min = x;\n        }\n        else if (x < second_min)\n\
    \        {\n            second_min = x;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplggdmfum.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmplggdmfum.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmplggdmfum.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplggdmfum.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp99luent5.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp99luent5.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp99luent5.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp99luent5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\
    \ \n    {\n        if (v < min) \n        {\n            min2 = min;\n       \
    \     min = v;\n        }\n        else if (v < min2) \n        {\n          \
    \  min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp17wh0au3.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp17wh0au3.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17wh0au3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = minElement(lst);\n    long min2 = long.max;\n\
    \    foreach (i; lst)\n    {\n        if (i != min && i < min2)\n            min2\
    \ = i;\n    }\n    if (min2 == long.max)\n        return null;\n    return min2;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnz92co9a.d(19): Error: undefined identifier `minElement`\\n/tmp/tmpnz92co9a.d(18):\
    \ Error: cannot implicitly convert expression `null` of type `typeof(null)` to\
    \ `Nullable!long`\\n/tmp/tmpnz92co9a.d(27): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpnz92co9a.d(28): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnz92co9a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprcptk_6i.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprcptk_6i.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprcptk_6i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long second =\
    \ lst[1];\n    foreach (i; lst) \n    {\n        if (i < min) \n        {\n  \
    \          second = min;\n            min = i;\n        }\n        else if (i\
    \ < second) \n        {\n            second = i;\n        }\n    }\n    return\
    \ second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n       \
    \ auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphu8mh9yv.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmphu8mh9yv.d(35): Error: cannot\
    \ implicitly convert expression `second` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphu8mh9yv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\n\
    \    {\n        if (v < min)\n        {\n            min2 = min;\n           \
    \ min = v;\n        }\n        else if (v < min2)\n        {\n            min2\
    \ = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpumb1z8gf.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpumb1z8gf.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpumb1z8gf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long next_min =\
    \ lst[1];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i]\
    \ < min)\n        {\n            next_min = min;\n            min = lst[i];\n\
    \        }\n        else if (lst[i] < next_min)\n        {\n            next_min\
    \ = lst[i];\n        }\n    }\n    if (min == next_min)\n        return Nullable!(long)();\n\
    \    return Nullable!(long)(next_min);\n}\nunittest\n{\n    alias candidate =\
    \ next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\
    \ \n    {\n        if (v < min) \n        {\n            min2 = min;\n       \
    \     min = v;\n        } \n        else if (v < min2) \n        {\n         \
    \   min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnj8ghaol.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpnj8ghaol.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnj8ghaol.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long second = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            second = min;\n            min = e;\n        }\n  \
    \      else if (e < second) \n        {\n            second = e;\n        }\n\
    \    }\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_1j4y8no.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_1j4y8no.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    \n    long min = lst[0];\n    long min2\
    \ = lst[1];\n    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n    \
    \    {\n            min2 = min;\n            min = e;\n        }\n        else\
    \ if (e < min2)\n        {\n            min2 = e;\n        }\n    }\n    \n  \
    \  return Nullable!(long)(min2);\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5tf3397n.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp5tf3397n.__unittest_L38_C1()\
    \ [0x44187e]\\n??:? void tmp5tf3397n.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x7f339554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n         \
    \   second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\
    \ \n        {\n            second_min = e;\n        }\n    }\n    return second_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgteul102.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgteul102.d(33): Error: cannot\
    \ implicitly convert expression `second_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgteul102.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            second = min;\n\
    \            min = v;\n        }\n        else if (v < second)\n        {\n  \
    \          second = v;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_970gb3b.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp_970gb3b.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp_970gb3b.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_970gb3b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpujqlcfgf.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpujqlcfgf.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpujqlcfgf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long smallest = lst[0];\n    long second_smallest =\
    \ lst[1];\n    foreach (i, e; lst)\n    {\n        if (e < smallest)\n       \
    \ {\n            second_smallest = smallest;\n            smallest = e;\n    \
    \    }\n        else if (e < second_smallest)\n        {\n            second_smallest\
    \ = e;\n        }\n    }\n    if (smallest == second_smallest)\n        return\
    \ null;\n    return second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjroueaco.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjroueaco.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpjroueaco.d(35): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjroueaco.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i; lst) \n    {\n        if (i < min) \n        {\n            min2\
    \ = min;\n            min = i;\n        } \n        else if (i < min2) \n    \
    \    {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpve9wx439.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpve9wx439.d(35): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpve9wx439.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length <= 1)\n\
    \        return null;\n    auto min = lst[0];\n    auto second_min = long.max;\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n        {\n            second_min\
    \ = min;\n            min = i;\n        }\n        else if (i < second_min)\n\
    \        {\n            second_min = i;\n        }\n    }\n    if (second_min\
    \ == long.max)\n        return null;\n    return second_min;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4os_kr4l.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp4os_kr4l.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp4os_kr4l.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4os_kr4l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i; lst) \n    {\n        if (i < min) \n        {\n            min2\
    \ = min;\n            min = i;\n        }\n        else if (i < min2) \n     \
    \   {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkjltnzkx.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkjltnzkx.d(35): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkjltnzkx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            next = min;\n       \
    \     min = e;\n        } \n        else if (e < next) \n        {\n         \
    \   next = e;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp980cln8g.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp980cln8g.d(32): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp980cln8g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min2 < min)\n    {\n        min = min2;\n        min2 = lst[0];\n    }\n  \
    \  foreach (i; lst[2..$])\n    {\n        if (i < min)\n        {\n          \
    \  min2 = min;\n            min = i;\n        }\n        else if (i < min2)\n\
    \        {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu__qsnne.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpu__qsnne.d(38): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu__qsnne.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long smallest = lst[0];\n\
    \    long second_smallest = lst[1];\n    foreach (i, e; lst) \n    {\n       \
    \ if (e < smallest) \n        {\n            second_smallest = smallest;\n   \
    \         smallest = e;\n        }\n        else if (e < second_smallest) \n \
    \       {\n            second_smallest = e;\n        }\n    }\n    if (smallest\
    \ == second_smallest) \n    {\n        return Nullable!(long).init;\n    }\n \
    \   return second_smallest;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprdzwtbyg.d(39): Error: cannot implicitly convert expression `second_smallest`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmprdzwtbyg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        } \n        else if (e < min2) \n        {\n         \
    \   min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo3bdx5bq.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpo3bdx5bq.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3bdx5bq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptlooc5f5.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmptlooc5f5.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmptlooc5f5.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptlooc5f5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi56191w6.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpi56191w6.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi56191w6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpolnm346i.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpolnm346i.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpolnm346i.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpolnm346i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long next_min = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e <\
    \ min) \n        {\n            next_min = min;\n            min = e;\n      \
    \  } \n        else if (e < next_min) \n        {\n            next_min = e;\n\
    \        }\n    }\n    return next_min;\n}\nunittest\n{\n    alias candidate =\
    \ next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk2kp9jh3.d(35): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpk2kp9jh3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph_6xvn0e.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmph_6xvn0e.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmph_6xvn0e.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmph_6xvn0e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            next = min;\n           \
    \ min = e;\n        }\n        else if (e < next)\n        {\n            next\
    \ = e;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3qowexe3.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3qowexe3.d(32): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3qowexe3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, v; lst)\n\
    \    {\n        if (v < min)\n        {\n            min2 = min;\n           \
    \ min = v;\n        }\n        else if (v < min2)\n        {\n            min2\
    \ = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq1wcg_g5.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpq1wcg_g5.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq1wcg_g5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg232rict.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpg232rict.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpg232rict.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg232rict.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        }\n    \
    \    else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi4xhxiqp.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpi4xhxiqp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm2zdne8m.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpm2zdne8m.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpm2zdne8m.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpm2zdne8m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    if (min2 < min)\n\
    \    {\n        min = min2;\n        min2 = lst[0];\n    }\n    foreach (i, e;\
    \ lst[2..$])\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy3ei7y3b.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpy3ei7y3b.d(37): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy3ei7y3b.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ second_min = min;\n            min = e;\n        }\n        else if (e < second_min)\n\
    \        {\n            second_min = e;\n        }\n    }\n    if (min == second_min)\n\
    \        return null;\n    return second_min;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf4fwkos9.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpf4fwkos9.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpf4fwkos9.d(35): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpf4fwkos9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdwv6xct8.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpdwv6xct8.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpdwv6xct8.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpdwv6xct8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n           \
    \ next_min = min;\n            min = e;\n        } \n        else if (e < next_min)\
    \ \n        {\n            next_min = e;\n        }\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl7ag_3nd.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpl7ag_3nd.d(33): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl7ag_3nd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, v; lst)\n    {\n        if (v < min)\n        {\n           \
    \ min2 = min;\n            min = v;\n        }\n        else if (v < min2)\n \
    \       {\n            min2 = v;\n        }\n    }\n    if (min == min2)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8qogk67h.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp8qogk67h.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp8qogk67h.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x68b26554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpufpanzh3.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpufpanzh3.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpufpanzh3.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x706d2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long next_min\
    \ = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n\
    \            next_min = min;\n            min = e;\n        }\n        else if\
    \ (e < next_min) \n        {\n            next_min = e;\n        }\n    }\n  \
    \  if (min == next_min) \n    {\n        return null;\n    }\n    return next_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptk5_lzpp.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmptk5_lzpp.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmptk5_lzpp.d(39): Error: cannot implicitly convert expression `next_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmptk5_lzpp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\
    \ \n    {\n        if (e < min) \n        {\n            min2 = min;\n       \
    \     min = e;\n        }\n        else if (e < min2) \n        {\n          \
    \  min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppv22asu1.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmppv22asu1.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppv22asu1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return Nullable!(long).init;\n    }\n    long min = lst[0];\n\
    \    long min2 = lst[1];\n    foreach (i, e; lst) \n    {\n        if (e < min)\
    \ \n        {\n            min2 = min;\n            min = e;\n        } \n   \
    \     else if (e < min2) \n        {\n            min2 = e;\n        }\n    }\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpet2_xgqg.d(35): Error: cannot implicitly convert expression `min2`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpet2_xgqg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    if (min > min2)\n    {\n        min = min2;\n        min2 = lst[0];\n   \
    \ }\n    foreach (i, x; lst[2..$])\n    {\n        if (x < min)\n        {\n \
    \           min2 = min;\n            min = x;\n        }\n        else if (x <\
    \ min2)\n        {\n            min2 = x;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq1_dxxeg.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455b09]\\n??:? void tmpq1_dxxeg.__unittest_L40_C1()\
    \ [0x4419fa]\\n??:? void tmpq1_dxxeg.__modtest() [0x453618]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x455136]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a34d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2d9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x45510d]\\n??:? runModuleUnitTests [0x45e8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a94]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a1b]\\n??:? _d_run_main [0x456986]\\n??:? main [0x4536eb]\\\
    n??:? __libc_start_main [0xffd3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       second_min = min;\n            min = e;\n        }\n        else if (e\
    \ < second_min)\n        {\n            second_min = e;\n        }\n    }\n  \
    \  \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprzoccmtc.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprzoccmtc.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmprzoccmtc.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmprzoccmtc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i; lst) \n    {\n        if (i < min) \n        {\n            min2\
    \ = min;\n            min = i;\n        } \n        else if (i < min2) \n    \
    \    {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3dtujblq.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp3dtujblq.d(35): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dtujblq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    return Nullable!(long)(min2);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp629pa3ny.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmp629pa3ny.__unittest_L35_C1()\
    \ [0x44187e]\\n??:? void tmp629pa3ny.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x132e2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb2qnboss.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpb2qnboss.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpb2qnboss.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpb2qnboss.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ddig30t.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp7ddig30t.d(33): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ddig30t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) \n\
    \    {\n        return null;\n    }\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i; lst) \n    {\n        if (i < min) \n        {\n            min2\
    \ = min;\n            min = i;\n        } \n        else if (i < min2) \n    \
    \    {\n            min2 = i;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6b7gcgia.d(19): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp6b7gcgia.d(35): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6b7gcgia.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       second_min = min;\n            min = e;\n        }\n        else if (e\
    \ < second_min)\n        {\n            second_min = e;\n        }\n    }\n  \
    \  \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpef7v0_ja.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpef7v0_ja.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpef7v0_ja.d(39): Error: cannot implicitly convert expression `second_min`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpef7v0_ja.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min > min2)\n    {\n        min = min2;\n        min2 = lst[0];\n    }\n  \
    \  foreach (i, e; lst[2..$])\n    {\n        if (e < min)\n        {\n       \
    \     min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n\
    \        {\n            min2 = e;\n        }\n    }\n    return min2;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp80awiqdt.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp80awiqdt.d(38): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80awiqdt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, val;\
    \ lst) \n    {\n        if (val < min) \n        {\n            min2 = min;\n\
    \            min = val;\n        } \n        else if (val < min2) \n        {\n\
    \            min2 = val;\n        }\n    }\n    return min2;\n}\nunittest\n{\n\
    \    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpieuwj2gq.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpieuwj2gq.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpieuwj2gq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr33m45lr.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpr33m45lr.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpr33m45lr.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpr33m45lr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min1 = lst[0];\n    long min2 = lst[1];\n    if\
    \ (min1 > min2)\n        swap(min1, min2);\n    foreach (i, e; lst[2..$])\n  \
    \  {\n        if (e < min1)\n        {\n            min2 = min1;\n           \
    \ min1 = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkvzbjnec.d(22): Error: undefined identifier `swap`, did you mean\
    \ template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable,\
    \ Targets))`?\\n/tmp/tmpkvzbjnec.d(18): Error: cannot implicitly convert expression\
    \ `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpkvzbjnec.d(35): Error:\
    \ cannot implicitly convert expression `min2` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvzbjnec.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long second = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            second = min;\n\
    \            min = e;\n        }\n        else if (e < second)\n        {\n  \
    \          second = e;\n        }\n    }\n    if (min == second)\n        return\
    \ null;\n    return second;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\
    \n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqyslyizn.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpqyslyizn.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpqyslyizn.d(35): Error: cannot implicitly convert expression `second`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpqyslyizn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach (i, v; lst)\n\
    \    {\n        if (v < min)\n        {\n            next = min;\n           \
    \ min = v;\n        }\n        else if (v < next)\n        {\n            next\
    \ = v;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw0_qhrua.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpw0_qhrua.d(32): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0_qhrua.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min == min2)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaviav8f2.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpaviav8f2.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpaviav8f2.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x7c5b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long next = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            next = min;\n\
    \            min = v;\n        }\n        else if (v < next)\n        {\n    \
    \        next = v;\n        }\n    }\n    return next;\n}\nunittest\n{\n    alias\
    \ candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L,\
    \ 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjxfyb586.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjxfyb586.d(33): Error: cannot\
    \ implicitly convert expression `next` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjxfyb586.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, e; lst)\n    {\n        if (e < min)\n        {\n            min2 = min;\n\
    \            min = e;\n        }\n        else if (e < min2)\n        {\n    \
    \        min2 = e;\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj1au5fl3.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpj1au5fl3.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpj1au5fl3.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpj1au5fl3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n \
    \       {\n            min2 = e;\n        }\n    }\n    if (min2 == min)\n   \
    \     return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcqzmvug1.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmpcqzmvug1.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmpcqzmvug1.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0xba23a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach\
    \ (i, v; lst)\n    {\n        if (v < min)\n        {\n            min2 = min;\n\
    \            min = v;\n        }\n        else if (v < min2)\n        {\n    \
    \        min2 = v;\n        }\n    }\n    if (min == min2)\n        return null;\n\
    \    return min2;\n}\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n\
    \        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L,\
    \ 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n   \
    \     auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n \
    \       auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\
    \n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5666ks7s.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp5666ks7s.d(34): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmp5666ks7s.d(35): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5666ks7s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long min2 = lst[1];\n    foreach (i, e; lst)\n\
    \    {\n        if (e < min)\n        {\n            min2 = min;\n           \
    \ min = e;\n        }\n        else if (e < min2)\n        {\n            min2\
    \ = e;\n        }\n    }\n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl9lmdjai.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpl9lmdjai.d(32): Error: cannot\
    \ implicitly convert expression `min2` of type `long` to `Nullable!long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl9lmdjai.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next_min = lst[1];\n    foreach (i,\
    \ v; lst) \n    {\n        if (v < min) \n        {\n            next_min = min;\n\
    \            min = v;\n        }\n        else if (v < next_min) \n        {\n\
    \            next_min = v;\n        }\n    }\n    return next_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9985keu1.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp9985keu1.d(32): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9985keu1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ Nullable!(long)();\n    long min = lst[0];\n    long next_min = lst[1];\n  \
    \  foreach (i, e; lst) \n    {\n        if (e < min) \n        {\n           \
    \ next_min = min;\n            min = e;\n        }\n        else if (e < next_min)\
    \ \n        {\n            next_min = e;\n        }\n    }\n    return Nullable!(long)(next_min);\n\
    }\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
    \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n  \
    \      assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto\
    \ result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull &&\
    \ result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n   \
    \     assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L,\
    \ 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsut2vu_o.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455ab1]\\n??:? void tmpsut2vu_o.__unittest_L34_C1()\
    \ [0x44187e]\\n??:? void tmpsut2vu_o.__modtest() [0x4535c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4550de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a2f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a384]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a281]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550b5]\\n??:? runModuleUnitTests [0x45e889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a3c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4569c3]\\n??:? _d_run_main [0x45692e]\\n??:? main [0x453693]\\\
    n??:? __libc_start_main [0x53268554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2) return\
    \ null;\n    long min = lst[0];\n    long next_min = lst[1];\n    foreach (i,\
    \ e; lst)\n    {\n        if (e < min)\n        {\n            next_min = min;\n\
    \            min = e;\n        }\n        else if (e < next_min)\n        {\n\
    \            next_min = e;\n        }\n    }\n    return next_min;\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpph4b4ayu.d(17): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpph4b4ayu.d(32): Error: cannot\
    \ implicitly convert expression `next_min` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpph4b4ayu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return null;\n    \n    long min = lst[0];\n    long min2 = lst[1];\n\
    \    \n    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n     \
    \       min2 = min;\n            min = e;\n        }\n        else if (e < min2)\n\
    \        {\n            min2 = e;\n        }\n    }\n    \n    if (min2 == min)\n\
    \        return null;\n    \n    return min2;\n}\nunittest\n{\n    alias candidate\
    \ = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n\
    \        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L,\
    \ 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\
    \n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyo8yilak.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpyo8yilak.d(37): Error: cannot\
    \ implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    n/tmp/tmpyo8yilak.d(39): Error: cannot implicitly convert expression `min2` of\
    \ type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyo8yilak.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the list.\n    Return None if there is no such element.\n    \n \
    \   next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) ==\
    \ 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \n\
    */\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n \
    \       return Nullable!(long)();\n    long min = lst[0];\n    long second = lst[1];\n\
    \    foreach (i, e; lst)\n    {\n        if (e < min)\n        {\n           \
    \ second = min;\n            min = e;\n        }\n        else if (e < second)\n\
    \        {\n            second = e;\n        }\n    }\n    if (min == second)\n\
    \        return Nullable!(long)();\n    return Nullable!(long)(second);\n}\nunittest\n\
    {\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n\
    {\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull\
    \ && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n      \
    \  assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n\
    \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L,\
    \ 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n\
    {\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
    \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7y293l3h.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x455af1]\\n??:? void tmp7y293l3h.__unittest_L37_C1()\
    \ [0x4418ba]\\n??:? void tmp7y293l3h.__modtest() [0x4535fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x45eaf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x45511e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x45a335]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x45a3c4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x45a2c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4550f5]\\n??:? runModuleUnitTests [0x45e8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x456a7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x456a03]\\n??:? _d_run_main [0x45696e]\\n??:? main [0x4536cf]\\\
    n??:? __libc_start_main [0x8569b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
