name: HumanEval_153_Strongest_Extension
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max_strength = 0;\n    string strongest_extension = \"\";\n\
    \    foreach(string extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphlmzu11t.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmphlmzu11t.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphlmzu11t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength += 1;\n            else\n                strength -= 1;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf2_vhhv.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjf2_vhhv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    float strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float cap = 0;\n        float sm = 0;\n   \
    \     foreach(char c; ext)\n        {\n            if(c.isUpper)\n           \
    \     cap++;\n            else\n                sm++;\n        }\n        float\
    \ cur_strength = cap - sm;\n        if(cur_strength > strength)\n        {\n \
    \           strength = cur_strength;\n            strongest = ext;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppuudbhlj.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppuudbhlj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2_0lw2q3.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp2_0lw2q3.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_0lw2q3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(ch;\
    \ extension)\n        {\n            if(ch.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphr5k9m8v.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphr5k9m8v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int[string] strength;\n    foreach(ext; extensions)\n    {\n      \
    \  int cap = 0;\n        int sm = 0;\n        foreach(c; ext)\n        {\n   \
    \         if(c.isUpper)\n                cap++;\n            else\n          \
    \      sm++;\n        }\n        strength[ext] = cap - sm;\n    }\n    string\
    \ strongest = extensions[0];\n    foreach(ext; extensions)\n    {\n        if(strength[ext]\
    \ > strength[strongest])\n            strongest = ext;\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmzboe6ee.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmzboe6ee.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpofntoege.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpofntoege.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg43oz6xz.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg43oz6xz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = \"\";\n    double max = 0;\n    foreach(string ext;\
    \ extensions)\n    {\n        double strength = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                strength++;\n         \
    \   else if(c.isLower)\n                strength--;\n        }\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjbe68v4l.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpjbe68v4l.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjbe68v4l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > strongest_extension_strength)\n        {\n   \
    \         strongest_extension_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyis_oz34.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyis_oz34.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double cap = 0;\n        double sm =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        double current_strength = cap - sm;\n        if(current_strength > strength)\n\
    \        {\n            strength = current_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpehf7moua.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpehf7moua.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxsi3h9d7.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpxsi3h9d7.d(32): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxsi3h9d7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv6ls8k93.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv6ls8k93.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float maxStrength = float.min;\n    string strongestExtension = \"\"\
    ;\n    foreach(extension; extensions)\n    {\n        float strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > maxStrength)\n        {\n            maxStrength\
    \ = strength;\n            strongestExtension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo9bixv93.d(23): Error: no property `min` for type `float`\\n/tmp/tmpo9bixv93.d(30):\
    \ Error: no property `isUpper` for type `char`\\n/tmp/tmpo9bixv93.d(32): Error:\
    \ no property `isLower` for type `char`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpo9bixv93.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = class_name;\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double ext_strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                ext_strength\
    \ += 1;\n            else\n                ext_strength -= 1;\n        }\n   \
    \     if(abs(ext_strength) > abs(strength))\n        {\n            strength =\
    \ ext_strength;\n            result = class_name ~ \".\" ~ ext;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpky1q1eux.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpky1q1eux.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int maxStrength = 0;\n    string strongestExtension = \"\";\n    foreach(string\
    \ extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > maxStrength)\n        {\n            maxStrength = strength;\n\
    \            strongestExtension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongestExtension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp92zr0kjs.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp92zr0kjs.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp92zr0kjs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cap = 0;\n        double sm = 0;\n \
    \       foreach(char c; ext)\n        {\n            if(c.isUpper)\n         \
    \       cap++;\n            else if(c.isLower)\n                sm++;\n      \
    \  }\n        double curr_strength = cap - sm;\n        if(curr_strength > strength)\n\
    \        {\n            strength = curr_strength;\n            strongest = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_gmwj0uz.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp_gmwj0uz.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_gmwj0uz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk28qae4p.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk28qae4p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnsr7flc1.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnsr7flc1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(abs(strength)\
    \ > max_strength)\n        {\n            max_strength = abs(strength);\n    \
    \        strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiy4nou7q.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiy4nou7q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm5j1lfxi.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm5j1lfxi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = \"\";\n    double max_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   result = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy34pq3ge.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy34pq3ge.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength++;\n            else if(c.isLower)\n     \
    \           extension_strength--;\n        }\n        if(extension_strength >\
    \ strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnlkpcaox.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpnlkpcaox.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnlkpcaox.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4d6f9i9w.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4d6f9i9w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7vf2510h.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vf2510h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float strength = 0.0f;\n    string strongest = \"\";\n    foreach(string\
    \ ext; extensions)\n    {\n        float cur_strength = 0.0f;\n        foreach(char\
    \ c; ext)\n        {\n            if(isUpper(c))\n                cur_strength\
    \ += 1.0f;\n            else\n                cur_strength -= 1.0f;\n        }\n\
    \        if(cur_strength > strength)\n        {\n            strength = cur_strength;\n\
    \            strongest = ext;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprs5mpwsu.d(30): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprs5mpwsu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ -1;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz5f308e4.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpz5f308e4.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz5f308e4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq3ivzsqx.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpq3ivzsqx.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq3ivzsqx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppjasqe5x.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppjasqe5x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    auto strongest = extensions[0];\n    auto strongest_strength = 0;\n\
    \    foreach(extension; extensions)\n    {\n        auto strength = 0;\n     \
    \   foreach(c; extension)\n        {\n            if(c.isUpper)\n            \
    \    strength++;\n            else\n                strength--;\n        }\n \
    \       if(strength > strongest_strength)\n        {\n            strongest =\
    \ extension;\n            strongest_strength = strength;\n        }\n    }\n \
    \   return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ks11ebw.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ks11ebw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrtg6wou.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpcrtg6wou.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcrtg6wou.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double cap = 0;\n        double sm =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        double current_strength = cap - sm;\n        if(current_strength > strength)\n\
    \        {\n            strength = current_strength;\n            strongest =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8dk23x10.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8dk23x10.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuc6te4t7.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuc6te4t7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5atoxr6l.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp5atoxr6l.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5atoxr6l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    float strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float cap = 0;\n        float sm = 0;\n   \
    \     foreach(char c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n\
    \                cap++;\n            else if(c >= 'a' && c <= 'z')\n         \
    \       sm++;\n        }\n        float str = cap - sm;\n        if(str > strength)\n\
    \        {\n            strength = str;\n            strongest = ext;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo4wucjmb.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429265]\\n??:? void tmpo4wucjmb.__unittest_L45_C1()\
    \ [0x427f9f]\\n??:? void tmpo4wucjmb.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db3f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428fbe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9ed]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa7c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a979]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428f95]\\n??:? runModuleUnitTests [0x42d915]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4296b4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42963b]\\n??:? _d_run_main [0x4295a6]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0xe08e8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string res = \"\";\n    foreach(string s; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; s)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            res = s;\n     \
    \   }\n    }\n    return class_name ~ \".\" ~ res;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5nrksve7.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5nrksve7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu1lj8ha7.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpu1lj8ha7.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpu1lj8ha7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double cap = 0;\n        double sm =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        double curr_strength = cap - sm;\n        if(curr_strength\
    \ > strength)\n        {\n            strength = curr_strength;\n            strongest\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph1__mnmb.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmph1__mnmb.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph1__mnmb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(isUpper(c))\n   \
    \             strength++;\n            else if(isLower(c))\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdhudfiyj.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpdhudfiyj.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdhudfiyj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max = 0;\n    string result = \"\";\n    foreach(string ext;\
    \ extensions)\n    {\n        double strength = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                strength++;\n         \
    \   else\n                strength--;\n        }\n        if(strength > max)\n\
    \        {\n            max = strength;\n            result = class_name ~ \"\
    .\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnppt8369.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnppt8369.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcf52wv_3.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcf52wv_3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max = 0;\n    string res = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        double cap = 0;\n        double sm = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n                cap++;\n\
    \            else if(c >= 'a' && c <= 'z')\n                sm++;\n        }\n\
    \        double strength = cap - sm;\n        if(strength > max)\n        {\n\
    \            max = strength;\n            res = class_name + \".\" + ext;\n  \
    \      }\n    }\n    return res;\n}\n/*\nYou will be given a list of integers\
    \ and a number. You should find the sum of the\n    integers that are closest\
    \ to the given number.\n    For example, if you are given the list [1, 2, 3, 4,\
    \ 5] and the number 3, then\n    the sum of the numbers that are closest to 3\
    \ is 2 + 3 = 5.\n    Example:\n    for Closest_Sum([1, 2, 3, 4, 5], 3) == 5\n\
    */\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0xc5rieh.d(40): Error: invalid array operation `class_name +\
    \ \".\"` (possible missing [])\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0xc5rieh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    int index = 0;\n    int strength = 0;\n    foreach(i,\
    \ ext; extensions)\n    {\n        strength = 0;\n        foreach(c; ext)\n  \
    \      {\n            if(c.isUpper)\n                strength++;\n           \
    \ else\n                strength--;\n        }\n        if(strength > max)\n \
    \       {\n            max = strength;\n            index = i;\n        }\n  \
    \  }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n{\n   \
    \ alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\",\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpasyidup_.d(31): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpasyidup_.d(39): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpasyidup_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ts5qc4k.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp3ts5qc4k.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ts5qc4k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    float strongest_strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        float strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = extension;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpguslhyt8.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpguslhyt8.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpguslhyt8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ox7mq08.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ox7mq08.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpicyo0bz8.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpicyo0bz8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptg2ttwal.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmptg2ttwal.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptg2ttwal.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ar__a1m.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp2ar__a1m.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ar__a1m.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpah4b2nqn.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpah4b2nqn.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpah4b2nqn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(isUpper(c))\n   \
    \             strength++;\n            else if(isLower(c))\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6l0zycid.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmp6l0zycid.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6l0zycid.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjng8ol6y.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpjng8ol6y.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjng8ol6y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string s; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; s)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptyit2425.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptyit2425.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9r_ae7bn.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9r_ae7bn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float max_strength = 0;\n    string strongest_extension = \"\";\n \
    \   foreach(extension; extensions)\n    {\n        float strength = 0;\n     \
    \   foreach(c; extension)\n        {\n            if(c.isUpper)\n            \
    \    strength += 1;\n            else\n                strength -= 1;\n      \
    \  }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7_s05oz5.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7_s05oz5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = class_name;\n    double max_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            result = class_name ~ \".\" ~ ext;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5gwabwia.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp5gwabwia.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5gwabwia.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpna96t8re.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpna96t8re.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcbgo43kg.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpcbgo43kg.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcbgo43kg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int[] strength = new int[extensions.length];\n    int max = 0;\n  \
    \  int index = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n  \
    \      int cap = 0;\n        int sm = 0;\n        foreach (char c; extensions[i])\n\
    \        {\n            if (c >= 'A' && c <= 'Z')\n                cap++;\n  \
    \          else if (c >= 'a' && c <= 'z')\n                sm++;\n        }\n\
    \        strength[i] = cap - sm;\n        if (strength[i] > max)\n        {\n\
    \            max = strength[i];\n            index = i;\n        }\n    }\n  \
    \  return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe289ipa7.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42952d]\\n??:? void tmpe289ipa7.__unittest_L46_C1()\
    \ [0x428267]\\n??:? void tmpe289ipa7.__modtest() [0x428798]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e0bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x429286]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ad85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ae14]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ad11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42925d]\\n??:? runModuleUnitTests [0x42de91]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4299f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429977]\\n??:? _d_run_main [0x4298e2]\\n??:? main [0x4287ab]\\\
    n??:? __libc_start_main [0x3baed554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength += 1;\n            else\n                strength -=\
    \ 1;\n        }\n        if(strength > strongest_strength)\n        {\n      \
    \      strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6b_uip7e.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6b_uip7e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp54ohy2ic.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54ohy2ic.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdam_ke_b.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpdam_ke_b.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdam_ke_b.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int cap = 0;\n        int sm\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        int strength = cap - sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqofqqiok.d(31): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpqofqqiok.d(33): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqofqqiok.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string strongest = \"\";\n    foreach(string ext;\
    \ extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                cap++;\n    \
    \        else\n                sm++;\n        }\n        int strength = cap -\
    \ sm;\n        if(strength > max)\n        {\n            max = strength;\n  \
    \          strongest = ext;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n \
    \   assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2jj8olni.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2jj8olni.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max_strength = 0;\n    string strongest_extension = \"\";\n\
    \    foreach(extension; extensions)\n    {\n        double strength = 0;\n   \
    \     foreach(c; extension)\n        {\n            if(c.isUpper)\n          \
    \      strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptreo9ao_.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmptreo9ao_.d(32): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptreo9ao_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph3jb2eyj.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmph3jb2eyj.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmph3jb2eyj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string max_extension = \"\";\n    foreach(string\
    \ extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5bfdiws3.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp5bfdiws3.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bfdiws3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int cap = 0;\n\
    \        int sm = 0;\n        foreach(char c; extension)\n        {\n        \
    \    if(c.isUpper)\n                cap++;\n            else if(c.isLower)\n \
    \               sm++;\n        }\n        double strength = cap - sm;\n      \
    \  if(strength > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwcokdjj4.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpwcokdjj4.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwcokdjj4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmltped8b.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpmltped8b.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmltped8b.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(letter;\
    \ extension)\n        {\n            if(letter.isUpper)\n            {\n     \
    \           strength++;\n            }\n            else\n            {\n    \
    \            strength--;\n            }\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbrq4z6j5.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbrq4z6j5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzzj9t1yi.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzzj9t1yi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw6ovpujx.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw6ovpujx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_extension_strength\
    \ = -1.0f;\n    foreach(extension; extensions)\n    {\n        float extension_strength\
    \ = 0.0f;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \            {\n                extension_strength += 1.0f;\n            }\n \
    \           else if(c.isLower)\n            {\n                extension_strength\
    \ -= 1.0f;\n            }\n        }\n        if(extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = extension_strength;\n \
    \           strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ar0aez0.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmp3ar0aez0.d(34): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ar0aez0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double current_strength = 0;\n      \
    \  foreach(char c; extension)\n        {\n            if(c.isUpper)\n        \
    \        current_strength++;\n            else\n                current_strength--;\n\
    \        }\n        if(abs(current_strength) > strength)\n        {\n        \
    \    strength = abs(current_strength);\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2gczbi60.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2gczbi60.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = class_name;\n    double strength = 0.0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cur_strength = 0.0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                cur_strength++;\n\
    \            else\n                cur_strength--;\n        }\n        if(cur_strength\
    \ > strength)\n        {\n            strength = cur_strength;\n            result\
    \ = class_name ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph8cqqwyf.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph8cqqwyf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \            {\n                extension_strength++;\n            }\n       \
    \     else if(isLower(c))\n            {\n                extension_strength--;\n\
    \            }\n        }\n        if(extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = extension_strength;\n \
    \           strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbjl4lyzs.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpbjl4lyzs.d(34):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpbjl4lyzs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47u4lmj7.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp47u4lmj7.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47u4lmj7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cap = 0;\n        double sm = 0;\n \
    \       foreach(char c; ext)\n        {\n            if(c.isUpper)\n         \
    \       cap++;\n            else if(c.isLower)\n                sm++;\n      \
    \  }\n        double curr_strength = cap - sm;\n        if(curr_strength > strength)\n\
    \        {\n            strength = curr_strength;\n            strongest = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpetzlaojj.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpetzlaojj.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpetzlaojj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfw7yt96.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmptfw7yt96.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptfw7yt96.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int CAP = 0;\n       \
    \ int SM = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                CAP++;\n            else\n                SM++;\n        }\n\
    \        int strength = CAP - SM;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptx6g5ub3.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptx6g5ub3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2zr5pasw.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2zr5pasw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = \"\";\n    int max = 0;\n    foreach(string ext; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpftz3o52m.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpftz3o52m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyj3b42nf.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyj3b42nf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ -1;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi0egvyed.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpi0egvyed.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi0egvyed.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpow7iuyof.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpow7iuyof.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpow7iuyof.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpitaugb1d.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpitaugb1d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl50w8h5_.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpl50w8h5_.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl50w8h5_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1wsmy_qd.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp1wsmy_qd.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1wsmy_qd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int upper_case_count =\
    \ 0;\n        int lower_case_count = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n            {\n                upper_case_count++;\n\
    \            }\n            else if(c.isLower)\n            {\n              \
    \  lower_case_count++;\n            }\n        }\n        int strength = upper_case_count\
    \ - lower_case_count;\n        if(strength > max_strength)\n        {\n      \
    \      max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2_64vld6.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp2_64vld6.d(35): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_64vld6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_j_1fcxp.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmp_j_1fcxp.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_j_1fcxp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strongest_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7z29ywow.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp7z29ywow.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7z29ywow.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = extensions[0];\n    double strongest_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplumqqczn.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmplumqqczn.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplumqqczn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double cap = 0;\n        double sm =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        if(cap - sm > strength)\n        {\n            strength =\
    \ cap - sm;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnru27dya.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpnru27dya.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnru27dya.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ ext;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxxtsafqf.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxtsafqf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_extension_strength\
    \ = 0.0;\n    float extension_strength = 0.0;\n    foreach(extension; extensions)\n\
    \    {\n        extension_strength = 0.0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n            {\n                extension_strength\
    \ += 1.0;\n            }\n            else if(c.isLower)\n            {\n    \
    \            extension_strength -= 1.0;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxg_ds1qb.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpxg_ds1qb.d(35): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxg_ds1qb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkvm6o9ff.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvm6o9ff.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprbjgb55r.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmprbjgb55r.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprbjgb55r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnp_e9o1j.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnp_e9o1j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strongest_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbab6tfc.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpmbab6tfc.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbab6tfc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength += 1;\n            else\n                strength -=\
    \ 1;\n        }\n        if(strength > strongest_strength)\n        {\n      \
    \      strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm2qxwwgn.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm2qxwwgn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength += 1;\n            else\n                strength -=\
    \ 1;\n        }\n        if(strength > strongest_strength)\n        {\n      \
    \      strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6s7_j3g5.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6s7_j3g5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int cap = 0;\n        int sm\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        int strength = cap - sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprqbyf7f0.d(31): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmprqbyf7f0.d(33): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqbyf7f0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0.0f;\n    foreach(extension; extensions)\n    {\n        float strength = 0.0f;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength += 1.0f;\n            else if(c.isLower)\n           \
    \     strength -= 1.0f;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdd7e4y5k.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpdd7e4y5k.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdd7e4y5k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    auto strongest = 0.0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        auto strength = 0.0;\n      \
    \  foreach(letter; extension)\n        {\n            if(letter.isUpper)\n   \
    \             strength++;\n            else\n                strength--;\n   \
    \     }\n        if(strength > strongest)\n        {\n            strongest =\
    \ strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpef_eeiby.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpef_eeiby.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0kopa7x5.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp0kopa7x5.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0kopa7x5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string max_extension = \"\";\n    foreach(string\
    \ extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpty60b0r0.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpty60b0r0.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpty60b0r0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        double cap = 0;\n        double sm =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        double current_strength = cap - sm;\n        if(current_strength > strength)\n\
    \        {\n            strength = current_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkwlya7_.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkwlya7_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float max_strength = 0;\n    string strongest_extension = \"\";\n \
    \   foreach(extension; extensions)\n    {\n        float strength = 0;\n     \
    \   foreach(char c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdskfghxb.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpdskfghxb.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdskfghxb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnd0gew1j.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpnd0gew1j.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnd0gew1j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strongest_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(isUpper(c))\n                strength++;\n\
    \            else if(isLower(c))\n                strength--;\n        }\n   \
    \     if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpec2aps0a.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpec2aps0a.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpec2aps0a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppt_5te75.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmppt_5te75.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppt_5te75.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double[] strength = new double[extensions.length];\n    double max\
    \ = 0;\n    int index = 0;\n    for (int i = 0; i < extensions.length; i++)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach (char c; extensions[i])\n\
    \        {\n            if (c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        strength[i] = cap - sm;\n        if\
    \ (strength[i] > max)\n        {\n            max = strength[i];\n           \
    \ index = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc61ejmu6.d(32): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc61ejmu6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprdkx4d4v.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprdkx4d4v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsl8ss0kj.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsl8ss0kj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = -1;\n    string strongest_extension = \"\";\n  \
    \  foreach(string extension; extensions)\n    {\n        int strength = 0;\n \
    \       foreach(char c; extension)\n        {\n            if(c.isUpper)\n   \
    \             strength++;\n            else\n                strength--;\n   \
    \     }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9bt09_ta.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9bt09_ta.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float max_strength = 0;\n    string strongest_extension = \"\";\n \
    \   foreach(extension; extensions)\n    {\n        float strength = 0;\n     \
    \   foreach(char c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3msq_y88.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp3msq_y88.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3msq_y88.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpni1s7mo8.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpni1s7mo8.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpni1s7mo8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdr1vyopm.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpdr1vyopm.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdr1vyopm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    float strongest_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float strength = 0;\n        foreach(char c;\
    \ ext)\n        {\n            if(c.isUpper)\n                strength++;\n  \
    \          else if(c.isLower)\n                strength--;\n        }\n      \
    \  if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe2chqz57.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpe2chqz57.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe2chqz57.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp32ngll7p.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32ngll7p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float max_strength = 0;\n    string strongest_extension = \"\";\n \
    \   foreach(string extension; extensions)\n    {\n        float strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgz44hcjc.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpgz44hcjc.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgz44hcjc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo055cvii.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmpo055cvii.d(32): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo055cvii.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgzia8fo4.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpgzia8fo4.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgzia8fo4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0.0f;\n    foreach(extension; extensions)\n    {\n        float strength = 0.0f;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6atjb9bx.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6atjb9bx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int upper_case_count = 0;\n \
    \       int lower_case_count = 0;\n        foreach(letter; extension)\n      \
    \  {\n            if(isUpper(letter))\n            {\n                upper_case_count++;\n\
    \            }\n            else\n            {\n                lower_case_count++;\n\
    \            }\n        }\n        int strength = upper_case_count - lower_case_count;\n\
    \        if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmploil055_.d(31): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmploil055_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int cap = 0;\n        int sm\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        int strength = cap - sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ooni60r.d(31): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmp7ooni60r.d(33): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ooni60r.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppg9qodff.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmppg9qodff.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppg9qodff.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr_8kmmaq.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpr_8kmmaq.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_8kmmaq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c.isUpper)\n               \
    \ cap++;\n            else\n                sm++;\n        }\n        double curr_strength\
    \ = cap - sm;\n        if(curr_strength > strength)\n        {\n            strength\
    \ = curr_strength;\n            strongest = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2raawthl.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2raawthl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk8bzj785.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpk8bzj785.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpk8bzj785.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(letter;\
    \ extension)\n        {\n            if(letter.isUpper)\n            {\n     \
    \           strength++;\n            }\n            else\n            {\n    \
    \            strength--;\n            }\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpou_78w4k.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpou_78w4k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpemmho51v.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpemmho51v.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpemmho51v.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strongest_strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5af7z08s.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp5af7z08s.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5af7z08s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        float extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength++;\n            else if(c.isLower)\n     \
    \           extension_strength--;\n        }\n        if(extension_strength >\
    \ strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43ps_qvz.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp43ps_qvz.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43ps_qvz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string strongest = \"\";\n    foreach(string ext;\
    \ extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                cap++;\n    \
    \        else\n                sm++;\n        }\n        if(cap - sm > max)\n\
    \        {\n            max = cap - sm;\n            strongest = ext;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn1bub4yh.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1bub4yh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpddugpkvc.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpddugpkvc.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpddugpkvc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wxfwcuu.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp9wxfwcuu.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9wxfwcuu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(abs(strength) > abs(strongest_strength))\n        {\n \
    \           strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2tib135.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmps2tib135.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2tib135.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp40anxnae.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp40anxnae.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    float max_strength = 0;\n    string strongest_extension = \"\";\n \
    \   foreach(extension; extensions)\n    {\n        float strength = 0;\n     \
    \   foreach(c; extension)\n        {\n            if(c.isUpper)\n            \
    \    strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8qeulmqw.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmp8qeulmqw.d(32): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8qeulmqw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqv5o1cl0.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpqv5o1cl0.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqv5o1cl0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cap = 0;\n        double sm = 0;\n \
    \       foreach(char c; ext)\n        {\n            if(c.isUpper)\n         \
    \       cap++;\n            else\n                sm++;\n        }\n        double\
    \ temp = cap - sm;\n        if(temp > strength)\n        {\n            strength\
    \ = temp;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_st6vuyq.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_st6vuyq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string ext; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpam5xc5ij.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpam5xc5ij.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpam5xc5ij.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ -1;\n    foreach(extension; extensions)\n    {\n        float strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdzvjb5xf.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzvjb5xf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe5q83miw.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpe5q83miw.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe5q83miw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    int max_index = 0;\n    int strength = 0;\n    int\
    \ cap = 0;\n    int sm = 0;\n    foreach(i, extension; extensions)\n    {\n  \
    \      cap = extension.count!(a => a.isUpper);\n        sm = extension.count!(a\
    \ => a.isLower);\n        strength = cap - sm;\n        if(strength > max)\n \
    \       {\n            max = strength;\n            max_index = i;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ extensions[max_index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmu5izgiu.d(30): Error: no property `count` for type `string`\\\
    n/tmp/tmpmu5izgiu.d(31): Error: no property `count` for type `string`\\n/tmp/tmpmu5izgiu.d(36):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmu5izgiu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = extensions[0];\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength += 1;\n            else if(c.isLower)\n  \
    \              extension_strength -= 1;\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdhjn548i.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpdhjn548i.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdhjn548i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuk1arbzp.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpuk1arbzp.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuk1arbzp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    float strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float cap = 0;\n        float sm = 0;\n   \
    \     foreach(char c; ext)\n        {\n            if(c.isUpper)\n           \
    \     cap++;\n            else\n                sm++;\n        }\n        float\
    \ str = cap - sm;\n        if(str > strength)\n        {\n            strength\
    \ = str;\n            strongest = ext;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwmsyhtr6.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwmsyhtr6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpadbmvu_g.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpadbmvu_g.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpadbmvu_g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiu3mh_ok.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu3mh_ok.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_rywn0eh.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp_rywn0eh.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_rywn0eh.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(isUpper(c))\n   \
    \             strength++;\n            else if(isLower(c))\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6l3fvi57.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmp6l3fvi57.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6l3fvi57.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        float cap = 0;\n        float sm = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        float cur_strength = cap - sm;\n        if(cur_strength >\
    \ strength)\n        {\n            strength = cur_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvl5w5q9x.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpvl5w5q9x.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvl5w5q9x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength += 1;\n            else if(c.isLower)\n  \
    \              extension_strength -= 1;\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj219cad5.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpj219cad5.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj219cad5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(isUpper(c))\n   \
    \             strength++;\n            else\n                strength--;\n   \
    \     }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcwak3844.d(30): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcwak3844.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0gbtiidi.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp0gbtiidi.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0gbtiidi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max = 0;\n    string result = \"\";\n    foreach(string ext;\
    \ extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                cap++;\n    \
    \        else if(c.isLower)\n                sm++;\n        }\n        double\
    \ strength = cap - sm;\n        if(strength > max)\n        {\n            max\
    \ = strength;\n            result = class_name ~ \".\" ~ ext;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpewf33ub8.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpewf33ub8.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpewf33ub8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp383g4b38.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp383g4b38.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp383g4b38.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(isUpper(c))\n      \
    \          strength++;\n            else\n                strength--;\n      \
    \  }\n        if(strength > strongest_strength)\n        {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbepynhcc.d(30): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbepynhcc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1n01rn8g.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1n01rn8g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    auto strongest = extensions.front;\n    double strength = 0;\n    foreach(ext;\
    \ extensions)\n    {\n        auto cap = ext.count!(a => a.isUpper);\n       \
    \ auto sm = ext.count!(a => a.isLower);\n        auto str = cap - sm;\n      \
    \  if(str > strength)\n        {\n            strength = str;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw5rfuwr8.d(23): Error: no property `front` for type `string[]`\\\
    n/tmp/tmpw5rfuwr8.d(27): Error: no property `count` for type `string`\\n/tmp/tmpw5rfuwr8.d(28):\
    \ Error: no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpw5rfuwr8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int[] strength = new int[extensions.length];\n    int max = 0;\n  \
    \  int max_index = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n\
    \        int cap = 0;\n        int sm = 0;\n        foreach (char c; extensions[i])\n\
    \        {\n            if (c >= 'A' && c <= 'Z')\n                cap++;\n  \
    \          else if (c >= 'a' && c <= 'z')\n                sm++;\n        }\n\
    \        strength[i] = cap - sm;\n        if (strength[i] > max)\n        {\n\
    \            max = strength[i];\n            max_index = i;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpausbl97u.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42952d]\\n??:? void tmpausbl97u.__unittest_L46_C1()\
    \ [0x428267]\\n??:? void tmpausbl97u.__modtest() [0x428798]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e0bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x429286]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ad85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ae14]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ad11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42925d]\\n??:? runModuleUnitTests [0x42de91]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4299f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429977]\\n??:? _d_run_main [0x4298e2]\\n??:? main [0x4287ab]\\\
    n??:? __libc_start_main [0x1dbd1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    auto strongest = extensions[0];\n    double strongest_strength = 0;\n\
    \    foreach(ext; extensions)\n    {\n        double strength = 0;\n        foreach(c;\
    \ ext)\n        {\n            if(c.isUpper)\n                strength += 1;\n\
    \            else\n                strength -= 1;\n        }\n        if(strength\
    \ > strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest = ext;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrw4keyw.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcrw4keyw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphqmf0ozk.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmphqmf0ozk.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphqmf0ozk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwwj5ik69.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpwwj5ik69.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwwj5ik69.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cap = 0;\n        double sm = 0;\n \
    \       foreach(char c; ext)\n        {\n            if(c.isUpper)\n         \
    \       cap++;\n            else\n                sm++;\n        }\n        double\
    \ new_strength = cap - sm;\n        if(new_strength > strength)\n        {\n \
    \           strength = new_strength;\n            strongest = ext;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxf3faayb.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxf3faayb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzxn5o8w8.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpzxn5o8w8.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzxn5o8w8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo2l29xnc.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpo2l29xnc.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo2l29xnc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > strongest_strength)\n       \
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxk03b7jl.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpxk03b7jl.d(32):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxk03b7jl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max_strength = 0;\n    string strongest_extension = \"\";\n\
    \    foreach(string extension; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpalmiitf3.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpalmiitf3.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpalmiitf3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \            {\n                extension_strength++;\n            }\n       \
    \     else if(isLower(c))\n            {\n                extension_strength--;\n\
    \            }\n        }\n        if(extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = extension_strength;\n \
    \           strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi0ln3s3k.d(30): Error: undefined identifier `isUpper`\\n/tmp/tmpi0ln3s3k.d(34):\
    \ Error: undefined identifier `isLower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpi0ln3s3k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqjju3p_c.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpqjju3p_c.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqjju3p_c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0.0f;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0.0f;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength += 1.0f;\n            else if(c.isLower)\n         \
    \       strength -= 1.0f;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsao2n9bd.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpsao2n9bd.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsao2n9bd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxwtj04r4.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpxwtj04r4.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxwtj04r4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(char\
    \ c; extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5a7kr7t9.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp5a7kr7t9.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5a7kr7t9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplhwgjt84.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmplhwgjt84.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplhwgjt84.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiuwrdv4x.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpiuwrdv4x.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiuwrdv4x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(c;\
    \ extension)\n        {\n            if(c.isUpper)\n                strength++;\n\
    \            else if(c.isLower)\n                strength--;\n        }\n    \
    \    if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2z46536e.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    n/tmp/tmp2z46536e.d(32): Error: no property `isLower` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z46536e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0.0f;\n    float strength = 0.0f;\n    foreach(string extension; extensions)\n\
    \    {\n        strength = 0.0f;\n        foreach(char c; extension)\n       \
    \ {\n            if(c.isUpper)\n                strength++;\n            else\
    \ if(c.isLower)\n                strength--;\n        }\n        if(strength >\
    \ strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpszjkt4lt.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpszjkt4lt.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpszjkt4lt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string ext; extensions)\n    {\n        double strength = 0;\n\
    \        foreach(char c; ext)\n        {\n            if(c.isUpper)\n        \
    \        strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = ext;\n   \
    \     }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph7q5fo58.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmph7q5fo58.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7q5fo58.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyuclkqk.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpcyuclkqk.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyuclkqk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest = \"\";\n    double strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        double cap = 0;\n        double sm = 0;\n \
    \       foreach(char c; ext)\n        {\n            if(c.isUpper)\n         \
    \       cap++;\n            else if(c.isLower)\n                sm++;\n      \
    \  }\n        double temp = cap - sm;\n        if(temp > strength)\n        {\n\
    \            strength = temp;\n            strongest = ext;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57j8jq4_.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp57j8jq4_.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57j8jq4_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = class_name;\n    float strength = 0;\n    foreach(string\
    \ ext; extensions)\n    {\n        float cur_strength = 0;\n        foreach(char\
    \ c; ext)\n        {\n            if(c.isUpper)\n                cur_strength++;\n\
    \            else if(c.isLower)\n                cur_strength--;\n        }\n\
    \        if(cur_strength > strength)\n        {\n            strength = cur_strength;\n\
    \            result = class_name ~ \".\" ~ ext;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwj2z2jji.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpwj2z2jji.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwj2z2jji.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else\n                strength--;\n    \
    \    }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy09ogu99.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy09ogu99.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength++;\n            else if(c.isLower)\n     \
    \           extension_strength--;\n        }\n        if(extension_strength >\
    \ strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas5m0xta.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpas5m0xta.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas5m0xta.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength++;\n            else if(c.isLower)\n     \
    \           extension_strength--;\n        }\n        if(extension_strength >\
    \ strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkg0_bwn.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmplkg0_bwn.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkg0_bwn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptg19qo40.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmptg19qo40.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptg19qo40.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(string extension; extensions)\n    {\n        int strength = 0;\n  \
    \      foreach(char c; extension)\n        {\n            if(c.isUpper)\n    \
    \            strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpff295r83.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpff295r83.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpff295r83.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strongest_strength =\
    \ 0.0f;\n    foreach(extension; extensions)\n    {\n        float strength = 0.0f;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength += 1.0f;\n            else\n                strength -= 1.0f;\n\
    \        }\n        if(strength > strongest_strength)\n        {\n           \
    \ strongest_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbg5q8glz.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbg5q8glz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string s; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; s)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max)\n        {\n            max = strength;\n            result = class_name\
    \ ~ \".\" ~ s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt1_9s31z.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt1_9s31z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuvlxnk0s.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpuvlxnk0s.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvlxnk0s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = strength;\n           \
    \ strongest_extension = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6dygz_io.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmp6dygz_io.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6dygz_io.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = 0;\n    string strongest_extension = \"\";\n   \
    \ foreach(extension; extensions)\n    {\n        int strength = 0;\n        foreach(letter;\
    \ extension)\n        {\n            if(letter.isUpper)\n            {\n     \
    \           strength++;\n            }\n            else\n            {\n    \
    \            strength--;\n            }\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaf1nv08t.d(30): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaf1nv08t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjrebnxmx.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpjrebnxmx.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjrebnxmx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    foreach(string\
    \ extension; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n \
    \       foreach(char c; extension)\n        {\n            if(c.isUpper)\n   \
    \             cap++;\n            else\n                sm++;\n        }\n   \
    \     int current_strength = cap - sm;\n        if(current_strength > strength)\n\
    \        {\n            strength = current_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwq6c67cy.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwq6c67cy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max = 0;\n    string max_ext = \"\";\n    foreach(string ext; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(char c; ext)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\
    \ if(c.isLower)\n                sm++;\n        }\n        int strength = cap\
    \ - sm;\n        if(strength > max)\n        {\n            max = strength;\n\
    \            max_ext = ext;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n   \
    \ assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7iubwtj.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpb7iubwtj.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7iubwtj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int strength = 0;\n    string strongest = \"\";\n    foreach(string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c.isUpper)\n               \
    \ cap++;\n            else\n                sm++;\n        }\n        int curr_strength\
    \ = cap - sm;\n        if(curr_strength > strength)\n        {\n            strength\
    \ = curr_strength;\n            strongest = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9j2vxh8k.d(31): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9j2vxh8k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    double strongest_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngeor8zs.d(30): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmpngeor8zs.d(32): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngeor8zs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    float strength = 0;\n    foreach(string\
    \ extension; extensions)\n    {\n        float extension_strength = 0;\n     \
    \   foreach(char c; extension)\n        {\n            if(c.isUpper)\n       \
    \         extension_strength++;\n            else\n                extension_strength--;\n\
    \        }\n        if(extension_strength > strength)\n        {\n           \
    \ strength = extension_strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpllesztyi.d(30): Error: no property `isUpper` for type `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpllesztyi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
