name: HumanEval_70_strange_sort_list
language: humaneval_to_dlang.py
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
  \ return list in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n  \
  \  strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) ==\
  \ []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 0)\n        return lst;\n    long[] res =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length != 0)\n    {\n\
    \        long min = lst[0];\n        long max = lst[0];\n        foreach (item;\
    \ lst)\n        {\n            if (item < min)\n                min = item;\n\
    \            if (item > max)\n                max = item;\n        }\n       \
    \ res[i] = min;\n        res[i + 1] = max;\n        i += 2;\n        lst = lst.filter!(x\
    \ => x != min && x != max);\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i : lst)\n    {\n     \
    \   min = min(min, i);\n        max = max(max, i);\n    }\n    long[] lst1 = new\
    \ long[lst.length];\n    long[] lst2 = new long[lst.length];\n    long j = 0;\n\
    \    long k = 0;\n    for (long i : lst)\n    {\n        if (i != min && i !=\
    \ max)\n        {\n            if (i < min)\n            {\n                lst1[j]\
    \ = i;\n                j++;\n            }\n            else\n            {\n\
    \                lst2[k] = i;\n                k++;\n            }\n        }\n\
    \    }\n    res[0] = min;\n    res[1] = max;\n    for (long i = 2; i < lst.length;\
    \ i += 2)\n    {\n        res[i] = lst1[i / 2 - 1];\n        res[i + 1] = lst2[i\
    \ / 2 - 1];\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n    lst2.sort();\n\
    \    int i = 0;\n    int j = lst2.length - 1;\n    int k = 0;\n    while (k <\
    \ lst.length)\n    {\n        res[k] = lst2[i];\n        i++;\n        k++;\n\
    \        if (k < lst.length)\n        {\n            res[k] = lst2[j];\n     \
    \       j--;\n            k++;\n        }\n    }\n    return res;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n\
    \        if (i < min)\n            min = i;\n        if (i > max)\n          \
    \  max = i;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[lst.length - 1] = max;\n    for (int i = 1; i < lst.length\
    \ - 1; i++)\n    {\n        if (i % 2 == 1)\n        {\n            res[i] = lst2[lst2.length\
    \ - 1];\n            lst2.remove(lst2[lst2.length - 1]);\n        }\n        else\n\
    \        {\n            res[i] = lst2[0];\n            lst2.remove(lst2[0]);\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            res[i] = lst.min();\n            lst.remove(lst.min());\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst.max();\n\
    \            lst.remove(lst.max());\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return\
    \ lst;\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n\
    \    bool is_even = true;\n    foreach (i, v; sorted)\n    {\n        if (is_even)\n\
    \        {\n            result[i] = v;\n        }\n        else\n        {\n \
    \           result[lst.length - i - 1] = v;\n        }\n        is_even = !is_even;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n\
    \    bool is_min = true;\n    foreach (i, v; temp)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = v;\n            is_min = false;\n        }\n\
    \        else\n        {\n            result[lst.length - i - 1] = v;\n      \
    \      is_min = true;\n        }\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n     \
    \   else\n        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto\
    \ max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n         \
    \   min = i;\n        if (i > max)\n            max = i;\n    }\n    auto min_index\
    \ = 0;\n    auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (lst[i]\
    \ == min)\n            min_index = i;\n        if (lst[i] == max)\n          \
    \  max_index = i;\n    }\n    auto lst_copy = lst.dup;\n    lst_copy.remove(min_index);\n\
    \    lst_copy.remove(max_index);\n    auto result = [min, max];\n    while (lst_copy.length\
    \ > 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n      \
    \  foreach (i; lst_copy)\n        {\n            if (i < min)\n              \
    \  min = i;\n            if (i > max)\n                max = i;\n        }\n \
    \       min_index = 0;\n        max_index = 0;\n        foreach (i; lst_copy)\n\
    \        {\n            if (lst_copy[i] == min)\n                min_index = i;\n\
    \            if (lst_copy[i] == max)\n                max_index = i;\n       \
    \ }\n        lst_copy.remove(min_index);\n        lst_copy.remove(max_index);\n\
    \        result ~= min;\n        result ~= max;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    lst_copy.sort();\n    bool is_min = true;\n\
    \    foreach (i, ref e; res)\n    {\n        if (is_min)\n        {\n        \
    \    e = lst_copy[0];\n            lst_copy = lst_copy[1..$];\n        }\n   \
    \     else\n        {\n            e = lst_copy[$-1];\n            lst_copy =\
    \ lst_copy[0..$-1];\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] tmp = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = tmp.min;\n      \
    \      tmp.remove(tmp.min);\n        }\n        else\n        {\n            res[i]\
    \ = tmp.max;\n            tmp.remove(tmp.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    int i = 0;\n    int j = 0;\n    int k = sorted.length - 1;\n    int dir =\
    \ 1;\n    while (i < res.length)\n    {\n        res[i] = sorted[j];\n       \
    \ if (dir == 1)\n            j++;\n        else\n            k--;\n        dir\
    \ *= -1;\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int i =\
    \ 0;\n    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n \
    \   {\n        if (e < min)\n            min = e;\n        if (e > max)\n    \
    \        max = e;\n    }\n    res[i++] = min;\n    lst -= min;\n    res[i++] =\
    \ max;\n    lst -= max;\n    while (lst.length > 0)\n    {\n        min = lst[0];\n\
    \        max = lst[0];\n        foreach (e; lst)\n        {\n            if (e\
    \ < min)\n                min = e;\n            if (e > max)\n               \
    \ max = e;\n        }\n        res[i++] = min;\n        lst -= min;\n        res[i++]\
    \ = max;\n        lst -= max;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort();\n    int i = 0;\n    int j = temp.length -\
    \ 1;\n    while (i <= j)\n    {\n        result[i] = temp[i];\n        if (i !=\
    \ j)\n            result[j] = temp[j];\n        i++;\n        j--;\n    }\n  \
    \  return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n   \
    \ long[] res = new long[lst.length];\n    bool asc = true;\n    int i = 0;\n \
    \   while (lst.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = lst[0];\n            lst = lst[1..$];\n        }\n        else\n        {\n\
    \            res[i] = lst[$-1];\n            lst = lst[0..$-1];\n        }\n \
    \       i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    bool asc = true;\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst[i];\n          \
    \  i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n  \
    \          j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while\
    \ (i <= j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    foreach (e; lst)\n    {\n        if (i < j)\n        {\n         \
    \   result[i] = sorted[i];\n            result[j] = sorted[j];\n            i++;\n\
    \            j--;\n        }\n        else\n        {\n            result[i] =\
    \ sorted[i];\n        }\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <=\
    \ j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n    \
    \        i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] min = new long[1];\n\
    \    long[] max = new long[1];\n    long[] result = new long[lst.length];\n  \
    \  long[] remaining = new long[lst.length];\n    bool[] used = new bool[lst.length];\n\
    \    long[] tmp = new long[lst.length];\n    long[] tmp2 = new long[lst.length];\n\
    \    long[] tmp3 = new long[lst.length];\n    long[] tmp4 = new long[lst.length];\n\
    \    long[] tmp5 = new long[lst.length];\n    long[] tmp6 = new long[lst.length];\n\
    \    long[] tmp7 = new long[lst.length];\n    long[] tmp8 = new long[lst.length];\n\
    \    long[] tmp9 = new long[lst.length];\n    long[] tmp10 = new long[lst.length];\n\
    \    long[] tmp11 = new long[lst.length];\n    long[] tmp12 = new long[lst.length];\n\
    \    long[] tmp13 = new long[lst.length];\n    long[] tmp14 = new long[lst.length];\n\
    \    long[] tmp15 = new long[lst.length];\n    long[] tmp16 = new long[lst.length];\n\
    \    long[] tmp17 = new long[lst.length];\n    long[] tmp18 = new long[lst.length];\n\
    \    long[] tmp19 = new long[lst.length];\n    long[] tmp20 = new long[lst.length];\n\
    \    long[] tmp21 = new long[lst.length];\n    long[] tmp22 = new long[lst.length];\n\
    \    long[] tmp23 = new long[lst.length];\n    long[] tmp24 = new long[lst.length];\n\
    \    long[] tmp25 = new long[lst.length];\n    long[] tmp26 = new long[lst.length];\n\
    \    long[] tmp27 = new long[lst.length];\n    long[] tmp28 = new long[lst.length];\n\
    \    long[] tmp29 = new long[", "{\n    if (lst.length == 0) return lst;\n   \
    \ long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    long\
    \ min = sorted[0];\n    long max = sorted[sorted.length - 1];\n    long i = 0;\n\
    \    while (i < lst.length)\n    {\n        res[i] = min;\n        i += 1;\n \
    \       if (i < lst.length)\n        {\n            res[i] = max;\n          \
    \  i += 1;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n  \
    \  {\n        if (is_min)\n        {\n            res[i] = lst.min();\n      \
    \      lst.remove(lst.min());\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long\
    \ min = sorted[0];\n    long max = sorted[sorted.length - 1];\n    bool min_flag\
    \ = true;\n    foreach (i, ref x; lst)\n    {\n        if (min_flag)\n       \
    \ {\n            result[i] = min;\n            min_flag = false;\n        }\n\
    \        else\n        {\n            result[i] = max;\n            min_flag =\
    \ true;\n        }\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\
    \ return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            res[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = lst[i];\n          \
    \  j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto\
    \ max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n         \
    \   min = i;\n        if (i > max)\n            max = i;\n    }\n    auto min_index\
    \ = 0;\n    auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (i ==\
    \ min)\n            min_index = i;\n        if (i == max)\n            max_index\
    \ = i;\n    }\n    long[] res = new long[lst.length];\n    res[0] = min;\n   \
    \ res[1] = max;\n    long[] lst_copy = lst[2..$];\n    lst_copy.remove(min);\n\
    \    lst_copy.remove(max);\n    auto i = 2;\n    while (lst_copy.length > 0)\n\
    \    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n        foreach\
    \ (i; lst_copy)\n        {\n            if (i < min)\n                min = i;\n\
    \            if (i > max)\n                max = i;\n        }\n        res[i]\
    \ = min;\n        res[i + 1] = max;\n        lst_copy.remove(min);\n        lst_copy.remove(max);\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n  \
    \  {\n        if (is_min)\n        {\n            res[i] = lst.min();\n      \
    \      lst.remove(lst.min());\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    \n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    long[] reversed = sorted.dup;\n    reversed.reverse();\n    \n    foreach\
    \ (i, e; lst)\n    {\n        if (i % 2 == 0)\n            result[i] = sorted[i\
    \ / 2];\n        else\n            result[i] = reversed[i / 2];\n    }\n    \n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n  \
    \  int i = 0;\n    int j = lst.length - 1;\n    while (i <= j)\n    {\n      \
    \  result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n       \
    \ if (i != j)\n        {\n            result[j] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n        j--;\n    }\n    return result;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j =\
    \ sorted.length - 1;\n    bool asc = true;\n    foreach (e; lst)\n    {\n    \
    \    if (asc)\n        {\n            result[i] = sorted[i];\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = sorted[j];\n    \
    \        j--;\n        }\n        asc = !asc;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j =\
    \ sorted.length - 1;\n    foreach (e; lst)\n    {\n        if (i == j)\n     \
    \   {\n            result[i] = sorted[i];\n            break;\n        }\n   \
    \     result[i] = sorted[i];\n        result[j] = sorted[j];\n        i++;\n \
    \       j--;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n  \
    \      min = min(min, lst[i]);\n        max = max(max, lst[i]);\n    }\n    long\
    \ min_i = 0;\n    long max_i = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (min_i <= max_i)\n    {\n        if (is_min)\n        {\n            res[min_i]\
    \ = min;\n            min_i++;\n        }\n        else\n        {\n         \
    \   res[max_i] = max;\n            max_i--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n        if (flag)\n\
    \        {\n            res[i] = lst[i];\n            i++;\n        }\n      \
    \  else\n        {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        flag = !flag;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted =\
    \ lst.dup.sort;\n    long min = sorted[0];\n    long max = sorted[^1];\n    int\
    \ i = 0;\n    int j = 0;\n    while (i < lst.length)\n    {\n        res[i] =\
    \ min;\n        i += 2;\n        if (i >= lst.length) break;\n        res[i] =\
    \ max;\n        i += 2;\n    }\n    i = 1;\n    while (i < lst.length)\n    {\n\
    \        res[i] = sorted[j];\n        i += 2;\n        j++;\n        if (i >=\
    \ lst.length) break;\n        res[i] = sorted[j];\n        i += 2;\n        j++;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    bool is_min\
    \ = true;\n    foreach (e; lst)\n    {\n        if (is_min)\n        {\n     \
    \       result[i] = sorted[i];\n            i++;\n        }\n        else\n  \
    \      {\n            result[j] = sorted[j];\n            j--;\n        }\n  \
    \      is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (e; lst)\n    {\n        min = min(min, e);\n\
    \        max = max(max, e);\n    }\n    long[] result = new long[lst.length];\n\
    \    long[] remaining = lst.dup;\n    long[] min_remaining = remaining.filter!(e\
    \ => e == min).dup;\n    long[] max_remaining = remaining.filter!(e => e == max).dup;\n\
    \    long[] mid_remaining = remaining.filter!(e => e != min && e != max).dup;\n\
    \    bool min_first = true;\n    foreach (e; remaining)\n    {\n        if (min_first)\n\
    \        {\n            if (min_remaining.length > 0)\n            {\n       \
    \         result ~= min_remaining[0];\n                min_remaining = min_remaining[1..$];\n\
    \            }\n            else if (max_remaining.length > 0)\n            {\n\
    \                result ~= max_remaining[0];\n                max_remaining =\
    \ max_remaining[1..$];\n            }\n            else\n            {\n     \
    \           result ~= mid_remaining[0];\n                mid_remaining = mid_remaining[1..$];\n\
    \            }\n        }\n        else\n        {\n            if (max_remaining.length\
    \ > 0)\n            {\n                result ~= max_remaining[0];\n         \
    \       max_remaining = max_remaining[1..$];\n            }\n            else\
    \ if (min_remaining.length > 0)\n            {\n                result ~= min_remaining[0];\n\
    \                min_remaining = min_remaining[1..$];\n            }\n       \
    \     else\n            {\n                result ~= mid_remaining[0];\n     \
    \           mid_remaining = mid_remaining[1..$];\n            }\n        }\n \
    \       min_first = !min_first;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   result[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n  \
    \      else\n        {\n            result[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        asc = !asc;\n        i++;\n    }\n   \
    \ return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ result = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    bool is_min = true;\n    int i = 0;\n    int j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = sorted[j];\n \
    \           j++;\n        }\n        else\n        {\n            result[i] =\
    \ sorted[sorted.length - j];\n        }\n        is_min = !is_min;\n        i++;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort();\n\
    \    long min = temp[0];\n    long max = temp[temp.length - 1];\n    int i = 0;\n\
    \    while (temp.length != 0)\n    {\n        result[i] = min;\n        temp.remove(min);\n\
    \        i++;\n        if (temp.length == 0)\n            break;\n        result[i]\
    \ = max;\n        temp.remove(max);\n        i++;\n        if (temp.length ==\
    \ 0)\n            break;\n        min = temp[0];\n        max = temp[temp.length\
    \ - 1];\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n  \
    \      if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n\
    \            max = lst[i];\n    }\n    long[] lst2 = new long[lst.length];\n \
    \   long[] lst3 = new long[lst.length];\n    long j = 0;\n    long k = 0;\n  \
    \  for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n\
    \            continue;\n        lst2[j] = lst[i];\n        j++;\n    }\n    for\
    \ (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == max)\n     \
    \       continue;\n        lst3[k] = lst[i];\n        k++;\n    }\n    res[0]\
    \ = min;\n    res[1] = max;\n    long[] lst4 = new long[lst.length];\n    long[]\
    \ lst5 = new long[lst.length];\n    long[] lst6 = new long[lst.length];\n    long[]\
    \ lst7 = new long[lst.length];\n    long[] lst8 = new long[lst.length];\n    long[]\
    \ lst9 = new long[lst.length];\n    long[] lst10 = new long[lst.length];\n   \
    \ long[] lst11 = new long[lst.length];\n    long[] lst12 = new long[lst.length];\n\
    \    long[] lst13 = new long[lst.length];\n    long[] lst14 = new long[lst.length];\n\
    \    long[] lst15 = new long[lst.length];\n    long[] lst16 = new long[lst.length];\n\
    \    long[] l", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n\
    \            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    int i = 0;\n    int j = lst.length - 1;\n    bool isMin = true;\n\
    \    while (i <= j)\n    {\n        if (isMin)\n        {\n            res[i]\
    \ = min;\n            isMin = false;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = max;\n            isMin = true;\n           \
    \ j--;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    res[0]\
    \ = min;\n    res[1] = max;\n    long[] lst_ = lst.dup;\n    lst_.remove(min);\n\
    \    lst_.remove(max);\n    int i = 2;\n    while (lst_.length > 0)\n    {\n \
    \       min = lst_[0];\n        max = lst_[0];\n        foreach (j; lst_)\n  \
    \      {\n            if (j < min)\n                min = j;\n            if (j\
    \ > max)\n                max = j;\n        }\n        res[i] = min;\n       \
    \ res[i + 1] = max;\n        lst_.remove(min);\n        lst_.remove(max);\n  \
    \      i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n   \
    \     return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    long[] reversed = sorted.dup;\n    reversed.reverse;\n\
    \    bool is_reversed = false;\n    foreach (i, val; lst)\n    {\n        if (is_reversed)\n\
    \        {\n            result[i] = reversed[0];\n            reversed = reversed[1..$];\n\
    \        }\n        else\n        {\n            result[i] = sorted[0];\n    \
    \        sorted = sorted[1..$];\n        }\n        is_reversed = !is_reversed;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        min = min(min, e);\n        max = max(max, e);\n    }\n    long[] res\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            res[i] = min;\n            i++;\n        }\n        else\n      \
    \  {\n            res[j] = max;\n            j--;\n        }\n        is_min =\
    \ !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] result = new long[lst.length];\n    long[] sorted =\
    \ lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst) {\n    \
    \    min = min(min, e);\n        max = max(max, e);\n    }\n    bool is_min =\
    \ true;\n    int i = 0;\n    while (lst.length > 0) {\n        if (is_min) {\n\
    \            res[i] = min;\n            lst = lst.filter!(e => e != min);\n  \
    \          min = lst[0];\n            foreach (e; lst) {\n                min\
    \ = min(min, e);\n            }\n        } else {\n            res[i] = max;\n\
    \            lst = lst.filter!(e => e != max);\n            max = lst[0];\n  \
    \          foreach (e; lst) {\n                max = max(max, e);\n          \
    \  }\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        if (e < min)\n            min = e;\n        if (e > max)\n          \
    \  max = e;\n    }\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = min;\n            i++;\n            is_min = false;\n        }\n\
    \        else\n        {\n            res[j] = max;\n            j--;\n      \
    \      is_min = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto new_lst = new long[](lst.length);\n\
    \    new_lst[0] = min;\n    new_lst[1] = max;\n    auto min_index = 1;\n    auto\
    \ max_index = 1;\n    for (int i = 2; i < lst.length; i++)\n    {\n        if\
    \ (i % 2 == 0)\n        {\n            new_lst[i] = lst[min_index];\n        \
    \    min_index++;\n        }\n        else\n        {\n            new_lst[i]\
    \ = lst[max_index];\n            max_index++;\n        }\n    }\n    return new_lst;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst2 = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst2.min;\n        \
    \    lst2.remove(lst2.min);\n        }\n        else\n        {\n            res[i]\
    \ = lst2.max;\n            lst2.remove(lst2.max);\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool\
    \ is_max = true;\n    int i = 0;\n    foreach (e; sorted)\n    {\n        if (is_max)\n\
    \        {\n            result[i] = e;\n            is_max = false;\n        }\n\
    \        else\n        {\n            result[lst.length - i - 1] = e;\n      \
    \      is_max = true;\n            i++;\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        long min = lst_copy[0];\n        long max = lst_copy[0];\n\
    \        foreach (el; lst_copy)\n        {\n            min = min(min, el);\n\
    \            max = max(max, el);\n        }\n        res[i] = min;\n        res[i\
    \ + 1] = max;\n        lst_copy = lst_copy.filter!(el => el != min && el != max);\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return\
    \ lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst[i];\n            i++;\n        }\n      \
    \  else\n        {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] sorted = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        long min = lst_copy[0];\n        long max = lst_copy[0];\n\
    \        int min_index = 0;\n        int max_index = 0;\n        for (int j =\
    \ 0; j < lst_copy.length; j++)\n        {\n            if (lst_copy[j] < min)\n\
    \            {\n                min = lst_copy[j];\n                min_index\
    \ = j;\n            }\n            if (lst_copy[j] > max)\n            {\n   \
    \             max = lst_copy[j];\n                max_index = j;\n           \
    \ }\n        }\n        if (is_min)\n        {\n            sorted[i] = min;\n\
    \            lst_copy = lst_copy[0..min_index] ~ lst_copy[min_index+1..$];\n \
    \       }\n        else\n        {\n            sorted[i] = max;\n           \
    \ lst_copy = lst_copy[0..max_index] ~ lst_copy[max_index+1..$];\n        }\n \
    \       is_min = !is_min;\n    }\n    return sorted;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    int i =\
    \ 0;\n    while (sorted.length > 0)\n    {\n        if (is_min)\n        {\n \
    \           result[i] = sorted[0];\n            sorted = sorted[1..$];\n     \
    \   }\n        else\n        {\n            result[i] = sorted[$-1];\n       \
    \     sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n       \
    \ i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    long min = min(lst);\n   \
    \ long max = max(lst);\n    long min_index = 0;\n    long max_index = lst.length\
    \ - 1;\n    foreach (i; 0 .. lst.length)\n    {\n        if (i % 2 == 0)\n   \
    \     {\n            res[i] = min;\n            min_index++;\n            min\
    \ = min(lst[min_index .. $]);\n        }\n        else\n        {\n          \
    \  res[i] = max;\n            max_index--;\n            max = max(lst[0 .. max_index]);\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] result = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (e; lst)\n    {\n        if (e < min)\n \
    \           min = e;\n        if (e > max)\n            max = e;\n    }\n    long[]\
    \ tmp = lst.dup;\n    tmp.remove(min);\n    tmp.remove(max);\n    result[0] =\
    \ min;\n    result[result.length - 1] = max;\n    int i = 1;\n    int j = result.length\
    \ - 2;\n    while (tmp.length > 0)\n    {\n        result[i] = tmp[0];\n     \
    \   result[j] = tmp[tmp.length - 1];\n        tmp.remove(tmp[0]);\n        tmp.remove(tmp[tmp.length\
    \ - 1]);\n        i++;\n        j--;\n    }\n    return result;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] remaining = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            auto min = remaining.min;\n\
    \            result[i] = min;\n            remaining.remove(min);\n        }\n\
    \        else\n        {\n            auto max = remaining.max;\n            result[i]\
    \ = max;\n            remaining.remove(max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n            min\
    \ = i;\n        if (i > max)\n            max = i;\n    }\n    long[] lst_copy\
    \ = lst.dup;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n    res[0]\
    \ = min;\n    res[res.length - 1] = max;\n    long[] lst_copy_sorted = lst_copy.dup;\n\
    \    lst_copy_sorted.sort;\n    long[] lst_copy_sorted_reversed = lst_copy_sorted.dup;\n\
    \    lst_copy_sorted_reversed.reverse;\n    bool is_odd = false;\n    foreach\
    \ (i; 1 .. res.length - 1)\n    {\n        if (is_odd)\n        {\n          \
    \  res[i] = lst_copy_sorted.popFront;\n            is_odd = false;\n        }\n\
    \        else\n        {\n            res[i] = lst_copy_sorted_reversed.popFront;\n\
    \            is_odd = true;\n        }\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    bool is_min = true;\n\
    \    foreach (el; lst_copy)\n    {\n        if (is_min)\n        {\n         \
    \   res ~= min;\n            lst_copy = lst_copy.filter!(a => a != min);\n   \
    \         is_min = false;\n        }\n        else\n        {\n            res\
    \ ~= max;\n            lst_copy = lst_copy.filter!(a => a != max);\n         \
    \   is_min = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ e; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst2.length\
    \ > 0)\n    {\n        min = lst2[0];\n        max = lst2[0];\n        foreach\
    \ (j; lst2)\n        {\n            if (j < min)\n                min = j;\n \
    \           if (j > max)\n                max = j;\n        }\n        res[i]\
    \ = min;\n        res[i+1] = max;\n        lst2.remove(min);\n        lst2.remove(max);\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n    {\n\
    \        if (is_min)\n        {\n            res[i] = lst_copy.min;\n        \
    \    lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n    \
    \        res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto max\
    \ = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n            min\
    \ = i;\n        if (i > max)\n            max = i;\n    }\n    auto res = new\
    \ long[](lst.length);\n    res[0] = min;\n    res[1] = max;\n    auto i = 2;\n\
    \    while (i < lst.length)\n    {\n        min = max;\n        max = lst[0];\n\
    \        foreach (j; lst)\n        {\n            if (j < min && j > res[i - 2])\n\
    \                min = j;\n            if (j > max && j < res[i - 1])\n      \
    \          max = j;\n        }\n        res[i] = min;\n        res[i + 1] = max;\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n  \
    \  {\n        if (is_min)\n        {\n            res[i] = lst.min();\n      \
    \      lst.remove(lst.min());\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_ = lst.dup;\n    int i = 0;\n    while (lst_.length > 0)\n   \
    \ {\n        res[i] = lst_.min;\n        lst_.remove(lst_.min);\n        if (lst_.length\
    \ == 0)\n            break;\n        res[i + 1] = lst_.max;\n        lst_.remove(lst_.max);\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (long\
    \ i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min\
    \ = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n   \
    \ long[] result = new long[lst.length];\n    long[] temp = new long[lst.length];\n\
    \    long[] temp2 = new long[lst.length];\n    long j = 0;\n    long k = 0;\n\
    \    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] != min &&\
    \ lst[i] != max)\n        {\n            temp[j] = lst[i];\n            j++;\n\
    \        }\n        else\n        {\n            temp2[k] = lst[i];\n        \
    \    k++;\n        }\n    }\n    long[] temp3 = new long[j];\n    long[] temp4\
    \ = new long[k];\n    for (long i = 0; i < j; i++)\n        temp3[i] = temp[i];\n\
    \    for (long i = 0; i < k; i++)\n        temp4[i] = temp2[i];\n    long[] temp5\
    \ = strange_sort_list(temp3);\n    long[] temp6 = strange_sort_list(temp4);\n\
    \    long[] temp7 = new long[temp5.length + temp6.length];\n    for (long i =\
    \ 0; i < temp5.length; i++)\n        temp7[i] = temp5[i];\n    for (long i = 0;\
    \ i < temp6.length; i++)\n        temp7[i + temp5.length] = temp6[i];\n    for\
    \ (long i = 0; i < temp7.length; i++)\n    {\n        if (i % 2 == 0)\n      \
    \      result[i] = temp7[i / 2];\n        else\n            result[i] = temp7[temp7",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length !=\
    \ 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int\
    \ i = 0;\n    while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i += 1;\n        if (lst_copy.length\
    \ > 0)\n        {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i += 1;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach (el;\
    \ lst_copy)\n        {\n            min = min(min, el);\n            max = max(max,\
    \ el);\n        }\n        res[i] = min;\n        res[i + 1] = max;\n        lst_copy\
    \ = lst_copy.filter!(el => el != min && el != max);\n        i += 2;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] tmp = lst.dup;\n    tmp.sort();\n  \
    \  bool is_min = true;\n    int i = 0;\n    while (tmp.length > 0)\n    {\n  \
    \      if (is_min)\n        {\n            res[i] = tmp[0];\n            tmp =\
    \ tmp[1..$];\n        }\n        else\n        {\n            res[i] = tmp[$-1];\n\
    \            tmp = tmp[0..$-1];\n        }\n        is_min = !is_min;\n      \
    \  i++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst[i];\n            i++;\n        }\n      \
    \  else\n        {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] tmp = new long[lst.length];\n\
    \    long j = 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n        if\
    \ (lst[i] != min && lst[i] != max)\n        {\n            tmp[j] = lst[i];\n\
    \            j++;\n        }\n    }\n    res[0] = min;\n    res[1] = max;\n  \
    \  long k = 2;\n    for (long i = 0; i < j; i++)\n    {\n        if (i % 2 ==\
    \ 0)\n        {\n            min = tmp[i];\n            for (long m = i; m < j;\
    \ m++)\n            {\n                if (tmp[m] < min)\n                   \
    \ min = tmp[m];\n            }\n            res[k] = min;\n            k++;\n\
    \        }\n        else\n        {\n            max = tmp[i];\n            for\
    \ (long m = i; m < j; m++)\n            {\n                if (tmp[m] > max)\n\
    \                    max = tmp[m];\n            }\n            res[k] = max;\n\
    \            k++;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[1] =\
    \ max;\n    long i = 2;\n    while (lst2.length > 0)\n    {\n        min = lst2[0];\n\
    \        max = lst2[0];\n        for (long j = 0; j < lst2.length; j++)\n    \
    \    {\n            if (lst2[j] < min)\n                min = lst2[j];\n     \
    \       if (lst2[j] > max)\n                max = lst2[j];\n        }\n      \
    \  res[i] = min;\n        i++;\n        res[i] = max;\n        i++;\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_ =\
    \ lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n    {\n  \
    \      if (asc)\n        {\n            res[i] = lst_.min;\n            lst_.remove(lst_.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_.max;\n        \
    \    lst_.remove(lst_.max);\n        }\n        asc = !asc;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    bool is_min = true;\n    foreach (i, ref e; result)\n    {\n        if (is_min)\n\
    \        {\n            e = sorted[0];\n            sorted = sorted[1..$];\n \
    \       }\n        else\n        {\n            e = sorted[$-1];\n           \
    \ sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n  \
    \  for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n  \
    \          min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    int min_i = 0;\n    int max_i = lst.length - 1;\n    int i = 0;\n\
    \    while (min_i <= max_i)\n    {\n        res[i] = min;\n        min_i++;\n\
    \        i++;\n        if (min_i <= max_i)\n        {\n            res[i] = max;\n\
    \            max_i--;\n            i++;\n        }\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  result[i] = lst2.min;\n        lst2.remove(lst2.min);\n        if (lst2.length\
    \ > 0)\n        {\n            result[i+1] = lst2.max;\n            lst2.remove(lst2.max);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n \
    \           lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        if (lst_copy.length > 0)\n        {\n            res[i + 1] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n\
    \    bool is_min = true;\n    foreach (i, ref e; res)\n    {\n        if (is_min)\n\
    \        {\n            e = lst_copy[0];\n            lst_copy = lst_copy[1..$];\n\
    \        }\n        else\n        {\n            e = lst_copy[$-1];\n        \
    \    lst_copy = lst_copy[0..$-1];\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n\
    \            res[i] = lst[i];\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst[i];\n            j--;\n        }\n        asc\
    \ = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    for (int i = 0; i < lst.length; i++)\n    {\n  \
    \      long min_max = is_min ? lst_copy.min : lst_copy.max;\n        result[i]\
    \ = min_max;\n        lst_copy.remove(min_max);\n        is_min = !is_min;\n \
    \   }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool\
    \ asc = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n      \
    \  if (asc)\n        {\n            res[i] = lst_copy.min;\n            lst_copy\
    \ = lst_copy.filter!(x => x != lst_copy.min)();\n        }\n        else\n   \
    \     {\n            res[i] = lst_copy.max;\n            lst_copy = lst_copy.filter!(x\
    \ => x != lst_copy.max)();\n        }\n        asc = !asc;\n        i++;\n   \
    \ }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort();\n    int i = 0;\n    while (sorted.length > 0)\n    {\n     \
    \   result[i] = sorted[0];\n        sorted = sorted[1..$];\n        if (sorted.length\
    \ > 0)\n        {\n            result[i+1] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-2];\n        }\n        i += 2;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    res[0] = min;\n    res[1]\
    \ = max;\n    int i = 2;\n    int j = 0;\n    while (i < lst.length)\n    {\n\
    \        if (lst[j] != min && lst[j] != max)\n        {\n            res[i] =\
    \ lst[j];\n            i++;\n        }\n        j++;\n    }\n    return res;\n\
    }", "{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n\
    \        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool asc = true;\n    foreach (e; lst)\n    {\n        if (asc)\n\
    \        {\n            res[i] = sorted[i];\n            i++;\n        }\n   \
    \     else\n        {\n            res[j] = sorted[j];\n            j--;\n   \
    \     }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n \
    \           lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto max\
    \ = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n            min\
    \ = i;\n        if (i > max)\n            max = i;\n    }\n    auto min_index\
    \ = 0;\n    auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (i ==\
    \ min)\n            min_index = i;\n        if (i == max)\n            max_index\
    \ = i;\n    }\n    long[] result = new long[lst.length];\n    result[0] = min;\n\
    \    result[1] = max;\n    long[] lst_without_min_max = lst[1..$-1];\n    lst_without_min_max\
    \ ~= lst[0];\n    lst_without_min_max ~= lst[$-1];\n    lst_without_min_max =\
    \ lst_without_min_max.sort();\n    foreach (i; 2..lst.length)\n    {\n       \
    \ result[i] = lst_without_min_max[i-2];\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0) \n        return lst;\n    auto min = lst[0];\n    auto\
    \ max = lst[0];\n    foreach (i; lst) \n    {\n        min = min(min, i);\n  \
    \      max = max(max, i);\n    }\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    bool is_min = true;\n    while (i < lst.length) \n    {\n  \
    \      if (is_min) \n        {\n            res[i] = min;\n            lst = lst.filter!(a\
    \ => a != min);\n            is_min = false;\n        } \n        else \n    \
    \    {\n            res[i] = max;\n            lst = lst.filter!(a => a != max);\n\
    \            is_min = true;\n        }\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ is_min = true;\n    foreach (i, _; lst)\n    {\n        if (is_min)\n      \
    \  {\n            result[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[i] = sorted[$-1];\n  \
    \          sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n  \
    \  }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    foreach (el; lst)\n    {\n        if (el < min)\n           \
    \ min = el;\n        if (el > max)\n            max = el;\n    }\n    res[0] =\
    \ min;\n    res[1] = max;\n    long[] lst_ = lst.dup;\n    lst_.remove(min);\n\
    \    lst_.remove(max);\n    bool is_min = true;\n    foreach (i; 2..res.length)\n\
    \    {\n        if (is_min)\n        {\n            min = lst_[0];\n         \
    \   foreach (el; lst_)\n            {\n                if (el < min)\n       \
    \             min = el;\n            }\n            res[i] = min;\n          \
    \  lst_.remove(min);\n            is_min = false;\n        }\n        else\n \
    \       {\n            max = lst_[0];\n            foreach (el; lst_)\n      \
    \      {\n                if (el > max)\n                    max = el;\n     \
    \       }\n            res[i] = max;\n            lst_.remove(max);\n        \
    \    is_min = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ copy = lst.dup;\n    int i = 0;\n    while (copy.length > 0)\n    {\n      \
    \  auto min = copy.min;\n        auto max = copy.max;\n        result[i] = min;\n\
    \        result[i + 1] = max;\n        copy = copy.filter!(x => x != min && x\
    \ != max);\n        i += 2;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (remaining.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            result[i] = remaining.min;\n\
    \            remaining = remaining.remove(remaining.min);\n        }\n       \
    \ else\n        {\n            result[i] = remaining.max;\n            remaining\
    \ = remaining.remove(remaining.max);\n        }\n        is_min = !is_min;\n \
    \       i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] result = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if\
    \ (lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] res = new long[lst.length];\n    long min = lst[0];\n    long max =\
    \ lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i]\
    \ < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max\
    \ = lst[i];\n    }\n    long[] temp = lst.dup;\n    temp.remove(min);\n    temp.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (temp.length\
    \ > 0)\n    {\n        min = temp[0];\n        max = temp[0];\n        for (long\
    \ j = 0; j < temp.length; j++)\n        {\n            if (temp[j] < min)\n  \
    \              min = temp[j];\n            if (temp[j] > max)\n              \
    \  max = temp[j];\n        }\n        res[i] = min;\n        i++;\n        res[i]\
    \ = max;\n        i++;\n        temp.remove(min);\n        temp.remove(max);\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        min = min(min, e);\n        max = max(max, e);\n    }\n    long[] result\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n      \
    \      result[i] = min;\n            min++;\n            i++;\n        }\n   \
    \     else\n        {\n            result[j] = max;\n            max--;\n    \
    \        j--;\n        }\n        asc = !asc;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    res[$\
    \ - 1] = max;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n    for (int\
    \ i = 1; i < res.length - 1; i++)\n    {\n        if (i % 2 == 1)\n        {\n\
    \            res[i] = lst_copy[0];\n            lst_copy.remove(lst_copy[0]);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy[$ - 1];\n \
    \           lst_copy.remove(lst_copy[$ - 1]);\n        }\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        if (e < min)\n            min = e;\n        if (e > max)\n          \
    \  max = e;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst2.length\
    \ > 0)\n    {\n        min = lst2[0];\n        max = lst2[0];\n        foreach\
    \ (e; lst2)\n        {\n            if (e < min)\n                min = e;\n \
    \           if (e > max)\n                max = e;\n        }\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n        res[i] = min;\n        i++;\n        if (lst2.length\
    \ > 0)\n        {\n            res[i] = max;\n            i++;\n        }\n  \
    \  }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min = lst[0];\n    auto max = lst[0];\n    foreach (i; lst)\n    {\n\
    \        if (i < min)\n            min = i;\n        if (i > max)\n          \
    \  max = i;\n    }\n    auto result = new long[lst.length];\n    auto index =\
    \ 0;\n    auto min_index = 0;\n    auto max_index = lst.length - 1;\n    while\
    \ (index < lst.length)\n    {\n        if (index % 2 == 0)\n        {\n      \
    \      result[index] = min;\n            min_index++;\n            min = lst[min_index];\n\
    \            foreach (i; lst[min_index..$])\n            {\n                if\
    \ (i < min)\n                    min = i;\n            }\n        }\n        else\n\
    \        {\n            result[index] = max;\n            max_index--;\n     \
    \       max = lst[max_index];\n            foreach (i; lst[0..max_index])\n  \
    \          {\n                if (i > max)\n                    max = i;\n   \
    \         }\n        }\n        index++;\n    }\n    return result;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    while (i <= j)\n    {\n        result[i] = sorted[i];\n        i++;\n\
    \        if (i > j)\n            break;\n        result[j] = sorted[i];\n    \
    \    j--;\n        i++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool asc = true;\n    int i = 0;\n    foreach (e; sorted)\n\
    \    {\n        res[i] = e;\n        if (asc)\n        {\n            i++;\n \
    \           asc = false;\n        }\n        else\n        {\n            i--;\n\
    \            asc = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_ = lst.dup;\n    int i = 0;\n    while (lst_.length > 0)\n    {\n      \
    \  res[i] = lst_.min;\n        lst_.remove(lst_.min);\n        if (lst_.length\
    \ > 0)\n        {\n            res[i + 1] = lst_.max;\n            lst_.remove(lst_.max);\n\
    \        }\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ e; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (temp.length > 0)\n    {\n        if (asc)\n        {\n            result[i]\
    \ = temp[0];\n            temp = temp[1..$];\n        }\n        else\n      \
    \  {\n            result[i] = temp[$-1];\n            temp = temp[0..$-1];\n \
    \       }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}", "{\n\
    \    if (lst.length == 0) return lst;\n    auto min = lst[0];\n    auto max =\
    \ lst[0];\n    foreach (i; lst)\n    {\n        min = min(min, i);\n        max\
    \ = max(max, i);\n    }\n    auto res = new long[](lst.length);\n    auto min_i\
    \ = 0;\n    auto max_i = lst.length - 1;\n    foreach (i; lst)\n    {\n      \
    \  if (i == min)\n        {\n            res[min_i] = i;\n            min_i +=\
    \ 2;\n        }\n        else if (i == max)\n        {\n            res[max_i]\
    \ = i;\n            max_i -= 2;\n        }\n    }\n    foreach (i; lst)\n    {\n\
    \        if (i != min && i != max)\n        {\n            if (min_i < lst.length)\n\
    \            {\n                res[min_i] = i;\n                min_i += 2;\n\
    \            }\n            else\n            {\n                res[max_i] =\
    \ i;\n                max_i -= 2;\n            }\n        }\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    long[] remaining = lst.dup;\n    int index = 0;\n\
    \    int direction = 1;\n    while (remaining.length > 0)\n    {\n        long\
    \ min = remaining[0];\n        long max = remaining[0];\n        foreach (el;\
    \ remaining)\n        {\n            min = min(min, el);\n            max = max(max,\
    \ el);\n        }\n        if (direction == 1)\n        {\n            result[index]\
    \ = min;\n            remaining = remaining.filter!(a => a != min);\n        }\n\
    \        else\n        {\n            result[index] = max;\n            remaining\
    \ = remaining.filter!(a => a != max);\n        }\n        direction *= -1;\n \
    \       index++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int min = 0;\n\
    \    int max = lst.length - 1;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            res[i] = lst[min];\n\
    \            min++;\n        }\n        else\n        {\n            res[i] =\
    \ lst[max];\n            max--;\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0) return lst;\n    long[] res\
    \ = new long[lst.length];\n    long[] lst2 = lst.dup;\n    bool asc = true;\n\
    \    int i = 0;\n    while (lst2.length > 0)\n    {\n        if (asc)\n      \
    \  {\n            res[i] = lst2.min;\n            lst2.remove(lst2.min);\n   \
    \     }\n        else\n        {\n            res[i] = lst2.max;\n           \
    \ lst2.remove(lst2.max);\n        }\n        i++;\n        asc = !asc;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n    \
    \    {\n            res[i] = lst.min();\n            lst.remove(lst.min());\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst.max();\n\
    \            lst.remove(lst.max());\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return\
    \ lst;\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach (i; lst) {\n\
    \        min = min(min, i);\n        max = max(max, i);\n    }\n    long[] result\
    \ = new long[lst.length];\n    int i = 0;\n    while (i < lst.length) {\n    \
    \    result[i] = min;\n        min = max;\n        foreach (j; lst) {\n      \
    \      if (j != result[i]) {\n                min = min(min, j);\n           \
    \ }\n        }\n        i++;\n        if (i < lst.length) {\n            result[i]\
    \ = max;\n            max = min;\n            foreach (j; lst) {\n           \
    \     if (j != result[i]) {\n                    max = max(max, j);\n        \
    \        }\n            }\n            i++;\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while\
    \ (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n \
    \   int i = 0;\n    while (sorted.length > 0)\n    {\n        if (is_min)\n  \
    \      {\n            result[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[i] = sorted[$-1];\n  \
    \          sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n  \
    \      i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n   \
    \     return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n    foreach\
    \ (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n      \
    \  if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    lst_copy.remove(min);\n\
    \    res[1] = max;\n    lst_copy.remove(max);\n    int i = 2;\n    while (lst_copy.length\
    \ > 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n      \
    \  foreach (el; lst_copy)\n        {\n            if (el < min)\n            \
    \    min = el;\n            if (el > max)\n                max = el;\n       \
    \ }\n        res[i] = min;\n        lst_copy.remove(min);\n        i++;\n    \
    \    res[i] = max;\n        lst_copy.remove(max);\n        i++;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n  \
    \  for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n \
    \           min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    res[0] = min;\n    res[1] = max;\n    long[] lst_copy = lst.dup;\n\
    \    lst_copy.remove(min);\n    lst_copy.remove(max);\n    long[] lst_copy2 =\
    \ lst_copy.dup;\n    lst_copy2.sort;\n    long[] lst_copy3 = lst_copy.dup;\n \
    \   lst_copy3.sort(std.math.greater);\n    long[] lst_copy4 = new long[lst_copy.length];\n\
    \    for (long i = 0; i < lst_copy.length; i++)\n    {\n        if (i % 2 == 0)\n\
    \            lst_copy4[i] = lst_copy2[i / 2];\n        else\n            lst_copy4[i]\
    \ = lst_copy3[i / 2];\n    }\n    for (long i = 2; i < res.length; i++)\n    \
    \    res[i] = lst_copy4[i - 2];\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst1 = lst.dup;\n    long[] lst2 = lst.dup;\n    lst1.sort;\n    lst2.sort(std.numeric.comparisonFunctor!(\"\
    a > b\"));\n    bool flag = true;\n    foreach (i, ref e; res)\n    {\n      \
    \  if (flag)\n        {\n            e = lst1[0];\n            lst1 = lst1[1..$];\n\
    \        }\n        else\n        {\n            e = lst2[0];\n            lst2\
    \ = lst2[1..$];\n        }\n        flag = !flag;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            long min = lst_copy[0];\n\
    \            long min_index = 0;\n            foreach (j; 0 .. lst_copy.length)\n\
    \            {\n                if (lst_copy[j] < min)\n                {\n  \
    \                  min = lst_copy[j];\n                    min_index = j;\n  \
    \              }\n            }\n            result[i] = min;\n            lst_copy\
    \ = lst_copy[0 .. min_index] ~ lst_copy[min_index + 1 .. $];\n        }\n    \
    \    else\n        {\n            long max = lst_copy[0];\n            long max_index\
    \ = 0;\n            foreach (j; 0 .. lst_copy.length)\n            {\n       \
    \         if (lst_copy[j] > max)\n                {\n                    max =\
    \ lst_copy[j];\n                    max_index = j;\n                }\n      \
    \      }\n            result[i] = max;\n            lst_copy = lst_copy[0 .. max_index]\
    \ ~ lst_copy[max_index + 1 .. $];\n        }\n        is_min = !is_min;\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n\
    \    bool ascending = true;\n    int i = 0;\n    while (sorted.length > 0)\n \
    \   {\n        if (ascending)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        i++;\n        ascending = !ascending;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ min_idx = 0;\n    auto max_idx = 0;\n    foreach (i; lst)\n    {\n        if\
    \ (i == min)\n            min_idx = i;\n        if (i == max)\n            max_idx\
    \ = i;\n    }\n    auto min_lst = lst[0..min_idx];\n    auto max_lst = lst[min_idx+1..$];\n\
    \    auto res = [min];\n    foreach (i; max_lst)\n    {\n        res ~= i;\n \
    \       res ~= min_lst[0];\n        min_lst = min_lst[1..$];\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret\
    \ = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    ret[0] = min;\n    ret[1] = max;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n\
    \    for (int i = 2; i < lst.length; i += 2)\n    {\n        min = lst_copy[0];\n\
    \        max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n     \
    \       if (el < min)\n                min = el;\n            if (el > max)\n\
    \                max = el;\n        }\n        ret[i] = min;\n        ret[i +\
    \ 1] = max;\n        lst_copy.remove(min);\n        lst_copy.remove(max);\n  \
    \  }\n    return ret;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i]\
    \ < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max\
    \ = lst[i];\n    }\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long[]\
    \ sorted_min = sorted.filter!(a => a == min).dup;\n    long[] sorted_max = sorted.filter!(a\
    \ => a == max).dup;\n    long[] sorted_other = sorted.filter!(a => a != min &&\
    \ a != max).dup;\n    long[] sorted_other_min = sorted_other.filter!(a => a <\
    \ max).dup;\n    long[] sorted_other_max = sorted_other.filter!(a => a > min).dup;\n\
    \    long[] sorted_other_min_max = sorted_other_min.filter!(a => a > min).dup;\n\
    \    long[] sorted_other_max_min = sorted_other_max.filter!(a => a < max).dup;\n\
    \    long[] sorted_other_min_max_min = sorted_other_min_max.filter!(a => a < max).dup;\n\
    \    long[] sorted_other_max_min_max = sorted_other_max_min.filter!(a => a > min).dup;\n\
    \    long[] sorted_other_min_max_min_max = sorted_other_min_max_min.filter!(a\
    \ => a > min).dup;\n    long[] sorted_other_max_min_max_min = sorted_other_max_min_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other_min_max_min_max_min = sorted_other_min_max_min_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 =\
    \ lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n        res[i]\
    \ = lst2.min;\n        lst2 = lst2.remove(lst2.min);\n        i++;\n        if\
    \ (lst2.length > 0)\n        {\n            res[i] = lst2.max;\n            lst2\
    \ = lst2.remove(lst2.max);\n            i++;\n        }\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] tmp = lst.dup;\n\
    \    tmp.remove(min);\n    tmp.remove(max);\n    res[0] = min;\n    res[1] = max;\n\
    \    for (long i = 2; i < lst.length; i++)\n    {\n        if (i % 2 == 0)\n \
    \       {\n            min = tmp[0];\n            for (long j = 0; j < tmp.length;\
    \ j++)\n            {\n                if (tmp[j] < min)\n                   \
    \ min = tmp[j];\n            }\n            res[i] = min;\n            tmp.remove(min);\n\
    \        }\n        else\n        {\n            max = tmp[0];\n            for\
    \ (long j = 0; j < tmp.length; j++)\n            {\n                if (tmp[j]\
    \ > max)\n                    max = tmp[j];\n            }\n            res[i]\
    \ = max;\n            tmp.remove(max);\n        }\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j)\n    {\n        if (is_min)\n        {\n            result[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort();\n    bool is_min = true;\n    foreach (i,\
    \ e; sorted)\n    {\n        if (is_min)\n        {\n            res[i] = e;\n\
    \            is_min = false;\n        }\n        else\n        {\n           \
    \ res[lst.length - i - 1] = e;\n            is_min = true;\n        }\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto\
    \ min = lst[0];\n    auto max = lst[0];\n    for (auto i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    auto res = new long[lst.length];\n\
    \    auto min_idx = 0;\n    auto max_idx = lst.length - 1;\n    for (auto i =\
    \ 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0)\n        {\n       \
    \     res[i] = min;\n            min_idx++;\n        }\n        else\n       \
    \ {\n            res[i] = max;\n            max_idx--;\n        }\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min =\
    \ lst_copy[0];\n    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n\
    \        if (el < min)\n            min = el;\n        if (el > max)\n       \
    \     max = el;\n    }\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        if (i % 2 == 0)\n        {\n            res[i] = min;\n            lst_copy\
    \ = lst_copy.filter!(el => el != min);\n            if (lst_copy.length == 0)\n\
    \                break;\n            min = lst_copy[0];\n            foreach (el;\
    \ lst_copy)\n            {\n                if (el < min)\n                  \
    \  min = el;\n            }\n        }\n        else\n        {\n            res[i]\
    \ = max;\n            lst_copy = lst_copy.filter!(el => el != max);\n        \
    \    if (lst_copy.length == 0)\n                break;\n            max = lst_copy[0];\n\
    \            foreach (el; lst_copy)\n            {\n                if (el > max)\n\
    \                    max = el;\n            }\n        }\n        i++;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ result = new long[lst.length];\n    long[] lst2 = lst.dup;\n    int i = 0;\n\
    \    while (lst2.length > 0)\n    {\n        result[i] = lst2.min;\n        lst2.remove(lst2.min);\n\
    \        if (lst2.length == 0)\n            break;\n        result[i + 1] = lst2.max;\n\
    \        lst2.remove(lst2.max);\n        i += 2;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n    long\
    \ max = lst[0];\n    foreach (e; lst)\n    {\n        min = min(min, e);\n   \
    \     max = max(max, e);\n    }\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            res[i] = min;\n            min\
    \ = max;\n            foreach (e; lst)\n            {\n                if (e !=\
    \ res[i])\n                    min = min(min, e);\n            }\n           \
    \ i++;\n        }\n        else\n        {\n            res[j] = max;\n      \
    \      max = min;\n            foreach (e; lst)\n            {\n             \
    \   if (e != res[j])\n                    max = max(max, e);\n            }\n\
    \            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i, ref e;\
    \ lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  res[i] = lst2.min;\n        lst2.remove(lst2.min);\n        i++;\n        if\
    \ (lst2.length == 0)\n            break;\n        res[i] = lst2.max;\n       \
    \ lst2.remove(lst2.max);\n        i++;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n \
    \   long[] sorted = lst.dup.sort();\n    bool asc = true;\n    foreach (i, item;\
    \ sorted)\n    {\n        if (asc)\n        {\n            result[i] = item;\n\
    \            asc = false;\n        }\n        else\n        {\n            result[lst.length\
    \ - i - 1] = item;\n            asc = true;\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            result[i] =\
    \ lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n     \
    \   else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] lst2 = lst.dup;\n    lst2.sort();\n    int i = 0;\n    int j = lst2.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst2[i++];\n\
    \        if (i <= j)\n            result[k++] = lst2[j--];\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long[] temp = lst.dup;\n    int i = 0;\n    while\
    \ (temp.length > 0)\n    {\n        res[i] = temp.min;\n        temp = temp.remove(temp.min);\n\
    \        i++;\n        if (temp.length == 0)\n            break;\n        res[i]\
    \ = temp.max;\n        temp = temp.remove(temp.max);\n        i++;\n    }\n  \
    \  return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    int i = 0;\n    while (sorted.length > 0)\n    {\n        res[i] = sorted[0];\n\
    \        sorted = sorted[1..$];\n        if (sorted.length > 0)\n        {\n \
    \           res[i + 1] = sorted[$ - 1];\n            sorted = sorted[0..$ - 1];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach\
    \ (i, ref el; res)\n    {\n        if (is_min)\n        {\n            el = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        el = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    long min = lst2[0];\n    long max = lst2[0];\n    foreach\
    \ (e; lst2)\n    {\n        if (e < min)\n            min = e;\n        if (e\
    \ > max)\n            max = e;\n    }\n    res[0] = min;\n    res[1] = max;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    bool asc = true;\n    for (int\
    \ i = 2; i < res.length; i++)\n    {\n        if (asc)\n        {\n          \
    \  min = lst2[0];\n            foreach (e; lst2)\n            {\n            \
    \    if (e < min)\n                    min = e;\n            }\n            res[i]\
    \ = min;\n            lst2.remove(min);\n            asc = false;\n        }\n\
    \        else\n        {\n            max = lst2[0];\n            foreach (e;\
    \ lst2)\n            {\n                if (e > max)\n                    max\
    \ = e;\n            }\n            res[i] = max;\n            lst2.remove(max);\n\
    \            asc = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 =\
    \ lst.dup;\n    long min = lst2[0];\n    long max = lst2[0];\n    foreach (e;\
    \ lst2)\n    {\n        if (e < min) min = e;\n        if (e > max) max = e;\n\
    \    }\n    int i = 0;\n    bool asc = true;\n    while (lst2.length > 0)\n  \
    \  {\n        if (asc)\n        {\n            res[i] = min;\n            lst2.remove(min);\n\
    \            if (lst2.length > 0)\n            {\n                min = lst2[0];\n\
    \                foreach (e; lst2)\n                {\n                    if\
    \ (e < min) min = e;\n                }\n            }\n        }\n        else\n\
    \        {\n            res[i] = max;\n            lst2.remove(max);\n       \
    \     if (lst2.length > 0)\n            {\n                max = lst2[0];\n  \
    \              foreach (e; lst2)\n                {\n                    if (e\
    \ > max) max = e;\n                }\n            }\n        }\n        i++;\n\
    \        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n  \
    \      if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n\
    \            max = lst[i];\n    }\n    int i = 0;\n    int j = lst.length - 1;\n\
    \    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n   \
    \     {\n            res[i] = min;\n            i++;\n            is_min = false;\n\
    \        }\n        else\n        {\n            res[j] = max;\n            j--;\n\
    \            is_min = true;\n        }\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup.sort();\n    long min = sorted[0];\n    long max = sorted[sorted.length\
    \ - 1];\n    long min_idx = 0;\n    long max_idx = sorted.length - 1;\n    bool\
    \ min_first = true;\n    foreach (i; 0 .. res.length)\n    {\n        if (min_first)\n\
    \        {\n            res[i] = min;\n            min_idx++;\n            min\
    \ = sorted[min_idx];\n        }\n        else\n        {\n            res[i] =\
    \ max;\n            max_idx--;\n            max = sorted[max_idx];\n        }\n\
    \        min_first = !min_first;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool is_min = true;\n    foreach (el; lst)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = sorted[i];\n            i++;\n        }\n   \
    \     else\n        {\n            res[j] = sorted[j];\n            j--;\n   \
    \     }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    long[] lst_ = lst.dup;\n    lst_.remove(min);\n    lst_.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst_.length\
    \ > 0)\n    {\n        min = lst_[0];\n        max = lst_[0];\n        foreach\
    \ (e; lst_)\n        {\n            if (e < min)\n                min = e;\n \
    \           if (e > max)\n                max = e;\n        }\n        lst_.remove(min);\n\
    \        lst_.remove(max);\n        res[i] = min;\n        res[i+1] = max;\n \
    \       i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max = sorted[$\
    \ - 1];\n    long i = 0;\n    while (i < lst.length)\n    {\n        result[i]\
    \ = min;\n        i++;\n        if (i == lst.length)\n            break;\n   \
    \     result[i] = max;\n        i++;\n    }\n    return result;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    for (int i = 0;\
    \ i < lst.length; i++)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n   \
    \     else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    int index = 0;\n    int\
    \ minIndex = 0;\n    int maxIndex = lst.length - 1;\n    while (index < lst.length)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            result[index] = min;\n\
    \            minIndex++;\n            min = lst[minIndex];\n            for (int\
    \ i = minIndex; i < lst.length; i++)\n            {\n                if (lst[i]\
    \ < min)\n                    min = lst[i];\n            }\n        }\n      \
    \  else\n        {\n            result[index] = max;\n            maxIndex--;\n\
    \            max = lst[maxIndex];\n            for (int i = maxIndex; i >= 0;\
    \ i--)\n            {\n                if (lst[i] > max)\n                   \
    \ max = lst[i];\n            }\n        }\n        index++;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n  \
    \  foreach (el; lst)\n    {\n        if (el < min)\n            min = el;\n  \
    \      if (el > max)\n            max = el;\n    }\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    while (i <= j)\n    {\n        if (i == j)\n        {\n\
    \            res[i] = min;\n            break;\n        }\n        res[i] = min;\n\
    \        res[j] = max;\n        i++;\n        j--;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j)\n    {\n        if (is_min)\n        {\n            result[i] = lst[lst.minIndex];\n\
    \            lst[lst.minIndex] = lst[lst.maxIndex];\n            lst[lst.maxIndex]\
    \ = result[i];\n            i++;\n        }\n        else\n        {\n       \
    \     result[j] = lst[lst.maxIndex];\n            lst[lst.maxIndex] = lst[lst.minIndex];\n\
    \            lst[lst.minIndex] = result[j];\n            j--;\n        }\n   \
    \     is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    int i = 0;\n    int j = sorted.length - 1;\n\
    \    bool asc = true;\n    foreach (el; lst)\n    {\n        if (asc)\n      \
    \  {\n            res[i] = min;\n            min = sorted[++i];\n        }\n \
    \       else\n        {\n            res[j] = max;\n            max = sorted[--j];\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach\
    \ (el; lst_copy)\n        {\n            min = min(min, el);\n            max\
    \ = max(max, el);\n        }\n        res[i] = min;\n        i++;\n        lst_copy\
    \ = lst_copy.filter!(x => x != min);\n        if (lst_copy.length == 0)\n    \
    \        break;\n        res[i] = max;\n        i++;\n        lst_copy = lst_copy.filter!(x\
    \ => x != max);\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst.length != 0)\n    {\n\
    \        if (is_min)\n        {\n            result[i] = lst.min();\n        \
    \    lst = lst.remove(lst.min());\n        }\n        else\n        {\n      \
    \      result[i] = lst.max();\n            lst = lst.remove(lst.max());\n    \
    \    }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i += 1;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i +=\
    \ 1;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    long i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (asc)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n    long\
    \ max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n         \
    \   min = i;\n        if (i > max)\n            max = i;\n    }\n    long[] result\
    \ = new long[lst.length];\n    bool is_min = true;\n    int index = 0;\n    while\
    \ (lst.length != 0)\n    {\n        if (is_min)\n        {\n            result[index]\
    \ = min;\n            lst = lst.filter!(a => a != min);\n            min = lst[0];\n\
    \            foreach (i; lst)\n            {\n                if (i < min)\n \
    \                   min = i;\n            }\n        }\n        else\n       \
    \ {\n            result[index] = max;\n            lst = lst.filter!(a => a !=\
    \ max);\n            max = lst[0];\n            foreach (i; lst)\n           \
    \ {\n                if (i > max)\n                    max = i;\n            }\n\
    \        }\n        is_min = !is_min;\n        index++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[1] =\
    \ max;\n    int i = 2;\n    while (lst2.length > 0)\n    {\n        min = lst2[0];\n\
    \        max = lst2[0];\n        for (int j = 0; j < lst2.length; j++)\n     \
    \   {\n            if (lst2[j] < min)\n                min = lst2[j];\n      \
    \      if (lst2[j] > max)\n                max = lst2[j];\n        }\n       \
    \ res[i] = min;\n        i++;\n        res[i] = max;\n        i++;\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    bool min_first = true;\n    foreach (i; 0\
    \ .. lst.length)\n    {\n        if (min_first)\n        {\n            result[i]\
    \ = min;\n            min_first = false;\n        }\n        else\n        {\n\
    \            result[i] = max;\n            min_first = true;\n        }\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] res = new long[lst.length];\n    res[0] = lst[0];\n    lst = lst[1..$];\n\
    \    bool asc = false;\n    foreach (i; 1..lst.length)\n    {\n        if (asc)\n\
    \        {\n            res[i] = lst[0];\n            lst = lst[1..$];\n     \
    \   }\n        else\n        {\n            res[i] = lst[$-1];\n            lst\
    \ = lst[0..$-1];\n        }\n        asc = !asc;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto max\
    \ = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n            min\
    \ = i;\n        if (i > max)\n            max = i;\n    }\n    auto min_index\
    \ = 0;\n    auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (lst[i]\
    \ == min)\n            min_index = i;\n        if (lst[i] == max)\n          \
    \  max_index = i;\n    }\n    auto new_lst = lst[0..min_index] ~ lst[min_index+1..$];\n\
    \    auto new_lst2 = new_lst[0..max_index-1] ~ new_lst[max_index..$];\n    auto\
    \ new_lst3 = new_lst2[0..min_index-1] ~ new_lst2[min_index..$];\n    auto new_lst4\
    \ = new_lst3[0..max_index-2] ~ new_lst3[max_index-1..$];\n    return [min, max]\
    \ ~ strange_sort_list(new_lst4);\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    long min = min(lst);\n   \
    \ long max = max(lst);\n    int i = 0;\n    while (i < lst.length)\n    {\n  \
    \      if (i % 2 == 0)\n        {\n            res[i] = min;\n            lst\
    \ = lst.filter!(a => a != min);\n        }\n        else\n        {\n        \
    \    res[i] = max;\n            lst = lst.filter!(a => a != max);\n        }\n\
    \        min = min(lst);\n        max = max(lst);\n        i++;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ flag = true;\n    while (i <= j)\n    {\n        if (flag)\n        {\n    \
    \        res[i] = lst[i];\n            i++;\n        }\n        else\n       \
    \ {\n            res[j] = lst[i];\n            j--;\n        }\n        flag =\
    \ !flag;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    bool asc = true;\n    int\
    \ i = 0;\n    while (lst.length > 0)\n    {\n        auto min = lst[0];\n    \
    \    auto max = lst[0];\n        foreach (el; lst)\n        {\n            if\
    \ (el < min)\n                min = el;\n            if (el > max)\n         \
    \       max = el;\n        }\n        lst = lst.filter!(el => el != min && el\
    \ != max);\n        if (asc)\n        {\n            res[i] = min;\n         \
    \   res[i + 1] = max;\n        }\n        else\n        {\n            res[i]\
    \ = max;\n            res[i + 1] = min;\n        }\n        i += 2;\n        asc\
    \ = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long min = lst[0];\n    long max = lst[0];\n    foreach (l; lst)\n\
    \    {\n        if (l < min)\n            min = l;\n        if (l > max)\n   \
    \         max = l;\n    }\n    long[] res = new long[lst.length];\n    bool asc\
    \ = true;\n    long i = 0;\n    while (i < lst.length)\n    {\n        if (asc)\n\
    \        {\n            res[i] = min;\n            min = max;\n            foreach\
    \ (l; lst)\n            {\n                if (l < min && l != res[i])\n     \
    \               min = l;\n            }\n        }\n        else\n        {\n\
    \            res[i] = max;\n            max = min;\n            foreach (l; lst)\n\
    \            {\n                if (l > max && l != res[i])\n                \
    \    max = l;\n            }\n        }\n        asc = !asc;\n        i++;\n \
    \   }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n \
    \   long min = lst_copy[0];\n    long max = lst_copy[0];\n    foreach (e; lst_copy)\n\
    \    {\n        if (e < min)\n            min = e;\n        if (e > max)\n   \
    \         max = e;\n    }\n    int i = 0;\n    int j = lst_copy.length - 1;\n\
    \    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n   \
    \     {\n            result[i] = min;\n            lst_copy.remove(min);\n   \
    \         min = lst_copy[0];\n            foreach (e; lst_copy)\n            {\n\
    \                if (e < min)\n                    min = e;\n            }\n \
    \           i++;\n        }\n        else\n        {\n            result[j] =\
    \ max;\n            lst_copy.remove(max);\n            max = lst_copy[0];\n  \
    \          foreach (e; lst_copy)\n            {\n                if (e > max)\n\
    \                    max = e;\n            }\n            j--;\n        }\n  \
    \      is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    int i = 0;\n    while (remaining.length > 0)\n   \
    \ {\n        result[i] = remaining[0];\n        remaining = remaining[1..$];\n\
    \        if (remaining.length == 0)\n            break;\n        result[i+1] =\
    \ remaining[$-1];\n        remaining = remaining[0..$-2];\n        i += 2;\n \
    \   }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min = lst[0];\n    auto max = lst[0];\n    foreach (i; lst)\n    {\n\
    \        if (i < min)\n            min = i;\n        if (i > max)\n          \
    \  max = i;\n    }\n    auto min_index = 0;\n    auto max_index = 0;\n    foreach\
    \ (i; lst)\n    {\n        if (i == min)\n            min_index = i;\n       \
    \ if (i == max)\n            max_index = i;\n    }\n    auto result = new long[lst.length];\n\
    \    result[0] = min;\n    result[1] = max;\n    auto index = 2;\n    foreach\
    \ (i; lst)\n    {\n        if (i != min && i != max)\n        {\n            result[index]\
    \ = i;\n            index++;\n        }\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long min_index = 0;\n\
    \    long max_index = lst.length - 1;\n    for (long i = 0; i < lst.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            res[i] = min;\n      \
    \      min_index++;\n            min = lst[min_index];\n        }\n        else\n\
    \        {\n            res[i] = max;\n            max_index--;\n            max\
    \ = lst[max_index];\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = min(lst);\n    long max = max(lst);\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = min;\n            i++;\n            is_min =\
    \ false;\n        }\n        else\n        {\n            res[j] = max;\n    \
    \        j--;\n            is_min = true;\n        }\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        if (e < min) min = e;\n        if (e > max) max = e;\n    }\n    long[]\
    \ lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n    res[0] =\
    \ min;\n    res[1] = max;\n    int i = 2;\n    while (lst2.length > 0)\n    {\n\
    \        min = lst2[0];\n        max = lst2[0];\n        foreach (e; lst2)\n \
    \       {\n            if (e < min) min = e;\n            if (e > max) max = e;\n\
    \        }\n        lst2.remove(min);\n        lst2.remove(max);\n        res[i]\
    \ = min;\n        res[i+1] = max;\n        i += 2;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n    long\
    \ max = lst[0];\n    foreach (e; lst)\n    {\n        min = min(min, e);\n   \
    \     max = max(max, e);\n    }\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    foreach (e; lst)\n    {\n        if\
    \ (e == min)\n        {\n            res[i] = e;\n            i++;\n        }\n\
    \        else if (e == max)\n        {\n            res[j] = e;\n            j--;\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n   \
    \ while (lst.length > 0)\n    {\n        long min = lst[0];\n        long max\
    \ = lst[0];\n        foreach (long e; lst)\n        {\n            if (e < min)\n\
    \                min = e;\n            if (e > max)\n                max = e;\n\
    \        }\n        result[i++] = min;\n        lst = lst.remove(min);\n     \
    \   if (lst.length > 0)\n        {\n            result[i++] = max;\n         \
    \   lst = lst.remove(max);\n        }\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n\
    \        if (i < min)\n            min = i;\n        if (i > max)\n          \
    \  max = i;\n    }\n    long[] lst_copy = lst.dup;\n    lst_copy.remove(min);\n\
    \    lst_copy.remove(max);\n    res[0] = min;\n    res[1] = max;\n    for (int\
    \ i = 2; i < res.length; i++)\n    {\n        if (i % 2 == 0)\n        {\n   \
    \         min = lst_copy[0];\n            foreach (j; lst_copy)\n            {\n\
    \                if (j < min)\n                    min = j;\n            }\n \
    \           res[i] = min;\n            lst_copy.remove(min);\n        }\n    \
    \    else\n        {\n            max = lst_copy[0];\n            foreach (j;\
    \ lst_copy)\n            {\n                if (j > max)\n                   \
    \ max = j;\n            }\n            res[i] = max;\n            lst_copy.remove(max);\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++]\
    \ = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n\
    \    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i]\
    \ > max)\n            max = lst[i];\n    }\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j)\n    {\n        if (is_min)\n        {\n            res[i] = min;\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = max;\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n    bool\
    \ asc = true;\n    int i = 0;\n    int j = 0;\n    while (i < sorted.length)\n\
    \    {\n        if (asc)\n        {\n            result[j] = sorted[i];\n    \
    \        i++;\n        }\n        else\n        {\n            result[j] = sorted[sorted.length\
    \ - i - 1];\n        }\n        j++;\n        asc = !asc;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n\
    \    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = sorted[i++];\n\
    \        if (i <= j) res[k++] = sorted[j--];\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] tmp = lst.dup;\n    tmp.sort;\n    int i = 0;\n    int j = tmp.length\
    \ - 1;\n    bool flag = true;\n    foreach (e; lst)\n    {\n        if (flag)\n\
    \        {\n            res[i] = tmp[j];\n            j--;\n        }\n      \
    \  else\n        {\n            res[i] = tmp[j];\n            j++;\n        }\n\
    \        i++;\n        flag = !flag;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[res.length\
    \ - 1] = max;\n    long[] lst3 = strange_sort_list(lst2);\n    for (long i = 0;\
    \ i < lst3.length; i++)\n    {\n        if (i % 2 == 0)\n            res[i + 1]\
    \ = lst3[i];\n        else\n            res[res.length - 2 - i] = lst3[i];\n \
    \   }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool\
    \ asc = true;\n    foreach (i; 0 .. lst.length)\n    {\n        if (asc)\n   \
    \     {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        asc = !asc;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n\
    \    while (lst_copy.length > 0)\n    {\n        long min = lst_copy[0];\n   \
    \     long max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n   \
    \         min = min(min, el);\n            max = max(max, el);\n        }\n  \
    \      res[i] = min;\n        res[i + 1] = max;\n        lst_copy = lst_copy.filter!(a\
    \ => a != min && a != max);\n        i += 2;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort;\n    bool asc = true;\n    int i = 0;\n   \
    \ while (sorted.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n\
    \        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long min = min(lst);\n    long max = max(lst);\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach (el;\
    \ lst)\n    {\n        if (is_min)\n        {\n            result[i] = el;\n \
    \           i++;\n        }\n        else\n        {\n            result[j] =\
    \ el;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    bool is_min = true;\n    foreach (i, ref e; result)\n    {\n        if (is_min)\n\
    \        {\n            e = sorted[0];\n            sorted = sorted[1..$];\n \
    \       }\n        else\n        {\n            e = sorted[$-1];\n           \
    \ sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n\
    \        long min = lst[0];\n        long max = lst[0];\n        foreach (long\
    \ x; lst)\n        {\n            if (x < min)\n                min = x;\n   \
    \         if (x > max)\n                max = x;\n        }\n        result[i]\
    \ = min;\n        i++;\n        result[i] = max;\n        i++;\n        lst =\
    \ lst.filter!(x => x != min && x != max);\n    }\n    return result;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_c = lst.dup;\n    long min = lst_c[0];\n    long max = lst_c[0];\n\
    \    foreach (el; lst_c)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    lst_c.remove(min);\n\
    \    bool is_min = true;\n    foreach (i; 1..lst.length)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst_c[0];\n            lst_c.remove(lst_c[0]);\n\
    \            is_min = false;\n        }\n        else\n        {\n           \
    \ res[i] = lst_c[$-1];\n            lst_c.remove(lst_c[$-1]);\n            is_min\
    \ = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n  \
    \      if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n\
    \            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n\
    \    lst2.remove(max);\n    res[0] = min;\n    res[res.length - 1] = max;\n  \
    \  long[] res2 = strange_sort_list(lst2);\n    for (long i = 0; i < res2.length;\
    \ i++)\n        res[i + 1] = res2[i];\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        long min_max = is_min ? remaining.min : remaining.max;\n     \
    \   result[i] = min_max;\n        remaining = remaining.filter!(a => a != min_max);\n\
    \        is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (i; lst_copy)\n    {\n        if (i < min)\n            min = i;\n\
    \        if (i > max)\n            max = i;\n    }\n    res[0] = min;\n    lst_copy.remove(min);\n\
    \    res[1] = max;\n    lst_copy.remove(max);\n    int i = 2;\n    while (lst_copy.length\
    \ != 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n     \
    \   foreach (j; lst_copy)\n        {\n            if (j < min)\n             \
    \   min = j;\n            if (j > max)\n                max = j;\n        }\n\
    \        res[i] = min;\n        lst_copy.remove(min);\n        i++;\n        res[i]\
    \ = max;\n        lst_copy.remove(max);\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] tmp = lst.dup;\n    tmp.sort;\n    bool asc = true;\n    int i = 0;\n\
    \    while (tmp.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = tmp[0];\n            tmp = tmp[1..$];\n        }\n        else\n        {\n\
    \            res[i] = tmp[$-1];\n            tmp = tmp[0..$-1];\n        }\n \
    \       asc = !asc;\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = min(lst);\n    auto max = max(lst);\n\
    \    auto min_index = indexOf(lst, min);\n    auto max_index = indexOf(lst, max);\n\
    \    auto lst_copy = lst.dup;\n    lst_copy.removeAt(min_index);\n    lst_copy.removeAt(max_index);\n\
    \    auto new_lst = [min, max];\n    while (lst_copy.length != 0)\n    {\n   \
    \     min = min(lst_copy);\n        max = max(lst_copy);\n        min_index =\
    \ indexOf(lst_copy, min);\n        max_index = indexOf(lst_copy, max);\n     \
    \   new_lst ~= [min, max];\n        lst_copy.removeAt(min_index);\n        lst_copy.removeAt(max_index);\n\
    \    }\n    return new_lst;\n}", "{\n    if (lst.length == 0) return lst;\n  \
    \  long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n \
    \   bool asc = true;\n    int i = 0;\n    while (sorted.length > 0)\n    {\n \
    \       if (asc)\n        {\n            res[i] = sorted[0];\n            sorted\
    \ = sorted[1..$];\n        }\n        else\n        {\n            res[i] = sorted[$-1];\n\
    \            sorted = sorted[0..$-1];\n        }\n        i++;\n        asc =\
    \ !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] result = new long[lst.length];\n    long[] copy = lst.dup;\n\
    \    long min = copy[0];\n    long max = copy[0];\n    foreach (long i; copy)\n\
    \    {\n        if (i < min)\n            min = i;\n        if (i > max)\n   \
    \         max = i;\n    }\n    result[0] = min;\n    copy.remove(min);\n    result[1]\
    \ = max;\n    copy.remove(max);\n    for (long i = 2; i < result.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            min = copy[0];\n     \
    \       foreach (long j; copy)\n            {\n                if (j < min)\n\
    \                    min = j;\n            }\n            result[i] = min;\n \
    \           copy.remove(min);\n        }\n        else\n        {\n          \
    \  max = copy[0];\n            foreach (long j; copy)\n            {\n       \
    \         if (j > max)\n                    max = j;\n            }\n        \
    \    result[i] = max;\n            copy.remove(max);\n        }\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    long min = sorted[0];\n    long max = sorted[sorted.length - 1];\n    bool\
    \ min_first = true;\n    foreach (i, val; lst)\n    {\n        if (min_first)\n\
    \        {\n            res[i] = min;\n            min_first = false;\n      \
    \  }\n        else\n        {\n            res[i] = max;\n            min_first\
    \ = true;\n        }\n        sorted.remove(val);\n        if (sorted.length ==\
    \ 0)\n            break;\n        min = sorted[0];\n        max = sorted[sorted.length\
    \ - 1];\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
