name: HumanEval_88_sort_array
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmqkkkyu.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbmqkkkyu.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbmqkkkyu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgm1w_r_q.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpgm1w_r_q.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgm1w_r_q.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool odd = (array[0] + array[array.length - 1]) %\
    \ 2 == 1;\n    if (odd)\n    {\n        array.sort!((a, b) => a > b);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc6lgipf7.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpc6lgipf7.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc6lgipf7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] result = new long[array.length];\n\
    \        long first = array[0];\n        long last = array[array.length - 1];\n\
    \        long sum = first + last;\n        if (sum % 2 == 0)\n        {\n    \
    \        sort(array);\n            reverse(array);\n            return array;\n\
    \        }\n        else\n        {\n            sort(array);\n            return\
    \ array;\n        }\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn519g3lk.d(33): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpn519g3lk.d(34): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpn519g3lk.d(39):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn519g3lk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt7l8uo78.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpt7l8uo78.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt7l8uo78.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] sortedArray = new long[array.length];\n   \
    \ int index = 0;\n    long sum = array[0] + array[array.length - 1];\n    if (sum\
    \ % 2 == 0)\n    {\n        for (int i = array.length - 1; i >= 0; i--)\n    \
    \    {\n            sortedArray[index] = array[i];\n            index++;\n   \
    \     }\n    }\n    else\n    {\n        for (int i = 0; i < array.length; i++)\n\
    \        {\n            sortedArray[index] = array[i];\n            index++;\n\
    \        }\n    }\n    return sortedArray;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps112clai.d(40): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmps112clai.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ss4ddpa.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp2ss4ddpa.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ss4ddpa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptbfah3k4.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmptbfah3k4.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptbfah3k4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        sort(array);\n\
    \        reverse(array);\n        return array;\n    }\n    else\n    {\n    \
    \    sort(array);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1sw3ofb3.d(28): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp1sw3ofb3.d(29): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp1sw3ofb3.d(34):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1sw3ofb3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk44f8l_p.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpk44f8l_p.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk44f8l_p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        // descending\n        array.sort!((a, b) => b - a);\n    }\n\
    \    else\n    {\n        // ascending\n        array.sort!((a, b) => a - b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_lvbe5o8.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp_lvbe5o8.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_lvbe5o8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg_pis0hg.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpg_pis0hg.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg_pis0hg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuc25psj0.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpuc25psj0.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuc25psj0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi3vmyo4n.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpi3vmyo4n.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi3vmyo4n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    bool isOdd = (first + last) % 2 == 1;\n    if (isOdd)\n    {\n  \
    \      array.sort!((a, b) => a < b);\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a > b);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvf0fbcoj.d(40): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpvf0fbcoj.d(44): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvf0fbcoj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] result = array.dup;\n\
    \        bool isOdd = (array[0] + array[$ - 1]) % 2 == 1;\n        if (isOdd)\n\
    \            result.sort!((a, b) => a > b);\n        else\n            result.sort!((a,\
    \ b) => a < b);\n        return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8zymmwo.d(30): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpd8zymmwo.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8zymmwo.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        long[] temp = array.dup;\n        temp.sort;\n        temp.reverse;\n\
    \        return temp;\n    }\n    else\n    {\n        long[] temp = array.dup;\n\
    \        temp.sort;\n        return temp;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpblk_h9ns.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpblk_h9ns.d(39): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpblk_h9ns.d(45):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpblk_h9ns.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps5sy3v6i.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmps5sy3v6i.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps5sy3v6i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] ret = array.dup;\n    if ((ret[0] +\
    \ ret[ret.length - 1]) % 2 == 0)\n    {\n        ret.sort!((a, b) => b - a);\n\
    \    }\n    else\n    {\n        ret.sort!((a, b) => a - b);\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt2bsy26o.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpt2bsy26o.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt2bsy26o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long sum = array[0] +\
    \ array[array.length - 1];\n        if (sum % 2 == 0)\n        {\n           \
    \ array.sort!((a, b) => b - a);\n            return array;\n        }\n      \
    \  else\n        {\n            array.sort!((a, b) => a - b);\n            return\
    \ array;\n        }\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqru6fntv.d(30): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpqru6fntv.d(35): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqru6fntv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    long\
    \ first = array[0];\n    long last = array[array.length - 1];\n    bool isOdd\
    \ = (first + last) % 2 == 1;\n    if (isOdd)\n    {\n        array.sort();\n \
    \       return array;\n    }\n    else\n    {\n        array.sort();\n       \
    \ array.reverse();\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxidpyih2.d(41): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxidpyih2.d(46): Error: no property `sort` for type `long[]`\\n/tmp/tmpxidpyih2.d(47):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpxidpyih2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        sort(array.ptr, array.ptr + array.length,\
    \ (a, b) => a > b);\n    }\n    else\n    {\n        sort(array.ptr, array.ptr\
    \ + array.length, (a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzeo1k57_.d(38): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpzeo1k57_.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpzeo1k57_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b > a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a > b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsg0sw76a.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpsg0sw76a.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsg0sw76a.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long tmp = array[0];\n       \
    \     array[0] = array[1];\n            array[1] = tmp;\n        }\n        return\
    \ array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1]) % 2 ==\
    \ 1;\n    if (isOdd)\n    {\n        sort(array);\n    }\n    else\n    {\n  \
    \      sort(array, (a, b) => b - a);\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyk1g5lbe.d(38): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpyk1g5lbe.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyk1g5lbe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    int i = 0;\n  \
    \  int j = array.length - 1;\n    int k = 0;\n    bool isOdd = (array[0] + array[array.length\
    \ - 1]) % 2 == 1;\n    while (i <= j)\n    {\n        if (isOdd)\n        {\n\
    \            if (array[i] % 2 == 1)\n            {\n                result[k]\
    \ = array[i];\n                i++;\n            }\n            else\n       \
    \     {\n                result[k] = array[j];\n                j--;\n       \
    \     }\n        }\n        else\n        {\n            if (array[i] % 2 == 1)\n\
    \            {\n                result[k] = array[j];\n                j--;\n\
    \            }\n            else\n            {\n                result[k] = array[i];\n\
    \                i++;\n            }\n        }\n        k++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg7f17dbf.d(23): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg7f17dbf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfucjbf7y.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpfucjbf7y.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfucjbf7y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    \n    long first = array[0];\n    long last\
    \ = array[array.length - 1];\n    long sum = first + last;\n    bool isOdd = (sum\
    \ % 2 == 1);\n    \n    if (isOdd)\n        return array.sort();\n    else\n \
    \       return array.sort!((a, b) => b - a);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf53pxcfk.d(32): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpf53pxcfk.d(34): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf53pxcfk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    int i = 0;\n  \
    \  int j = array.length - 1;\n    int k = 0;\n    if(array.length == 0)\n    \
    \    return result;\n    if(array.length == 1)\n        return array;\n    if((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        while(i <= j)\n       \
    \ {\n            if(array[i] % 2 == 0)\n            {\n                result[k]\
    \ = array[i];\n                i++;\n                k++;\n            }\n   \
    \         if(array[j] % 2 == 0)\n            {\n                result[k] = array[j];\n\
    \                j--;\n                k++;\n            }\n            if(array[i]\
    \ % 2 != 0)\n            {\n                i++;\n            }\n            if(array[j]\
    \ % 2 != 0)\n            {\n                j--;\n            }\n        }\n \
    \       return result;\n    }\n    else\n    {\n        while(i <= j)\n      \
    \  {\n            if(array[i] % 2 != 0)\n            {\n                result[k]\
    \ = array[i];\n                i++;\n                k++;\n            }\n   \
    \         if(array[j] % 2 != 0)\n            {\n                result[k] = array[j];\n\
    \                j--;\n                k++;\n            }\n            if(array[i]\
    \ % 2 == 0)\n            {\n                i++;\n            }\n            if(array[j]\
    \ % 2 == 0)\n            {\n                j--;\n            }\n        }\n \
    \       return result;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjliy8x90.d(23): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjliy8x90.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if(array.length == 0)\n    \
    \    return result;\n    if(array.length == 1)\n        return result;\n    if(array[0]\
    \ + array[array.length - 1] % 2 == 0)\n    {\n        result.sort!((a, b) => a\
    \ > b);\n    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj9h7u2xe.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpj9h7u2xe.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9h7u2xe.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] sortedArray = new long[array.length];\n   \
    \ long[] oddArray = new long[array.length];\n    long[] evenArray = new long[array.length];\n\
    \    long[] oddSortedArray = new long[array.length];\n    long[] evenSortedArray\
    \ = new long[array.length];\n    long[] oddSortedArray2 = new long[array.length];\n\
    \    long[] evenSortedArray2 = new long[array.length];\n    long[] oddSortedArray3\
    \ = new long[array.length];\n    long[] evenSortedArray3 = new long[array.length];\n\
    \    long[] oddSortedArray4 = new long[array.length];\n    long[] evenSortedArray4\
    \ = new long[array.length];\n    long[] oddSortedArray5 = new long[array.length];\n\
    \    long[] evenSortedArray5 = new long[array.length];\n    long[] oddSortedArray6\
    \ = new long[array.length];\n    long[] evenSortedArray6 = new long[array.length];\n\
    \    long[] oddSortedArray7 = new long[array.length];\n    long[] evenSortedArray7\
    \ = new long[array.length];\n    long[] oddSortedArray8 = new long[array.length];\n\
    \    long[] evenSortedArray8 = new long[array.length];\n    long[] oddSortedArray9\
    \ = new long[array.length];\n    long[] evenSortedArray9 = new long[array.length];\n\
    \    long[] oddSortedArray10 = new long[array.length];\n    long[] evenSortedArray10\
    \ = new long[array.length];\n    long[] oddSortedArray11 = new long[array.length];\n\
    \    long[] evenSortedArray11 = new long[array\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwjx3q_63.d(60): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpwjx3q_63.d(61): Error: semicolon expected, not `{`\\n/tmp/tmpwjx3q_63.d(72):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwjx3q_63.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a,\
    \ b) => a < b);\n    }\n    else\n    {\n        array.sort!((a, b) => a > b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqb1teghb.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpqb1teghb.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqb1teghb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps05buddr.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmps05buddr.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps05buddr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long[] result = array.dup;\n    if ((array[0] + array[array.length\
    \ - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) => a > b);\n    }\n    else\n\
    \    {\n        result.sort!((a, b) => a < b);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp75e_0f52.d(26): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp75e_0f52.d(30): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp75e_0f52.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        foreach\
    \ (i, v; array)\n            result[i] = v;\n        sort(result);\n        reverse(result);\n\
    \    }\n    else\n    {\n        foreach (i, v; array)\n            result[i]\
    \ = v;\n        sort(result);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpla6tpw0p.d(30): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpla6tpw0p.d(31): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpla6tpw0p.d(37):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpla6tpw0p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        long[] temp = array.dup;\n\
    \        temp.sort(std.numeric.comparison);\n        for (int i = 0; i < array.length;\
    \ i++)\n        {\n            result[i] = temp[array.length - 1 - i];\n     \
    \   }\n    }\n    else\n    {\n        long[] temp = array.dup;\n        temp.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n        {\n            result[i]\
    \ = temp[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb9l5opwv.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpb9l5opwv.d(48): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb9l5opwv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        int i = 0;\n        for\
    \ (int j = array.length - 1; j >= 0; j--)\n        {\n            result[i] =\
    \ array[j];\n            i++;\n        }\n    }\n    else\n    {\n        result\
    \ = array;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprt0l99qs.d(27): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprt0l99qs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5bewdld4.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5bewdld4.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bewdld4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] array_copy = array.dup;\n\
    \        if ((array_copy[0] + array_copy[array_copy.length - 1]) % 2 == 0)\n \
    \           array_copy.sort!((a, b) => b - a);\n        else\n            array_copy.sort!((a,\
    \ b) => a - b);\n        return array_copy;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcdujq_f_.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpcdujq_f_.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdujq_f_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] odd = new\
    \ long[array.length];\n    long[] even = new long[array.length];\n    int odd_index\
    \ = 0;\n    int even_index = 0;\n    foreach(i; array)\n    {\n        if(i %\
    \ 2 == 0)\n        {\n            even[even_index] = i;\n            even_index++;\n\
    \        }\n        else\n        {\n            odd[odd_index] = i;\n       \
    \     odd_index++;\n        }\n    }\n    sort(odd[0..odd_index]);\n    sort(even[0..even_index]);\n\
    \    if(array.length > 0 && (array[0] + array[array.length - 1]) % 2 == 0)\n \
    \   {\n        even = even[0..even_index].reverse;\n    }\n    int index = 0;\n\
    \    foreach(i; odd[0..odd_index])\n    {\n        result[index] = i;\n      \
    \  index++;\n    }\n    foreach(i; even[0..even_index])\n    {\n        result[index]\
    \ = i;\n        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0mfehuz7.d(39): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp0mfehuz7.d(40): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmp0mfehuz7.d(43): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp0mfehuz7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] ret = array.dup;\n    if (array.length == 0)\n      \
    \  return ret;\n    if (array.length == 1)\n        return ret;\n    if (array[0]\
    \ + array[array.length - 1] % 2 == 0)\n    {\n        ret.sort!((a, b) => a >\
    \ b);\n    }\n    else\n    {\n        ret.sort!((a, b) => a < b);\n    }\n  \
    \  return ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptlw02j6a.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmptlw02j6a.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptlw02j6a.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return (array[0] > array[1]) ?\
    \ array : array.reverse();\n    long sum = array[0] + array[array.length - 1];\n\
    \    if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_u0jkxad.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp_u0jkxad.d(27):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmp_u0jkxad.d(31): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_u0jkxad.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3voui7i7.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3voui7i7.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3voui7i7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] ret = array.dup;\n    if (array.length == 0)\n      \
    \  return ret;\n    if (array.length == 1)\n        return ret;\n    if (array[0]\
    \ + array[array.length - 1] % 2 == 0)\n    {\n        ret.sort!((a, b) => b -\
    \ a);\n    }\n    else\n    {\n        ret.sort!((a, b) => a - b);\n    }\n  \
    \  return ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ehvdycu.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6ehvdycu.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ehvdycu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b > a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9f7d9ljg.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp9f7d9ljg.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9f7d9ljg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] temp = new\
    \ long[array.length];\n    long[] temp2 = new long[array.length];\n    long[]\
    \ temp3 = new long[array.length];\n    long[] temp4 = new long[array.length];\n\
    \    long[] temp5 = new long[array.length];\n    long[] temp6 = new long[array.length];\n\
    \    long[] temp7 = new long[array.length];\n    long[] temp8 = new long[array.length];\n\
    \    long[] temp9 = new long[array.length];\n    long[] temp10 = new long[array.length];\n\
    \    long[] temp11 = new long[array.length];\n    long[] temp12 = new long[array.length];\n\
    \    long[] temp13 = new long[array.length];\n    long[] temp14 = new long[array.length];\n\
    \    long[] temp15 = new long[array.length];\n    long[] temp16 = new long[array.length];\n\
    \    long[] temp17 = new long[array.length];\n    long[] temp18 = new long[array.length];\n\
    \    long[] temp19 = new long[array.length];\n    long[] temp20 = new long[array.length];\n\
    \    long[] temp21 = new long[array.length];\n    long[] temp22 = new long[array.length];\n\
    \    long[] temp23 = new long[array.length];\n    long[] temp24 = new long[array.length];\n\
    \    long[] temp25 = new long[array.length];\n    long[] temp26 = new long[array.length];\n\
    \    long[] temp27 = new long[array.length];\n    long[] temp28 = new long[array.length];\n\
    \    long[] temp29 = new long[array.length];\n    long[] temp30 = new long[array.length];\n\
    \    long[] temp31 = new long[array.length];\n    long[] temp32 = new long[array.length];\n\
    \    long[] temp33 = new long[array.length];\n    long[] temp34 = new long[array.length];\n\
    \    long[] temp35 = new long[array.length];\n    long[] temp36 = new\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnsf2i83h.d(58): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpnsf2i83h.d(58): Error: semicolon expected, not `unittest`\\n/tmp/tmpnsf2i83h.d(58):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnsf2i83h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    bool isEven = (array[0] + array[array.length\
    \ - 1]) % 2 == 0;\n    if (isEven)\n    {\n        array.sort!((a, b) => a > b);\n\
    \    }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz0ip7205.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpz0ip7205.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz0ip7205.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isEven = (array[0] + array[array.length - 1])\
    \ % 2 == 0;\n    if (isEven)\n    {\n        array.sort!((a, b) => b - a);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkf9vp4b.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpqkf9vp4b.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqkf9vp4b.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a < b);\n        return array;\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a > b);\n        return array;\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd9hieigv.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpd9hieigv.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd9hieigv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        for (int i = 0; i < array.length;\
    \ i++)\n        {\n            result[i] = array[array.length - 1 - i];\n    \
    \    }\n    }\n    else\n    {\n        for (int i = 0; i < array.length; i++)\n\
    \        {\n            result[i] = array[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuu0z0l63.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428835]\\n??:? void tmpuu0z0l63.__unittest_L52_C1()\
    \ [0x428236]\\n??:? void tmpuu0z0l63.__modtest() [0x4285b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b782]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430a0d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430999]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b759]\\n??:? runModuleUnitTests [0x42c6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428cf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428c7f]\\n??:? _d_run_main [0x428bea]\\n??:? main [0x4285c7]\\\
    n??:? __libc_start_main [0x6de38554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsqlvlsvs.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpsqlvlsvs.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsqlvlsvs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a < b);\n        return array;\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a > b);\n        return array;\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmqiafgh1.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpmqiafgh1.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqiafgh1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuphne8gd.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpuphne8gd.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuphne8gd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long sum = array[0] + array[array.length - 1];\n    if(sum %\
    \ 2 == 0)\n    {\n        array.sort(std.numeric.comparisonFunctor!(\"a > b\"\
    ));\n    }\n    else\n    {\n        array.sort(std.numeric.comparisonFunctor!(\"\
    a < b\"));\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphzk84vs6.d(24): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmphzk84vs6.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphzk84vs6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphtakqoat.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmphtakqoat.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphtakqoat.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] sorted = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        sorted.sort!((a, b) =>\
    \ a > b);\n    }\n    else\n    {\n        sorted.sort!((a, b) => a < b);\n  \
    \  }\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7_g86r8n.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp7_g86r8n.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7_g86r8n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) =>\
    \ a < b);\n    }\n    else\n    {\n        result.sort!((a, b) => a > b);\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4xtlg9wi.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp4xtlg9wi.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4xtlg9wi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if (result.length == 0)\n  \
    \      return result;\n    if (result.length == 1)\n        return result;\n \
    \   if (result[0] + result[result.length - 1] % 2 == 0)\n    {\n        result.sort!((a,\
    \ b) => b - a);\n    }\n    else\n    {\n        result.sort!((a, b) => a - b);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe3z9qod1.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpe3z9qod1.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe3z9qod1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n            result[i] = array[array.length\
    \ - 1 - i];\n    }\n    else\n    {\n        array.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n            result[i] = array[i];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_6meas7.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpp_6meas7.d(34): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_6meas7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    long sum = array[0] + array[array.length - 1];\n    if(sum % 2 == 0)\n  \
    \  {\n        array.sort(std.numeric.cmp.greater);\n        return array;\n  \
    \  }\n    else\n    {\n        array.sort(std.numeric.cmp.less);\n        return\
    \ array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3lzmrzux.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3lzmrzux.d(34): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3lzmrzux.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp13f842du.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp13f842du.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp13f842du.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(array.ptr, array.ptr + array.length);\n\
    \    }\n    else\n    {\n        sort(array.ptr, array.ptr + array.length, std.numeric.comparison.greater!long);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprkx60vxw.d(38): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmprkx60vxw.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprkx60vxw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeq5latsg.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpeq5latsg.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeq5latsg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    long[]\
    \ left = new long[array.length / 2];\n    long[] right = new long[array.length\
    \ - array.length / 2];\n    for (int i = 0; i < array.length / 2; i++)\n     \
    \   left[i] = array[i];\n    for (int i = array.length / 2; i < array.length;\
    \ i++)\n        right[i - array.length / 2] = array[i];\n    left = sort_array(left);\n\
    \    right = sort_array(right);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    while (i < left.length && j < right.length)\n    {\n        if (left[i] <\
    \ right[j])\n        {\n            result[k] = left[i];\n            i++;\n \
    \       }\n        else\n        {\n            result[k] = right[j];\n      \
    \      j++;\n        }\n        k++;\n    }\n    while (i < left.length)\n   \
    \ {\n        result[k] = left[i];\n        i++;\n        k++;\n    }\n    while\
    \ (j < right.length)\n    {\n        result[k] = right[j];\n        j++;\n   \
    \     k++;\n    }\n    if ((result[0] + result[result.length - 1]) % 2 == 0)\n\
    \    {\n        for (int l = 0; l < result.length / 2; l++)\n        {\n     \
    \       long temp = result[l];\n            result[l] = result[result.length -\
    \ 1 - l];\n            result[result.length - 1 - l] = temp;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaaphy1ln.d(40): Error: cannot implicitly convert expression `array.length\
    \ / 2LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpaaphy1ln.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    bool odd = (first + last) % 2 == 1;\n    if (odd)\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a > b);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxn1_zoj9.d(40): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxn1_zoj9.d(44): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxn1_zoj9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0zp6nae3.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp0zp6nae3.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0zp6nae3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return (array[0] > array[1]) ?\
    \ array : array.reverse();\n    if (array[0] + array[$ - 1] % 2 == 0) return array.sort(std.math.cmp);\n\
    \    return array.sort(std.math.cmp).reverse();\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm652dg68.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpm652dg68.d(24):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmpm652dg68.d(25): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpm652dg68.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort();\n\
    \    }\n    else\n    {\n        array.sort(std.comparisonFunctor!(\">\"));\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp84kdu_rt.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp84kdu_rt.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp84kdu_rt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long[] result = array.dup;\n    bool odd = (array[0] +\
    \ array[$ - 1]) % 2 == 1;\n    if (odd)\n    {\n        result.sort!((a, b) =>\
    \ a < b);\n    }\n    else\n    {\n        result.sort!((a, b) => a > b);\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnt3trgu.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjnt3trgu.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnt3trgu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        sort(array);\n\
    \        for (int i = 0; i < array.length; i++)\n            result[i] = array[array.length\
    \ - 1 - i];\n    }\n    else\n    {\n        sort(array);\n        for (int i\
    \ = 0; i < array.length; i++)\n            result[i] = array[i];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl39xx2jg.d(28): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpl39xx2jg.d(34): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpl39xx2jg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long sum = array[0] +\
    \ array[array.length - 1];\n        if (sum % 2 == 0)\n        {\n           \
    \ array.sort!((a, b) => b - a);\n            return array;\n        }\n      \
    \  else\n        {\n            array.sort!((a, b) => a - b);\n            return\
    \ array;\n        }\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphzopp9qe.d(30): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmphzopp9qe.d(35): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphzopp9qe.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2)\n    {\n        if (array[0] >\
    \ array[1])\n        {\n            long temp = array[0];\n            array[0]\
    \ = array[1];\n            array[1] = temp;\n        }\n        return array;\n\
    \    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a > b);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzxgki19q.d(35): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpzxgki19q.d(39): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzxgki19q.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort(std.numeric.cmp.greater);\n\
    \        return array;\n    }\n    else\n    {\n        array.sort(std.numeric.cmp.less);\n\
    \        return array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ms_kl6l.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp0ms_kl6l.d(33): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ms_kl6l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    auto result = array.dup;\n    if (array.length == 0)\n     \
    \   return result;\n    if (array.length == 1)\n        return result;\n    auto\
    \ sum = array[0] + array[$-1];\n    if (sum % 2 == 0)\n    {\n        sort(result,\
    \ (a, b) => a < b);\n    }\n    else\n    {\n        sort(result, (a, b) => a\
    \ > b);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4s7mqjc2.d(29): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp4s7mqjc2.d(33): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4s7mqjc2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyuptz63d.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpyuptz63d.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyuptz63d.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprvny0hg9.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmprvny0hg9.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprvny0hg9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkkomu47.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpqkkomu47.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqkkomu47.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if (array.length == 0)\n   \
    \     return result;\n    if (array.length == 1)\n        return result;\n   \
    \ if (array[0] + array[array.length - 1] % 2 == 0)\n    {\n        result.sort!((a,\
    \ b) => b < a);\n    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpktex1rad.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpktex1rad.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpktex1rad.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] temp = new\
    \ long[array.length];\n    long[] temp2 = new long[array.length];\n    long[]\
    \ temp3 = new long[array.length];\n    long[] temp4 = new long[array.length];\n\
    \    long[] temp5 = new long[array.length];\n    long[] temp6 = new long[array.length];\n\
    \    long[] temp7 = new long[array.length];\n    long[] temp8 = new long[array.length];\n\
    \    long[] temp9 = new long[array.length];\n    long[] temp10 = new long[array.length];\n\
    \    long[] temp11 = new long[array.length];\n    long[] temp12 = new long[array.length];\n\
    \    long[] temp13 = new long[array.length];\n    long[] temp14 = new long[array.length];\n\
    \    long[] temp15 = new long[array.length];\n    long[] temp16 = new long[array.length];\n\
    \    long[] temp17 = new long[array.length];\n    long[] temp18 = new long[array.length];\n\
    \    long[] temp19 = new long[array.length];\n    long[] temp20 = new long[array.length];\n\
    \    long[] temp21 = new long[array.length];\n    long[] temp22 = new long[array.length];\n\
    \    long[] temp23 = new long[array.length];\n    long[] temp24 = new long[array.length];\n\
    \    long[] temp25 = new long[array.length];\n    long[] temp26 = new long[array.length];\n\
    \    long[] temp27 = new long[array.length];\n    long[] temp28 = new long[array.length];\n\
    \    long[] temp29 = new long[array.length];\n    long[] temp30 = new long[array.length];\n\
    \    long[] temp31 = new long[array.length];\n    long[] temp32 = new long[array.length];\n\
    \    long[] temp33 = new long[array.length];\n    long[] temp34 = new long[array.length];\n\
    \    long[] temp35 = new long[array.length];\n    long[] temp36 = new\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnys5q385.d(58): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpnys5q385.d(58): Error: semicolon expected, not `unittest`\\n/tmp/tmpnys5q385.d(58):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnys5q385.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        long[] result = new long[array.length];\n\
    \        for (int i = 0; i < array.length; i++)\n        {\n            result[i]\
    \ = array[array.length - 1 - i];\n        }\n        return result;\n    }\n \
    \   else\n    {\n        long[] result = new long[array.length];\n        for\
    \ (int i = 0; i < array.length; i++)\n        {\n            result[i] = array[i];\n\
    \        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpm1e8tlb6.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42886d]\\n??:? void tmpm1e8tlb6.__unittest_L55_C1()\
    \ [0x428272]\\n??:? void tmpm1e8tlb6.__modtest() [0x4285f0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c927]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b7ba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430a45]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ef4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4309d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b791]\\n??:? runModuleUnitTests [0x42c6fd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d30]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428cb7]\\n??:? _d_run_main [0x428c22]\\n??:? main [0x428603]\\\
    n??:? __libc_start_main [0x78bac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfe3nl0nq.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpfe3nl0nq.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfe3nl0nq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        for (int\
    \ i = 0; i < array.length; i++)\n        {\n            result[i] = array[array.length\
    \ - 1 - i];\n        }\n    }\n    else\n    {\n        for (int i = 0; i < array.length;\
    \ i++)\n        {\n            result[i] = array[i];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnnoooe82.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpnnoooe82.__unittest_L42_C1()\
    \ [0x42814e]\\n??:? void tmpnnoooe82.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0x34cca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isEven = (array[0] + array[array.length - 1])\
    \ % 2 == 0;\n    if (isEven)\n    {\n        array.sort!((a, b) => a < b);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwp891uo_.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwp891uo_.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwp891uo_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2iksvkmf.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp2iksvkmf.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2iksvkmf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppq4wtsef.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmppq4wtsef.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppq4wtsef.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if (array.length\
    \ == 0)\n        return result;\n    if (array.length == 1)\n        return array;\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        foreach\
    \ (i, v; array)\n            result[i] = v;\n        sort(result);\n        reverse(result);\n\
    \    }\n    else\n    {\n        foreach (i, v; array)\n            result[i]\
    \ = v;\n        sort(result);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpic_t03nq.d(30): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpic_t03nq.d(31): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpic_t03nq.d(37):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpic_t03nq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzgagxunj.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpzgagxunj.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgagxunj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] odd = new\
    \ long[array.length];\n    long[] even = new long[array.length];\n    int odd_index\
    \ = 0;\n    int even_index = 0;\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        if (array[i] % 2 == 0)\n        {\n            even[even_index]\
    \ = array[i];\n            even_index++;\n        }\n        else\n        {\n\
    \            odd[odd_index] = array[i];\n            odd_index++;\n        }\n\
    \    }\n    if (odd_index > 0)\n    {\n        sort(odd[0..odd_index]);\n    }\n\
    \    if (even_index > 0)\n    {\n        sort(even[0..even_index]);\n        reverse(even[0..even_index]);\n\
    \    }\n    int j = 0;\n    for (int i = 0; i < odd_index; i++)\n    {\n     \
    \   result[j] = odd[i];\n        j++;\n    }\n    for (int i = 0; i < even_index;\
    \ i++)\n    {\n        result[j] = even[i];\n        j++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgmxa22tv.d(41): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpgmxa22tv.d(45): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmpgmxa22tv.d(46): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpgmxa22tv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n            result[i] = array[array.length\
    \ - 1 - i];\n    }\n    else\n    {\n        array.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n            result[i] = array[i];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8s34dbtz.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8s34dbtz.d(34): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8s34dbtz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    \n    bool\
    \ isAscending = (array[0] + array[$ - 1]) % 2 == 1;\n    if (isAscending)\n  \
    \      return array.sort();\n    else\n        return array.sort!((a, b) => b\
    \ - a);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmhisnmz3.d(26): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpmhisnmz3.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmhisnmz3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    auto sum\
    \ = array[0] + array[$ - 1];\n    if (sum % 2 == 0)\n        return array.sort!((a,\
    \ b) => b < a);\n    else\n        return array.sort!((a, b) => a < b);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpicnl7n86.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpicnl7n86.d(27): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpicnl7n86.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv_e0ninh.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpv_e0ninh.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_e0ninh.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2)\n    {\n        if ((array[0] +\
    \ array[1]) % 2 == 0)\n        {\n            long temp = array[0];\n        \
    \    array[0] = array[1];\n            array[1] = temp;\n        }\n        return\
    \ array;\n    }\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        long[] temp = array.dup;\n\
    \        temp.sort(std.math.cmp(a, b) => b - a);\n        result = temp;\n   \
    \ }\n    else\n    {\n        long[] temp = array.dup;\n        temp.sort(std.math.cmp(a,\
    \ b) => a - b);\n        result = temp;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_kalpt8.d(37): Error: found `=>` when expecting `,`\\n/tmp/tmpz_kalpt8.d(43):\
    \ Error: found `=>` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpz_kalpt8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a,\
    \ b) => a < b);\n    }\n    else\n    {\n        array.sort!((a, b) => a > b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplthyestr.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmplthyestr.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplthyestr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkt0bva7s.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpkt0bva7s.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkt0bva7s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    long sum = first + last;\n    bool isOdd = sum % 2 == 1;\n    if\
    \ (isOdd)\n    {\n        array.sort();\n    }\n    else\n    {\n        array.sort();\n\
    \        array.reverse();\n    }\n    return array;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv6co95lp.d(41): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpv6co95lp.d(45): Error: no property `sort` for type `long[]`\\n/tmp/tmpv6co95lp.d(46):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpv6co95lp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjum7ulp6.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjum7ulp6.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjum7ulp6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool is_odd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (is_odd)\n    {\n        array.sort!((a, b) => a > b);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1ud3kizy.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp1ud3kizy.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ud3kizy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if (result.length == 0)\n  \
    \      return result;\n    bool isOdd = (result[0] + result[$-1]) % 2 == 1;\n\
    \    if (isOdd)\n        result.sort!((a, b) => a > b);\n    else\n        result.sort!((a,\
    \ b) => a < b);\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5apiyzi7.d(26): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5apiyzi7.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5apiyzi7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl1cm9po5.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpl1cm9po5.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl1cm9po5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        sort(array);\n        return array;\n    }\n    else\n    {\n\
    \        sort(array);\n        reverse(array);\n        return array;\n    }\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppkti56_u.d(37): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmppkti56_u.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmppkti56_u.d(43): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmppkti56_u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array = array.sort();\n        array = array.reverse();\n\
    \    }\n    else\n    {\n        array = array.sort();\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf1os937a.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpf1os937a.d(39): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpf1os937a.d(43):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf1os937a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    bool isOdd = (first + last) % 2 == 1;\n    if (isOdd)\n    {\n  \
    \      array.sort!((a, b) => a < b);\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a > b);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9w5_5b56.d(40): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp9w5_5b56.d(44): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9w5_5b56.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] temp = new\
    \ long[array.length];\n    long[] temp2 = new long[array.length];\n    long[]\
    \ temp3 = new long[array.length];\n    long[] temp4 = new long[array.length];\n\
    \    long[] temp5 = new long[array.length];\n    long[] temp6 = new long[array.length];\n\
    \    long[] temp7 = new long[array.length];\n    long[] temp8 = new long[array.length];\n\
    \    long[] temp9 = new long[array.length];\n    long[] temp10 = new long[array.length];\n\
    \    long[] temp11 = new long[array.length];\n    long[] temp12 = new long[array.length];\n\
    \    long[] temp13 = new long[array.length];\n    long[] temp14 = new long[array.length];\n\
    \    long[] temp15 = new long[array.length];\n    long[] temp16 = new long[array.length];\n\
    \    long[] temp17 = new long[array.length];\n    long[] temp18 = new long[array.length];\n\
    \    long[] temp19 = new long[array.length];\n    long[] temp20 = new long[array.length];\n\
    \    long[] temp21 = new long[array.length];\n    long[] temp22 = new long[array.length];\n\
    \    long[] temp23 = new long[array.length];\n    long[] temp24 = new long[array.length];\n\
    \    long[] temp25 = new long[array.length];\n    long[] temp26 = new long[array.length];\n\
    \    long[] temp27 = new long[array.length];\n    long[] temp28 = new long[array.length];\n\
    \    long[] temp29 = new long[array.length];\n    long[] temp30 = new long[array.length];\n\
    \    long[] temp31 = new long[array.length];\n    long[] temp32 = new long[array.length];\n\
    \    long[] temp33 = new long[array.length];\n    long[] temp34 = new long[array.length];\n\
    \    long[] temp35 = new long[array.length];\n    long[] temp36 = new\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppy0qb0jx.d(58): Error: basic type expected, not `unittest`\\\
    n/tmp/tmppy0qb0jx.d(58): Error: semicolon expected, not `unittest`\\n/tmp/tmppy0qb0jx.d(58):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppy0qb0jx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    bool isOdd = (array[0] + array[$-1]) % 2 == 1;\n    auto\
    \ sorted = array.dup;\n    if (isOdd)\n    {\n        sorted.sort!((a, b) => a\
    \ < b);\n    }\n    else\n    {\n        sorted.sort!((a, b) => a > b);\n    }\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp22jr_b7k.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp22jr_b7k.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp22jr_b7k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort(std.numeric.comparisonFunctor!(\"\
    a > b\"));\n    }\n    else\n    {\n        array.sort(std.numeric.comparisonFunctor!(\"\
    a < b\"));\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplu6dvf2c.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmplu6dvf2c.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplu6dvf2c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        long[]\
    \ temp = array.dup;\n        temp.sort;\n        temp.reverse;\n        return\
    \ temp;\n    }\n    else\n    {\n        array.sort;\n        return array;\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmdkyc8v8.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpmdkyc8v8.d(30): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpmdkyc8v8.d(35):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpmdkyc8v8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = ((array[0] + array[array.length - 1])\
    \ % 2 == 1);\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdu0g_ijz.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpdu0g_ijz.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdu0g_ijz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = new long[array.length];\n\
    \    bool isOdd = (array[0] + array[array.length - 1]) % 2 == 1;\n    if (isOdd)\n\
    \    {\n        result = array.sort();\n    }\n    else\n    {\n        result\
    \ = array.sort(std.numeric.comparisonFunctor!(\"a > b\"));\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpixdrzktt.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpixdrzktt.d(33): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpixdrzktt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 != 0;\n    if (isOdd)\n    {\n        array.sort!((a,\
    \ b) => a < b);\n    }\n    else\n    {\n        array.sort!((a, b) => a > b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ha_xxtc.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp9ha_xxtc.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ha_xxtc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppxmpsjuu.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmppxmpsjuu.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppxmpsjuu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return (array[0] > array[1]) ?\
    \ array : array.reverse();\n    if (array[0] + array[array.length - 1] % 2 ==\
    \ 0)\n    {\n        return array.sort( (a, b) => a > b ? -1 : 1 );\n    }\n \
    \   else\n    {\n        return array.sort( (a, b) => a < b ? -1 : 1 );\n    }\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl8qs4_qr.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpl8qs4_qr.d(26):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmpl8qs4_qr.d(30): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpl8qs4_qr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(array);\n    }\n    else\n  \
    \  {\n        sort(array.dup.reverse);\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe3gyvyqh.d(38): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpe3gyvyqh.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpe3gyvyqh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2)\n    {\n        if ((array[0] +\
    \ array[1]) % 2 == 0)\n        {\n            long temp = array[0];\n        \
    \    array[0] = array[1];\n            array[1] = temp;\n        }\n        return\
    \ array;\n    }\n    long[] odd = array.filter!(x => x % 2 != 0).sort!((a, b)\
    \ => a > b ? 1 : -1);\n    long[] even = array.filter!(x => x % 2 == 0).sort!((a,\
    \ b) => a < b ? 1 : -1);\n    return array.map!(x => x % 2 == 0 ? even.popFront()\
    \ : odd.popFront()).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjjaifhz6.d(33): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpjjaifhz6.d(34): Error: no property `filter` for type `long[]`\\n/tmp/tmpjjaifhz6.d(35):\
    \ Error: no property `map` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjjaifhz6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool odd = (array[0] + array[array.length - 1]) %\
    \ 2 == 1;\n    if (odd)\n    {\n        array.sort!((a, b) => a > b);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwb6ko9s5.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwb6ko9s5.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwb6ko9s5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if (array.length == 0) return\
    \ result;\n    if (array.length == 1) return result;\n    long sum = array[0]\
    \ + array[$-1];\n    if (sum % 2 == 0)\n    {\n        result.sort!((a, b) =>\
    \ b < a);\n    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43f9km_t.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp43f9km_t.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43f9km_t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdnijy140.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpdnijy140.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdnijy140.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[$ - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) => b < a);\n \
    \   }\n    else\n    {\n        result.sort!((a, b) => a < b);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5qd7hecd.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5qd7hecd.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5qd7hecd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphiupttk3.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmphiupttk3.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphiupttk3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    bool isEven = (first + last) % 2 == 0;\n    if (isEven)\n    {\n\
    \        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn877ac6x.d(40): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpn877ac6x.d(44): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn877ac6x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        sort(array);\n\
    \        reverse(array);\n        return array;\n    }\n    else\n    {\n    \
    \    sort(array);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18_bdw51.d(28): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp18_bdw51.d(29): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp18_bdw51.d(34):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18_bdw51.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6f5py7iw.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6f5py7iw.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6f5py7iw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long first = array[0];\n\
    \        long last = array[array.length - 1];\n        long sum = first + last;\n\
    \        if (sum % 2 == 0)\n        {\n            array.sort!((a, b) => b < a);\n\
    \            return array;\n        }\n        else\n        {\n            array.sort!((a,\
    \ b) => a < b);\n            return array;\n        }\n    }\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnonayhm_.d(32): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpnonayhm_.d(37): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnonayhm_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    if ((first + last) % 2 == 0)\n    {\n        array.sort!((a, b) =>\
    \ a < b);\n    }\n    else\n    {\n        array.sort!((a, b) => a > b);\n   \
    \ }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp804ljfdl.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp804ljfdl.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp804ljfdl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        long[] result = new long[array.length];\n        int index = 0;\n\
    \        for (int i = array.length - 1; i >= 0; i--)\n        {\n            result[index]\
    \ = array[i];\n            index++;\n        }\n        return result;\n    }\n\
    \    else\n    {\n        long[] result = new long[array.length];\n        int\
    \ index = 0;\n        for (int i = 0; i < array.length; i++)\n        {\n    \
    \        result[index] = array[i];\n            index++;\n        }\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy7jpjqv0.d(39): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpy7jpjqv0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp357b2_nj.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp357b2_nj.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp357b2_nj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long first = array[0];\n    long last = array[array.length\
    \ - 1];\n    bool isOdd = (first + last) % 2 == 1;\n    if (isOdd)\n    {\n  \
    \      sort(array);\n    }\n    else\n    {\n        sort(array, std.greater!long());\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpytnpw3s9.d(40): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpytnpw3s9.d(44): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpytnpw3s9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        long[]\
    \ temp = array.dup;\n        temp.sort;\n        temp.reverse;\n        return\
    \ temp;\n    }\n    else\n    {\n        long[] temp = array.dup;\n        temp.sort;\n\
    \        return temp;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvkiovk8z.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpvkiovk8z.d(30): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpvkiovk8z.d(36):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvkiovk8z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) =>\
    \ b - a);\n    }\n    else\n    {\n        result.sort!((a, b) => a - b);\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjesq9jes.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjesq9jes.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjesq9jes.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort();\n\
    \    }\n    else\n    {\n        array.sort!((a, b) => b - a)();\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8wufj93n.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8wufj93n.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wufj93n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] result = array.dup;\n\
    \        if ((array[0] + array[$ - 1]) % 2 == 0)\n            result.sort!((a,\
    \ b) => b - a);\n        else\n            result.sort!((a, b) => a - b);\n  \
    \      return result;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps78xj8ox.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmps78xj8ox.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps78xj8ox.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long sum = array[0] + array[array.length -\
    \ 1];\n    if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n \
    \   }\n    else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp21rrg3si.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp21rrg3si.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp21rrg3si.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpats3hjyk.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpats3hjyk.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpats3hjyk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ljtfrmi.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3ljtfrmi.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ljtfrmi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] result = array.dup;\n\
    \        if ((array[0] + array[$ - 1]) % 2 == 0)\n            result.sort!((a,\
    \ b) => b - a);\n        else\n            result.sort!((a, b) => a - b);\n  \
    \      return result;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6zt_ne0x.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6zt_ne0x.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zt_ne0x.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a,\
    \ b) => a > b);\n    }\n    else\n    {\n        array.sort!((a, b) => a < b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw85zc5hr.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpw85zc5hr.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw85zc5hr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    else if (array.length\
    \ == 1)\n        return array;\n    else\n    {\n        long[] result = new long[array.length];\n\
    \        long first = array[0];\n        long last = array[array.length - 1];\n\
    \        long sum = first + last;\n        if (sum % 2 == 0)\n        {\n    \
    \        array.sort(std.numeric.cmp.greater);\n            return array;\n   \
    \     }\n        else\n        {\n            array.sort(std.numeric.cmp.less);\n\
    \            return array;\n        }\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3xml9gw.d(33): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpf3xml9gw.d(38): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3xml9gw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool even = (array[0] + array[array.length - 1]) %\
    \ 2 == 0;\n    if (even)\n    {\n        array.sort!((a, b) => b < a);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqvm0ag7.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpyqvm0ag7.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqvm0ag7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8it7fbnw.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8it7fbnw.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8it7fbnw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[$ - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) => a < b);\n \
    \   }\n    else\n    {\n        result.sort!((a, b) => a > b);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc4hh6sm5.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpc4hh6sm5.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc4hh6sm5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array = array.sort(std.numeric.comparisonFunctor!(\"\
    a > b\"));\n    }\n    else\n    {\n        array = array.sort(std.numeric.comparisonFunctor!(\"\
    a < b\"));\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ycyduzv.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3ycyduzv.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ycyduzv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        sort(array);\n    }\n    else\n  \
    \  {\n        sort(array, std.greater!long());\n    }\n    return array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3o7jip00.d(38): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp3o7jip00.d(42): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3o7jip00.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool odd = (array[0] + array[array.length - 1]) %\
    \ 2 == 1;\n    if (odd)\n    {\n        array.sort!((a, b) => a > b);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp06r9fklg.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp06r9fklg.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp06r9fklg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) =>\
    \ b - a);\n    }\n    else\n    {\n        result.sort!((a, b) => a - b);\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppj5ybi_p.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmppj5ybi_p.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppj5ybi_p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return (array[0] + array[1]) %\
    \ 2 == 0 ? array.reverse() : array;\n    long[] result = array.dup;\n    if ((result[0]\
    \ + result[$ - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) => b - a);\n\
    \    }\n    else\n    {\n        result.sort!((a, b) => a - b);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwgja2wut.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpwgja2wut.d(27):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmpwgja2wut.d(31): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpwgja2wut.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw4cj2f9c.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpw4cj2f9c.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw4cj2f9c.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx_uq2u8f.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpx_uq2u8f.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx_uq2u8f.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    \n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[$-1]) % 2 == 0)\n    {\n        result.sort!((a, b) => b - a);\n   \
    \ }\n    else\n    {\n        result.sort!((a, b) => a - b);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprjsfu2tg.d(29): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmprjsfu2tg.d(33): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprjsfu2tg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwg4q6gh0.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwg4q6gh0.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwg4q6gh0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] temp = new\
    \ long[array.length];\n    long[] temp2 = new long[array.length];\n    long[]\
    \ temp3 = new long[array.length];\n    long[] temp4 = new long[array.length];\n\
    \    long[] temp5 = new long[array.length];\n    long[] temp6 = new long[array.length];\n\
    \    long[] temp7 = new long[array.length];\n    long[] temp8 = new long[array.length];\n\
    \    long[] temp9 = new long[array.length];\n    long[] temp10 = new long[array.length];\n\
    \    long[] temp11 = new long[array.length];\n    long[] temp12 = new long[array.length];\n\
    \    long[] temp13 = new long[array.length];\n    long[] temp14 = new long[array.length];\n\
    \    long[] temp15 = new long[array.length];\n    long[] temp16 = new long[array.length];\n\
    \    long[] temp17 = new long[array.length];\n    long[] temp18 = new long[array.length];\n\
    \    long[] temp19 = new long[array.length];\n    long[] temp20 = new long[array.length];\n\
    \    long[] temp21 = new long[array.length];\n    long[] temp22 = new long[array.length];\n\
    \    long[] temp23 = new long[array.length];\n    long[] temp24 = new long[array.length];\n\
    \    long[] temp25 = new long[array.length];\n    long[] temp26 = new long[array.length];\n\
    \    long[] temp27 = new long[array.length];\n    long[] temp28 = new long[array.length];\n\
    \    long[] temp29 = new long[array.length];\n    long[] temp30 = new long[array.length];\n\
    \    long[] temp31 = new long[array.length];\n    long[] temp32 = new long[array.length];\n\
    \    long[] temp33 = new long[array.length];\n    long[] temp34 = new long[array.length];\n\
    \    long[] temp35 = new long[array.length];\n    long[] temp36 = new\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo22afg9v.d(58): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpo22afg9v.d(58): Error: semicolon expected, not `unittest`\\n/tmp/tmpo22afg9v.d(58):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpo22afg9v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        for(int\
    \ i = 0; i < array.length; i++)\n            result[i] = array[array.length -\
    \ i - 1];\n    }\n    else\n    {\n        for(int i = 0; i < array.length; i++)\n\
    \            result[i] = array[i];\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplrqwls1m.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428745]\\n??:? void tmplrqwls1m.__unittest_L38_C1()\
    \ [0x42814a]\\n??:? void tmplrqwls1m.__modtest() [0x4284c8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7ff]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b692]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43091d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dcc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308a9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b669]\\n??:? runModuleUnitTests [0x42c5d5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c08]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b8f]\\n??:? _d_run_main [0x428afa]\\n??:? main [0x4284db]\\\
    n??:? __libc_start_main [0x991c2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long sum = array[0]\
    \ + array[array.length - 1];\n    if(sum % 2 == 0)\n    {\n        sort(array,\
    \ (a, b) => b - a);\n    }\n    else\n    {\n        sort(array);\n    }\n   \
    \ return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8nxfp4ov.d(25): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp8nxfp4ov.d(29): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp8nxfp4ov.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if(result.length == 0)\n   \
    \     return result;\n    if(result.length == 1)\n        return result;\n   \
    \ if((result[0] + result[result.length - 1]) % 2 == 0)\n    {\n        result.sort!((a,\
    \ b) => b - a);\n    }\n    else\n    {\n        result.sort!((a, b) => a - b);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkkb6hdcs.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpkkb6hdcs.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkkb6hdcs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxkxgc2_6.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxkxgc2_6.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxkxgc2_6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    auto result\
    \ = array.dup;\n    if ((array[0] + array[$-1]) % 2 == 0)\n        result.sort!((a,\
    \ b) => b - a);\n    else\n        result.sort!((a, b) => a - b);\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7jpgssgd.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp7jpgssgd.d(27): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7jpgssgd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] sorted =\
    \ array.dup;\n    sorted.sort;\n    if (array.length == 0)\n        return result;\n\
    \    if (array.length == 1)\n        return array;\n    if (array[0] + array[array.length\
    \ - 1] % 2 == 0)\n    {\n        for (int i = 0; i < array.length; i++)\n    \
    \        result[i] = sorted[array.length - 1 - i];\n    }\n    else\n    {\n \
    \       for (int i = 0; i < array.length; i++)\n            result[i] = sorted[i];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcxx7g4uw.d(23): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcxx7g4uw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a < b);\n        return array;\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a > b);\n        return array;\n\
    \    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpek72hes6.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpek72hes6.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpek72hes6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a < b);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaxcujm3u.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpaxcujm3u.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaxcujm3u.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    int i = 0;\n  \
    \  int j = array.length - 1;\n    bool isOdd = (array[0] + array[array.length\
    \ - 1]) % 2 == 1;\n    while (i <= j)\n    {\n        if (isOdd)\n        {\n\
    \            if (array[i] % 2 == 1)\n            {\n                result[i]\
    \ = array[i];\n                i++;\n            }\n            else\n       \
    \     {\n                result[j] = array[i];\n                j--;\n       \
    \     }\n        }\n        else\n        {\n            if (array[i] % 2 == 1)\n\
    \            {\n                result[j] = array[i];\n                j--;\n\
    \            }\n            else\n            {\n                result[i] = array[i];\n\
    \                i++;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu6hudlt8.d(23): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpu6hudlt8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long sum = array[0] + array[array.length - 1];\n    if (sum\
    \ % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n \
    \   {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbclsfuwi.d(24): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbclsfuwi.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbclsfuwi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if (array.length == 0)\n   \
    \     return result;\n    if (array.length == 1)\n        return result;\n   \
    \ if (array[0] + array[$-1] % 2 == 0)\n        result.sort!((a, b) => a > b);\n\
    \    else\n        result.sort!((a, b) => a < b);\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp54bekgsv.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp54bekgsv.d(29): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54bekgsv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long sum = array[0]\
    \ + array[array.length - 1];\n    if (sum % 2 == 0)\n    {\n        sort(array);\n\
    \        reverse(array);\n        return array;\n    }\n    else\n    {\n    \
    \    sort(array);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpazcc0acl.d(25): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpazcc0acl.d(26): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpazcc0acl.d(31):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpazcc0acl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool odd = (array[0] + array[array.length - 1]) %\
    \ 2 == 1;\n    if (odd)\n    {\n        array.sort!((a, b) => a < b);\n    }\n\
    \    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt8sz8b2w.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpt8sz8b2w.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt8sz8b2w.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort(std.numeric.comparison);\n  \
    \      return array;\n    }\n    else\n    {\n        array.sort(std.numeric.comparison);\n\
    \        array.reverse();\n        return array;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp72zfza22.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp72zfza22.d(43): Error: no property `sort` for type `long[]`\\n/tmp/tmp72zfza22.d(44):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp72zfza22.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => a > b);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp82jb21d0.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp82jb21d0.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp82jb21d0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    long[] result = array.dup;\n    if ((array[0]\
    \ + array[$ - 1]) % 2 == 0)\n    {\n        result.sort!((a, b) => b - a);\n \
    \   }\n    else\n    {\n        result.sort!((a, b) => a - b);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2z6kvlyz.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp2z6kvlyz.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z6kvlyz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return array[0] > array[1] ? array\
    \ : array.reverse();\n    long sum = array[0] + array[array.length - 1];\n   \
    \ if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n   \
    \ else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppe74hutb.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmppe74hutb.d(27):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmppe74hutb.d(31): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppe74hutb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        long[] temp = new long[array.length];\n\
    \        for (int i = 0; i < array.length; i++)\n            temp[i] = array[i];\n\
    \        sort(temp);\n        for (int i = 0; i < array.length; i++)\n       \
    \     result[i] = temp[array.length - 1 - i];\n    }\n    else\n    {\n      \
    \  long[] temp = new long[array.length];\n        for (int i = 0; i < array.length;\
    \ i++)\n            temp[i] = array[i];\n        sort(temp);\n        for (int\
    \ i = 0; i < array.length; i++)\n            result[i] = temp[i];\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm3y8kebv.d(41): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpm3y8kebv.d(50): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpm3y8kebv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long sum = array[0] + array[array.length - 1];\n    if (sum\
    \ % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n \
    \   {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmporzj1qh_.d(24): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmporzj1qh_.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmporzj1qh_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if (array.length\
    \ == 0)\n        return result;\n    if (array.length == 1)\n        return array;\n\
    \    if (array.length == 2)\n    {\n        if (array[0] > array[1])\n       \
    \ {\n            result[0] = array[1];\n            result[1] = array[0];\n  \
    \      }\n        else\n        {\n            result[0] = array[0];\n       \
    \     result[1] = array[1];\n        }\n        return result;\n    }\n    if\
    \ ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort(std.numeric.comparison);\n\
    \        return array;\n    }\n    else\n    {\n        array.sort(std.numeric.comparison);\n\
    \        for (int i = 0; i < array.length; i++)\n        {\n            result[i]\
    \ = array[array.length - i - 1];\n        }\n        return result;\n    }\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf0bayz1.d(42): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjf0bayz1.d(47): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjf0bayz1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if(array.length == 0)\n    \
    \    return result;\n    if(array.length == 1)\n        return result;\n    if(array[0]\
    \ + array[array.length - 1] % 2 == 0)\n    {\n        result.sort!((a, b) => a\
    \ < b);\n    }\n    else\n    {\n        result.sort!((a, b) => a > b);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngkherei.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpngkherei.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngkherei.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b < a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcld9xcu0.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpcld9xcu0.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcld9xcu0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array = array.sort(std.numeric.comparisonFunctor!(\"\
    a > b\"));\n    }\n    else\n    {\n        array = array.sort(std.numeric.comparisonFunctor!(\"\
    a < b\"));\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxtyam5n8.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxtyam5n8.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxtyam5n8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    \n    long[] result = array.dup;\n    if ((result[0]\
    \ + result[$-1]) % 2 == 0)\n        result.sort!((a, b) => a > b);\n    else\n\
    \        result.sort!((a, b) => a < b);\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdyidg0ri.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpdyidg0ri.d(30): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdyidg0ri.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        result = array.dup;\n \
    \       result.sort!((a, b) => b < a);\n    }\n    else\n    {\n        result\
    \ = array.dup;\n        result.sort!((a, b) => a < b);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp88ltlh9j.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp88ltlh9j.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp88ltlh9j.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array = array.sort!((a, b) => a > b);\n\
    \    }\n    else\n    {\n        array = array.sort!((a, b) => a < b);\n    }\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwcav2ck6.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwcav2ck6.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwcav2ck6.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2) return array[0] > array[1] ? array\
    \ : array.reverse();\n    long sum = array[0] + array[array.length - 1];\n   \
    \ if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n   \
    \ else\n    {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6m44u27u.d(23): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp6m44u27u.d(27):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmp6m44u27u.d(31): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6m44u27u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isEven = (array[0] + array[array.length - 1])\
    \ % 2 == 0;\n    if (isEven)\n    {\n        long[] sorted = array.dup;\n    \
    \    sorted.sort(std.math.greater);\n        return sorted;\n    }\n    else\n\
    \    {\n        long[] sorted = array.dup;\n        sorted.sort();\n        return\
    \ sorted;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0mbk6ljz.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp0mbk6ljz.d(45): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0mbk6ljz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        sort(array);\n        return array;\n    }\n    sort(array);\n\
    \    reverse(array);\n    return array;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbrsjbh95.d(37): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpbrsjbh95.d(40): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmpbrsjbh95.d(41): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpbrsjbh95.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    bool odd\
    \ = (array[0] + array[array.length - 1]) % 2 == 1;\n    if (odd)\n        return\
    \ array.sort!((a, b) => a > b);\n    else\n        return array.sort!((a, b) =>\
    \ a < b);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6y8aomtm.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6y8aomtm.d(27): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y8aomtm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   bool isOdd = sum % 2 == 1;\n    if (isOdd)\n    {\n        array.sort();\n\
    \    }\n    else\n    {\n        array.sort!((a, b) => b - a)();\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_rtuall.d(39): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpq_rtuall.d(43): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_rtuall.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8uwhoft5.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8uwhoft5.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8uwhoft5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if(array.length\
    \ == 0)\n        return result;\n    if(array.length == 1)\n        return array;\n\
    \    if((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        sort(array);\n\
    \        reverse(array);\n        return array;\n    }\n    else\n    {\n    \
    \    sort(array);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_oe1udyu.d(28): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp_oe1udyu.d(29): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp_oe1udyu.d(34):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_oe1udyu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] temp = new\
    \ long[array.length];\n    long[] temp2 = new long[array.length];\n    long[]\
    \ temp3 = new long[array.length];\n    long[] temp4 = new long[array.length];\n\
    \    long[] temp5 = new long[array.length];\n    long[] temp6 = new long[array.length];\n\
    \    long[] temp7 = new long[array.length];\n    long[] temp8 = new long[array.length];\n\
    \    long[] temp9 = new long[array.length];\n    long[] temp10 = new long[array.length];\n\
    \    long[] temp11 = new long[array.length];\n    long[] temp12 = new long[array.length];\n\
    \    long[] temp13 = new long[array.length];\n    long[] temp14 = new long[array.length];\n\
    \    long[] temp15 = new long[array.length];\n    long[] temp16 = new long[array.length];\n\
    \    long[] temp17 = new long[array.length];\n    long[] temp18 = new long[array.length];\n\
    \    long[] temp19 = new long[array.length];\n    long[] temp20 = new long[array.length];\n\
    \    long[] temp21 = new long[array.length];\n    long[] temp22 = new long[array.length];\n\
    \    long[] temp23 = new long[array.length];\n    long[] temp24 = new long[array.length];\n\
    \    long[] temp25 = new long[array.length];\n    long[] temp26 = new long[array.length];\n\
    \    long[] temp27 = new long[array.length];\n    long[] temp28 = new long[array.length];\n\
    \    long[] temp29 = new long[array.length];\n    long[] temp30 = new long[array.length];\n\
    \    long[] temp31 = new long[array.length];\n    long[] temp32 = new long[array.length];\n\
    \    long[] temp33 = new long[array.length];\n    long[] temp34 = new long[array.length];\n\
    \    long[] temp35 = new long[array.length];\n    long[] temp36 = new\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp67bwd9e8.d(58): Error: basic type expected, not `unittest`\\\
    n/tmp/tmp67bwd9e8.d(58): Error: semicolon expected, not `unittest`\\n/tmp/tmp67bwd9e8.d(58):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp67bwd9e8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long[] result = array.dup;\n    bool isOdd = (array[0]\
    \ + array[$ - 1]) % 2 == 1;\n    if (isOdd)\n    {\n        result.sort!((a, b)\
    \ => a < b);\n    }\n    else\n    {\n        result.sort!((a, b) => a > b);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5buoe5dw.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5buoe5dw.d(31): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5buoe5dw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long[] result = new long[array.length];\n    if ((array[0]\
    \ + array[array.length - 1]) % 2 == 0)\n    {\n        for (int i = 0; i < array.length;\
    \ i++)\n        {\n            result[i] = array[array.length - 1 - i];\n    \
    \    }\n    }\n    else\n    {\n        for (int i = 0; i < array.length; i++)\n\
    \        {\n            result[i] = array[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6seuiyzs.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428835]\\n??:? void tmp6seuiyzs.__unittest_L52_C1()\
    \ [0x428236]\\n??:? void tmp6seuiyzs.__modtest() [0x4285b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b782]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430a0d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430999]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b759]\\n??:? runModuleUnitTests [0x42c6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428cf8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428c7f]\\n??:? _d_run_main [0x428bea]\\n??:? main [0x4285c7]\\\
    n??:? __libc_start_main [0x72806554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp950pya7j.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp950pya7j.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp950pya7j.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    \n    if\
    \ (array.length == 1)\n        return array;\n    \n    long sum = array[0] +\
    \ array[array.length - 1];\n    bool isEven = (sum % 2 == 0);\n    \n    if (isEven)\n\
    \        return array.sort!((a, b) => b - a);\n    else\n        return array.sort!((a,\
    \ b) => a - b);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuh_w5740.d(31): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpuh_w5740.d(33): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuh_w5740.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if (array.length\
    \ == 0)\n        return result;\n    if (array.length == 1)\n        return array;\n\
    \    if ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort!((a,\
    \ b) => b < a);\n        return array;\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a < b);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp065l3phu.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp065l3phu.d(33): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp065l3phu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] odd = new\
    \ long[array.length];\n    long[] even = new long[array.length];\n    int odd_index\
    \ = 0;\n    int even_index = 0;\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        if (array[i] % 2 == 0)\n        {\n            even[even_index]\
    \ = array[i];\n            even_index++;\n        }\n        else\n        {\n\
    \            odd[odd_index] = array[i];\n            odd_index++;\n        }\n\
    \    }\n    even = even[0..even_index];\n    odd = odd[0..odd_index];\n    even.sort();\n\
    \    odd.sort();\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n   \
    \ {\n        even.reverse();\n    }\n    else\n    {\n        odd.reverse();\n\
    \    }\n    int index = 0;\n    for (int i = 0; i < odd.length; i++)\n    {\n\
    \        result[index] = odd[i];\n        index++;\n    }\n    for (int i = 0;\
    \ i < even.length; i++)\n    {\n        result[index] = even[i];\n        index++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps08a640d.d(41): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmps08a640d.d(42): Error: no property `sort` for type `long[]`\\n/tmp/tmps08a640d.d(45):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmps08a640d.d(49):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmps08a640d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    long[] odd = new\
    \ long[array.length];\n    long[] even = new long[array.length];\n    int odd_index\
    \ = 0;\n    int even_index = 0;\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        if (array[i] % 2 == 0)\n        {\n            even[even_index]\
    \ = array[i];\n            even_index++;\n        }\n        else\n        {\n\
    \            odd[odd_index] = array[i];\n            odd_index++;\n        }\n\
    \    }\n    if (array.length > 0)\n    {\n        if ((array[0] + array[array.length\
    \ - 1]) % 2 == 0)\n        {\n            sort(even);\n            sort(odd);\n\
    \            for (int i = 0; i < odd_index; i++)\n            {\n            \
    \    result[i] = odd[i];\n            }\n            for (int i = 0; i < even_index;\
    \ i++)\n            {\n                result[odd_index + i] = even[i];\n    \
    \        }\n        }\n        else\n        {\n            sort(even);\n    \
    \        sort(odd);\n            for (int i = 0; i < odd_index; i++)\n       \
    \     {\n                result[i] = odd[odd_index - i - 1];\n            }\n\
    \            for (int i = 0; i < even_index; i++)\n            {\n           \
    \     result[odd_index + i] = even[even_index - i - 1];\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpirrt7zbu.d(43): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpirrt7zbu.d(44): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmpirrt7zbu.d(56): Error: undefined identifier\
    \ `sort`, did you mean function `sqrt`?\\n/tmp/tmpirrt7zbu.d(57): Error: undefined\
    \ identifier `sort`, did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpirrt7zbu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if (array.length\
    \ == 0)\n        return result;\n    if (array.length == 1)\n        return array;\n\
    \    if (array.length == 2)\n    {\n        if (array[0] > array[1])\n       \
    \ {\n            result[0] = array[1];\n            result[1] = array[0];\n  \
    \      }\n        else\n        {\n            result[0] = array[0];\n       \
    \     result[1] = array[1];\n        }\n        return result;\n    }\n    if\
    \ ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        array.sort!((a,\
    \ b) => a > b);\n        return array;\n    }\n    else\n    {\n        array.sort!((a,\
    \ b) => a < b);\n        return array;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpycg0sii4.d(42): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpycg0sii4.d(47): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpycg0sii4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = array.dup;\n    if(result.length == 0)\n   \
    \     return result;\n    if(result.length == 1)\n        return result;\n   \
    \ if((result[0] + result[result.length - 1]) % 2 == 0)\n    {\n        result.sort!((a,\
    \ b) => a > b);\n    }\n    else\n    {\n        result.sort!((a, b) => a < b);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbztpnp35.d(28): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbztpnp35.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbztpnp35.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long sum = array[0] + array[array.length - 1];\n    if(sum %\
    \ 2 == 0)\n    {\n        return array.sort(a => a).reverse();\n    }\n    else\n\
    \    {\n        return array.sort(a => a);\n    }\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo12lcc37.d(24): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpo12lcc37.d(28): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo12lcc37.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    auto sum = array[0]\
    \ + array[array.length - 1];\n    bool isOdd = sum % 2 == 1;\n    if (isOdd)\n\
    \    {\n        result = array.sort();\n    }\n    else\n    {\n        result\
    \ = array.sort!((a, b) => b - a);\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe1miq5vb.d(26): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpe1miq5vb.d(30): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe1miq5vb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a < b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a > b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuiw2b6vw.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpuiw2b6vw.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuiw2b6vw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    long sum = array[0] + array[array.length - 1];\n \
    \   if (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b < a);\n    }\n \
    \   else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ymf4mc5.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp_ymf4mc5.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ymf4mc5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    bool isOdd = (array[0] + array[array.length - 1])\
    \ % 2 == 1;\n    if (isOdd)\n    {\n        array.sort!((a, b) => a > b);\n  \
    \  }\n    else\n    {\n        array.sort!((a, b) => a < b);\n    }\n    return\
    \ array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwm768x28.d(38): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwm768x28.d(42): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwm768x28.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    if (array.length == 2)\n    {\n        if\
    \ (array[0] > array[1])\n        {\n            long temp = array[0];\n      \
    \      array[0] = array[1];\n            array[1] = temp;\n        }\n       \
    \ return array;\n    }\n    if ((array[0] + array[array.length - 1]) % 2 == 0)\n\
    \    {\n        array.sort!((a, b) => a > b);\n    }\n    else\n    {\n      \
    \  array.sort!((a, b) => a < b);\n    }\n    return array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcp8gnmxa.d(37): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpcp8gnmxa.d(41): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcp8gnmxa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] result = new long[array.length];\n    if (array.length\
    \ == 0)\n        return result;\n    if (array.length == 1)\n        return array;\n\
    \    if (array.length == 2)\n    {\n        if (array[0] > array[1])\n       \
    \ {\n            result[0] = array[1];\n            result[1] = array[0];\n  \
    \      }\n        else\n        {\n            result[0] = array[0];\n       \
    \     result[1] = array[1];\n        }\n        return result;\n    }\n    if\
    \ ((array[0] + array[array.length - 1]) % 2 == 0)\n    {\n        result = array.dup;\n\
    \        result.sort!((a, b) => a > b);\n    }\n    else\n    {\n        result\
    \ = array.dup;\n        result.sort!((a, b) => a < b);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8rbzrb56.d(43): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8rbzrb56.d(48): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8rbzrb56.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    long sum = array[0] + array[array.length - 1];\n    if\
    \ (sum % 2 == 0)\n    {\n        array.sort!((a, b) => b - a);\n    }\n    else\n\
    \    {\n        array.sort!((a, b) => a - b);\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ll9iaxp.d(26): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3ll9iaxp.d(30): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ll9iaxp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
